{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flutter Production-Grade App Guide","text":"<p>Welcome to the comprehensive guide for building production-grade Flutter applications. This documentation covers everything from setup to deployment, following industry best practices.</p>"},{"location":"#overview","title":"Overview","text":"<p>This guide is designed to take you from Flutter beginner to production-ready developer. Whether you're building your first mobile app or scaling an existing application, you'll find practical advice, best practices, and real-world examples.</p>"},{"location":"#what-youll-learn","title":"What You'll Learn","text":""},{"location":"#development-fundamentals","title":"Development Fundamentals","text":"<ul> <li>Setting up a robust development environment</li> <li>Organizing scalable project structures</li> <li>Implementing clean architecture patterns</li> <li>Managing state effectively across your application</li> </ul>"},{"location":"#production-readiness","title":"Production Readiness","text":"<ul> <li>Building secure authentication systems</li> <li>Implementing proper error handling and monitoring</li> <li>Optimizing performance for mobile devices</li> <li>Setting up automated testing and deployment pipelines</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Integrating platform channels and native features</li> <li>Implementing offline-first architectures</li> <li>Managing real-time data synchronization</li> <li>Deploying to app stores with confidence</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"graph TB     A[Flutter App] --&gt; B[Presentation Layer]     A --&gt; C[Business Logic Layer]     A --&gt; D[Data Layer]     A --&gt; E[Infrastructure Layer]      B --&gt; B1[Widgets]     B --&gt; B2[Screens]     B --&gt; B3[Navigation]      C --&gt; C1[Riverpod Providers]     C --&gt; C2[Services]     C --&gt; C3[Use Cases]      D --&gt; D1[State Management]     D --&gt; D2[API Client]     D --&gt; D3[Local Storage]     D --&gt; D4[Cache]      E --&gt; E1[Platform Channels]     E --&gt; E2[Native Modules]     E --&gt; E3[External Services]     E --&gt; E4[Device APIs]"},{"location":"#technology-stack","title":"Technology Stack","text":""},{"location":"#core-technologies","title":"Core Technologies","text":"<ul> <li>Flutter 3.35+ - UI framework for cross-platform development</li> <li>Dart 3.5+ - Programming language optimized for UI development</li> <li>Material Design 3 - Modern design system for consistent UI</li> </ul>"},{"location":"#state-management","title":"State Management","text":"<ul> <li>Riverpod - Recommended for complex state management</li> <li>BLoC Pattern - Event-driven architecture for predictable state</li> <li>Provider - Simple state management for smaller apps</li> </ul>"},{"location":"#backend-services","title":"Backend &amp; Services","text":"<ul> <li>Supabase - Open-source Firebase alternative</li> <li>PostgreSQL - Robust relational database</li> <li>Real-time subscriptions - Live data synchronization</li> <li>Authentication - Built-in auth with multiple providers</li> </ul>"},{"location":"#development-tools","title":"Development Tools","text":"<ul> <li>VS Code / Android Studio - Primary development environments</li> <li>Flutter DevTools - Performance and debugging tools</li> <li>Dart Analyzer - Static code analysis</li> <li>Flutter Test - Comprehensive testing framework</li> </ul>"},{"location":"#quick-start-paths","title":"Quick Start Paths","text":""},{"location":"#for-beginners","title":"\ud83d\ude80 For Beginners","text":"<p>New to Flutter? Start here for a guided introduction:</p> <ol> <li>Environment Setup - Install Flutter and set up your development environment</li> <li>Project Structure - Understand Flutter project organization</li> <li>Package Management - Learn to manage dependencies</li> <li>Basic Architecture - Start with simple patterns</li> </ol>"},{"location":"#for-intermediate-developers","title":"\ud83c\udfd7\ufe0f For Intermediate Developers","text":"<p>Have some Flutter experience? Focus on production patterns:</p> <ol> <li>State Management - Choose the right state solution</li> <li>Navigation - Implement complex routing</li> <li>Supabase Integration - Set up your backend</li> <li>Testing Strategies - Ensure code quality</li> </ol>"},{"location":"#for-advanced-teams","title":"\u26a1 For Advanced Teams","text":"<p>Building production apps? Jump to advanced topics:</p> <ol> <li>Platform Channels - Native integration</li> <li>Performance Optimization - Optimize for production</li> <li>Security Implementation - Secure your app</li> <li>Deployment Automation - Automate your releases</li> </ol>"},{"location":"#architecture-overview_1","title":"Architecture Overview","text":"graph TB     A[Flutter App] --&gt; B[Presentation Layer]     A --&gt; C[Business Logic Layer]     A --&gt; D[Data Layer]     A --&gt; E[Core Layer]      B --&gt; B1[Widgets]     B --&gt; B2[Screens]     B --&gt; B3[Navigation]      C --&gt; C1[BLoC/Cubit]     C --&gt; C2[Providers]     C --&gt; C3[Use Cases]      D --&gt; D1[Repositories]     D --&gt; D2[Data Sources]     D --&gt; D3[Models]      E --&gt; E1[Utilities]     E --&gt; E2[Constants]     E --&gt; E3[Configuration]"},{"location":"#technology-stack_1","title":"Technology Stack","text":""},{"location":"#core-technologies_1","title":"Core Technologies","text":"<ul> <li>Flutter 3.35+</li> <li>Dart 3.5+</li> <li>Supabase - Backend as a Service</li> <li>Riverpod - State management</li> </ul>"},{"location":"#recommended-packages","title":"Recommended Packages","text":""},{"location":"#state-management_1","title":"State Management","text":"<ul> <li>Riverpod - Modern state management</li> <li>flutter_bloc - BLoC pattern implementation</li> <li>provider - Simple state management</li> </ul>"},{"location":"#ui-styling","title":"UI &amp; Styling","text":"<ul> <li>flutter_screenutil - Screen adaptation</li> <li>cached_network_image - Image caching</li> <li>flutter_svg - SVG support</li> <li>lottie - Animations</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>go_router - Declarative routing</li> <li>auto_route - Code generation routing</li> </ul>"},{"location":"#development-tools_1","title":"Development Tools","text":"<ul> <li>flutter_lints - Linting rules</li> <li>build_runner - Code generation</li> <li>flutter_test - Testing framework</li> <li>integration_test - Integration testing</li> </ul>"},{"location":"#quick-start-paths_1","title":"Quick Start Paths","text":""},{"location":"#for-beginners_1","title":"For Beginners","text":"<ol> <li>Environment Setup</li> <li>Project Structure</li> <li>Supabase Setup</li> <li>Widget Design</li> <li>Design Systems</li> </ol>"},{"location":"#for-intermediate-developers_1","title":"For Intermediate Developers","text":"<ol> <li>App Architecture</li> <li>State Management</li> <li>Navigation</li> <li>Supabase Usage</li> <li>Testing Guide</li> </ol>"},{"location":"#for-advanced-developers","title":"For Advanced Developers","text":"<ol> <li>Performance Optimization</li> <li>Security Implementation</li> <li>CI/CD Setup</li> <li>Monitoring &amp; Analytics</li> </ol>"},{"location":"#development-workflow","title":"Development Workflow","text":"flowchart LR     A[Setup Environment] --&gt; B[Create Project]     B --&gt; C[Design Architecture]     C --&gt; D[Implement Features]     D --&gt; E[Write Tests]     E --&gt; F[Optimize Performance]     F --&gt; G[Deploy to Stores]     G --&gt; H[Monitor &amp; Maintain]     H --&gt; D"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before diving into this guide, you should have:</p> <ul> <li>Basic knowledge of Dart programming language</li> <li>Understanding of Flutter fundamentals</li> <li>Familiarity with mobile app concepts</li> <li>A computer capable of running Flutter development tools</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the comprehensive guides in each section</li> <li>GitHub Issues: Report documentation bugs and improvements</li> <li>Discussions: Ask questions and get community support</li> <li>Examples: Check practical implementations in the project</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>This documentation is a living resource. Contributions are welcome:</p> <ol> <li>Report Issues: Found something unclear or outdated?</li> <li>Suggest Improvements: Have a better way to explain something?</li> <li>Add Examples: Real-world examples are always valuable</li> <li>Share Best Practices: Learned something new? Share it with the community</li> </ol>"},{"location":"#license","title":"License","text":"<p>This documentation is open source and available under the MIT License.</p> <p>Ready to build amazing Flutter apps? Start with Environment Setup!</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to the Flutter Instagram Clone project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Complete MkDocs documentation system</li> <li>Comprehensive Flutter development guide</li> <li>Production-ready project structure</li> <li>Supabase backend integration</li> <li>Clean architecture implementation</li> </ul>"},{"location":"CHANGELOG/#100-2025-01-18","title":"[1.0.0] - 2025-01-18","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Initial Flutter project setup</li> <li>Complete documentation structure with MkDocs</li> <li>Environment setup guides for all platforms</li> <li>Supabase integration documentation</li> <li>State management patterns (Riverpod, BLoC, Provider)</li> <li>Navigation system with Go Router</li> <li>UI/UX design systems with Material Design 3</li> <li>Comprehensive testing strategies</li> <li>Deployment guides for iOS, Android, and Web</li> <li>CI/CD workflows with GitHub Actions</li> <li>Security best practices</li> <li>Performance optimization guides</li> <li>Monitoring and analytics setup</li> <li>Maintenance and troubleshooting guides</li> </ul>"},{"location":"CHANGELOG/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Setup &amp; Configuration: Environment, project structure, Supabase</li> <li>Architecture: Clean architecture, state management, navigation</li> <li>UI Development: Design systems, responsive design, animations</li> <li>Platform Integration: Platform channels, permissions, native features</li> <li>Development Tools: Testing, debugging, code quality, performance</li> <li>Data &amp; Networking: API integration, offline support, real-time data</li> <li>Security: Authentication, API security, data protection</li> <li>Deployment: CI/CD, app stores, build configuration</li> <li>Monitoring: Analytics, crash reporting, performance tracking</li> <li>Maintenance: Version management, migrations, legacy support</li> </ul>"},{"location":"CHANGELOG/#technical-stack","title":"Technical Stack","text":"<ul> <li>Flutter 3.35+ with Dart 3.5+</li> <li>Supabase for backend services</li> <li>Riverpod for state management</li> <li>Go Router for navigation</li> <li>Material Design 3 for UI components</li> <li>MkDocs for documentation</li> </ul>"},{"location":"CHANGELOG/#features-covered","title":"Features Covered","text":"<ul> <li>User authentication (email/password, OAuth)</li> <li>Real-time feed with posts, likes, comments</li> <li>Image upload and storage</li> <li>User profiles and following system</li> <li>Stories functionality</li> <li>Push notifications</li> <li>Offline support</li> <li>Cross-platform responsive design</li> </ul>"},{"location":"CHANGELOG/#development-tools","title":"Development Tools","text":"<ul> <li>Complete testing setup (unit, widget, integration)</li> <li>Code quality tools and linting</li> <li>Performance monitoring</li> <li>Debugging guides</li> <li>Development scripts</li> </ul>"},{"location":"CHANGELOG/#deployment","title":"Deployment","text":"<ul> <li>iOS App Store deployment</li> <li>Google Play Store deployment</li> <li>Web deployment</li> <li>CI/CD automation</li> <li>Environment configuration</li> </ul>"},{"location":"CHANGELOG/#010-2025-01-18","title":"[0.1.0] - 2025-01-18","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Initial project structure</li> <li>Basic Flutter app setup</li> <li>Documentation framework</li> <li>GitHub repository setup</li> </ul>"},{"location":"CHANGELOG/#release-notes","title":"Release Notes","text":""},{"location":"CHANGELOG/#version-100-production-ready","title":"Version 1.0.0 - Production Ready","text":"<p>This release marks the completion of the comprehensive Flutter Instagram clone documentation. The project now includes:</p>"},{"location":"CHANGELOG/#complete-development-guide","title":"\ud83c\udfaf Complete Development Guide","text":"<ul> <li>Step-by-step setup instructions</li> <li>Production-ready architecture patterns</li> <li>Best practices for Flutter development</li> <li>Real-world implementation examples</li> </ul>"},{"location":"CHANGELOG/#instagram-clone-features","title":"\ud83d\udcf1 Instagram Clone Features","text":"<ul> <li>User authentication and profiles</li> <li>Photo/video sharing with filters</li> <li>Real-time feed and interactions</li> <li>Stories and messaging</li> <li>Push notifications</li> <li>Offline functionality</li> </ul>"},{"location":"CHANGELOG/#architecture-patterns","title":"\ud83c\udfd7\ufe0f Architecture &amp; Patterns","text":"<ul> <li>Clean Architecture implementation</li> <li>Multiple state management solutions</li> <li>Scalable project structure</li> <li>Testable code patterns</li> </ul>"},{"location":"CHANGELOG/#development-tools_1","title":"\ud83d\udd27 Development Tools","text":"<ul> <li>Comprehensive testing strategies</li> <li>Code quality automation</li> <li>Performance optimization</li> <li>Debugging techniques</li> </ul>"},{"location":"CHANGELOG/#production-deployment","title":"\ud83d\ude80 Production Deployment","text":"<ul> <li>App store submission guides</li> <li>CI/CD automation</li> <li>Environment management</li> <li>Monitoring and analytics</li> </ul>"},{"location":"CHANGELOG/#documentation-system","title":"\ud83d\udcda Documentation System","text":"<ul> <li>MkDocs with Material theme</li> <li>Interactive diagrams with Mermaid</li> <li>Code examples and snippets</li> <li>Cross-referenced guides</li> </ul>"},{"location":"CHANGELOG/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Clone the repository <pre><code>git clone https://github.com/rcdelacruz/flutter_instagram_app.git\n</code></pre></p> </li> <li> <p>Install documentation dependencies <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Start the documentation server <pre><code>mkdocs serve\n</code></pre></p> </li> <li> <p>Follow the setup guides in the documentation</p> </li> </ol>"},{"location":"CHANGELOG/#contributing","title":"Contributing","text":"<p>This documentation is a living resource. Contributions are welcome:</p> <ul> <li>Report issues and suggest improvements</li> <li>Submit pull requests for documentation updates</li> <li>Share your implementation experiences</li> <li>Help translate content for international developers</li> </ul>"},{"location":"CHANGELOG/#support","title":"Support","text":"<ul> <li>Documentation: Complete guides available at the documentation site</li> <li>GitHub Issues: Report bugs and request features</li> <li>Discussions: Community support and questions</li> <li>Examples: Practical implementations in the project</li> </ul> <p>This changelog will be updated with each release to track all changes and improvements to the project.</p>"},{"location":"setup-mkdocs/","title":"MkDocs Setup Guide","text":"<p>Quick setup guide for the Flutter Production Documentation.</p>"},{"location":"setup-mkdocs/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"setup-mkdocs/#installation","title":"Installation","text":""},{"location":"setup-mkdocs/#option-1-using-pip-directly","title":"Option 1: Using pip directly","text":"<pre><code>pip install mkdocs mkdocs-material pymdown-extensions\n</code></pre>"},{"location":"setup-mkdocs/#option-2-using-requirementstxt","title":"Option 2: Using requirements.txt","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"setup-mkdocs/#running-the-documentation","title":"Running the Documentation","text":""},{"location":"setup-mkdocs/#development-server","title":"Development Server","text":"<pre><code># Start the development server\nmkdocs serve\n\n# The documentation will be available at http://127.0.0.1:8000\n</code></pre>"},{"location":"setup-mkdocs/#building-for-production","title":"Building for Production","text":"<pre><code># Build static files\nmkdocs build\n\n# Files will be generated in the 'site' directory\n</code></pre>"},{"location":"setup-mkdocs/#deploying-to-github-pages","title":"Deploying to GitHub Pages","text":"<pre><code># Deploy to GitHub Pages (requires git repository)\nmkdocs gh-deploy\n</code></pre>"},{"location":"setup-mkdocs/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<p>The documentation includes mermaid diagrams for architecture visualization. The diagrams are automatically rendered using the included JavaScript configuration.</p>"},{"location":"setup-mkdocs/#to-enable-mermaid-rendering-locally","title":"To enable mermaid rendering locally:","text":"<ol> <li>Option A: Use GitHub Pages - GitHub automatically renders mermaid diagrams</li> <li>Option B: Local development - Already configured with mermaid.js</li> <li>Option C: Use online mermaid editor - Copy diagram code to https://mermaid.live/</li> </ol>"},{"location":"setup-mkdocs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setup-mkdocs/#common-issues","title":"Common Issues","text":"<ol> <li>Python version: Ensure you're using Python 3.8+</li> <li>Permission errors: Use <code>pip install --user</code> if needed</li> <li>Module not found: Make sure all dependencies are installed</li> </ol>"},{"location":"setup-mkdocs/#verification","title":"Verification","text":"<pre><code># Check mkdocs installation\nmkdocs --version\n\n# Check if all plugins are working\nmkdocs serve --verbose\n</code></pre>"},{"location":"setup-mkdocs/#documentation-structure","title":"Documentation Structure","text":"<p>The documentation follows this structure:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                            # Main landing page\n\u251c\u2500\u2500 setup/                              # Environment setup guides\n\u251c\u2500\u2500 architecture/                       # App architecture patterns\n\u251c\u2500\u2500 ui/                                 # UI development guides\n\u251c\u2500\u2500 native/                             # Platform integration\n\u251c\u2500\u2500 tools/                              # Development tools\n\u251c\u2500\u2500 data/                               # Data management\n\u251c\u2500\u2500 security/                           # Security implementation\n\u251c\u2500\u2500 deployment/                         # CI/CD and deployment\n\u251c\u2500\u2500 monitoring/                         # Monitoring and analytics\n\u251c\u2500\u2500 maintenance/                        # App maintenance\n\u251c\u2500\u2500 troubleshooting/                    # Common issues and solutions\n\u251c\u2500\u2500 stylesheets/                        # Custom CSS\n\u2514\u2500\u2500 javascripts/                        # Custom JavaScript\n</code></pre>"},{"location":"setup-mkdocs/#next-steps","title":"Next Steps","text":"<ol> <li>Run <code>mkdocs serve</code> to start the development server</li> <li>Navigate to http://127.0.0.1:8000 to view the documentation</li> <li>Edit markdown files in the <code>docs/</code> directory</li> <li>Changes will automatically reload in the browser</li> </ol> <p>The documentation is now ready to use with full Flutter-specific content!</p>"},{"location":"architecture/app-architecture/","title":"Flutter App Architecture","text":"<p>Learn how to design scalable, maintainable Flutter applications using proven architectural patterns that work with any project structure.</p> <p>Related Reading: See Project Structure for guidance on organizing your files and folders.</p>"},{"location":"architecture/app-architecture/#architecture-principles","title":"Architecture Principles","text":""},{"location":"architecture/app-architecture/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<ul> <li>Presentation Layer: Widgets, screens, and UI logic</li> <li>Business Logic Layer: State management, use cases, and business rules</li> <li>Data Layer: Repositories, data sources, and models</li> <li>Core Layer: Utilities, constants, and configuration</li> </ul>"},{"location":"architecture/app-architecture/#2-dependency-inversion","title":"2. Dependency Inversion","text":"<ul> <li>High-level modules should not depend on low-level modules</li> <li>Both should depend on abstractions</li> <li>Use dependency injection for better testability</li> </ul>"},{"location":"architecture/app-architecture/#3-single-responsibility","title":"3. Single Responsibility","text":"<ul> <li>Each class should have one reason to change</li> <li>Widgets should focus on UI presentation</li> <li>Services should handle specific business logic</li> </ul>"},{"location":"architecture/app-architecture/#clean-architecture-in-flutter","title":"Clean Architecture in Flutter","text":"graph TB     A[Presentation Layer] --&gt; B[Domain Layer]     B --&gt; C[Data Layer]      A1[Widgets] --&gt; A     A2[Screens] --&gt; A     A3[State Management] --&gt; A      B1[Entities] --&gt; B     B2[Use Cases] --&gt; B     B3[Repositories Interface] --&gt; B      C1[Models] --&gt; C     C2[Repositories Implementation] --&gt; C     C3[Data Sources] --&gt; C     C4[External APIs] --&gt; C"},{"location":"architecture/app-architecture/#presentation-layer","title":"Presentation Layer","text":"<p>Responsibilities: - UI rendering and user interactions - State management (UI state) - Navigation handling - Input validation and formatting</p> <p>Components: <pre><code>// Screens\nclass HomeScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final feedState = ref.watch(feedProvider);\n\n    return Scaffold(\n      body: feedState.when(\n        data: (posts) =&gt; PostsList(posts: posts),\n        loading: () =&gt; const LoadingIndicator(),\n        error: (error, stack) =&gt; ErrorWidget(error),\n      ),\n    );\n  }\n}\n\n// Widgets\nclass PostCard extends StatelessWidget {\n  final Post post;\n\n  const PostCard({required this.post});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Column(\n        children: [\n          PostHeader(user: post.user),\n          PostImage(imageUrl: post.imageUrl),\n          PostActions(post: post),\n          PostCaption(caption: post.caption),\n        ],\n      ),\n    );\n  }\n}\n</code></pre></p>"},{"location":"architecture/app-architecture/#domain-layer","title":"Domain Layer","text":"<p>Responsibilities: - Business logic and rules - Entity definitions - Use case implementations - Repository interfaces</p> <p>Components: <pre><code>// Entities\nclass Post {\n  final String id;\n  final String userId;\n  final String imageUrl;\n  final String caption;\n  final DateTime createdAt;\n  final List&lt;Like&gt; likes;\n  final List&lt;Comment&gt; comments;\n\n  const Post({\n    required this.id,\n    required this.userId,\n    required this.imageUrl,\n    required this.caption,\n    required this.createdAt,\n    required this.likes,\n    required this.comments,\n  });\n}\n\n// Use Cases\nclass GetFeedUseCase {\n  final PostRepository _repository;\n\n  GetFeedUseCase(this._repository);\n\n  Future&lt;List&lt;Post&gt;&gt; call(String userId) async {\n    return await _repository.getFeed(userId);\n  }\n}\n\n// Repository Interface\nabstract class PostRepository {\n  Future&lt;List&lt;Post&gt;&gt; getFeed(String userId);\n  Future&lt;Post&gt; createPost(CreatePostRequest request);\n  Future&lt;void&gt; likePost(String postId, String userId);\n  Future&lt;void&gt; deletePost(String postId);\n}\n</code></pre></p>"},{"location":"architecture/app-architecture/#data-layer","title":"Data Layer","text":"<p>Responsibilities: - Data persistence and retrieval - API communication - Data transformation - Caching strategies</p> <p>Components: <pre><code>// Repository Implementation\nclass PostRepositoryImpl implements PostRepository {\n  final PostRemoteDataSource _remoteDataSource;\n  final PostLocalDataSource _localDataSource;\n\n  PostRepositoryImpl(this._remoteDataSource, this._localDataSource);\n\n  @override\n  Future&lt;List&lt;Post&gt;&gt; getFeed(String userId) async {\n    try {\n      final posts = await _remoteDataSource.getFeed(userId);\n      await _localDataSource.cachePosts(posts);\n      return posts.map((model) =&gt; model.toEntity()).toList();\n    } catch (e) {\n      // Fallback to cached data\n      final cachedPosts = await _localDataSource.getCachedPosts();\n      return cachedPosts.map((model) =&gt; model.toEntity()).toList();\n    }\n  }\n}\n\n// Data Sources\nclass PostRemoteDataSource {\n  final SupabaseClient _client;\n\n  PostRemoteDataSource(this._client);\n\n  Future&lt;List&lt;PostModel&gt;&gt; getFeed(String userId) async {\n    final response = await _client\n        .from('posts')\n        .select('*, users(*), likes(*), comments(*)')\n        .order('created_at', ascending: false);\n\n    return response.map((json) =&gt; PostModel.fromJson(json)).toList();\n  }\n}\n</code></pre></p>"},{"location":"architecture/app-architecture/#state-management-architecture","title":"State Management Architecture","text":""},{"location":"architecture/app-architecture/#riverpod-pattern","title":"Riverpod Pattern","text":"<pre><code>// Providers\nfinal postRepositoryProvider = Provider&lt;PostRepository&gt;((ref) {\n  final remoteDataSource = ref.read(postRemoteDataSourceProvider);\n  final localDataSource = ref.read(postLocalDataSourceProvider);\n  return PostRepositoryImpl(remoteDataSource, localDataSource);\n});\n\nfinal getFeedUseCaseProvider = Provider&lt;GetFeedUseCase&gt;((ref) {\n  final repository = ref.read(postRepositoryProvider);\n  return GetFeedUseCase(repository);\n});\n\nfinal feedProvider = FutureProvider&lt;List&lt;Post&gt;&gt;((ref) async {\n  final useCase = ref.read(getFeedUseCaseProvider);\n  final user = ref.read(currentUserProvider);\n  return await useCase(user.id);\n});\n\n// State Notifier for complex state\nclass FeedNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt; {\n  final GetFeedUseCase _getFeedUseCase;\n  final CreatePostUseCase _createPostUseCase;\n\n  FeedNotifier(this._getFeedUseCase, this._createPostUseCase) \n      : super(const AsyncValue.loading());\n\n  Future&lt;void&gt; loadFeed(String userId) async {\n    state = const AsyncValue.loading();\n    try {\n      final posts = await _getFeedUseCase(userId);\n      state = AsyncValue.data(posts);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n\n  Future&lt;void&gt; createPost(CreatePostRequest request) async {\n    try {\n      final newPost = await _createPostUseCase(request);\n      state = state.whenData((posts) =&gt; [newPost, ...posts]);\n    } catch (error) {\n      // Handle error\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/app-architecture/#bloc-pattern-alternative","title":"BLoC Pattern (Alternative)","text":"<pre><code>// Events\nabstract class FeedEvent {}\nclass LoadFeed extends FeedEvent {\n  final String userId;\n  LoadFeed(this.userId);\n}\n\n// States\nabstract class FeedState {}\nclass FeedInitial extends FeedState {}\nclass FeedLoading extends FeedState {}\nclass FeedLoaded extends FeedState {\n  final List&lt;Post&gt; posts;\n  FeedLoaded(this.posts);\n}\nclass FeedError extends FeedState {\n  final String message;\n  FeedError(this.message);\n}\n\n// BLoC\nclass FeedBloc extends Bloc&lt;FeedEvent, FeedState&gt; {\n  final GetFeedUseCase _getFeedUseCase;\n\n  FeedBloc(this._getFeedUseCase) : super(FeedInitial()) {\n    on&lt;LoadFeed&gt;(_onLoadFeed);\n  }\n\n  Future&lt;void&gt; _onLoadFeed(LoadFeed event, Emitter&lt;FeedState&gt; emit) async {\n    emit(FeedLoading());\n    try {\n      final posts = await _getFeedUseCase(event.userId);\n      emit(FeedLoaded(posts));\n    } catch (error) {\n      emit(FeedError(error.toString()));\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/app-architecture/#navigation-architecture","title":"Navigation Architecture","text":""},{"location":"architecture/app-architecture/#go-router-setup","title":"Go Router Setup","text":"<pre><code>// Route Configuration\nfinal goRouter = GoRouter(\n  initialLocation: '/splash',\n  routes: [\n    GoRoute(\n      path: '/splash',\n      builder: (context, state) =&gt; const SplashScreen(),\n    ),\n    GoRoute(\n      path: '/auth',\n      builder: (context, state) =&gt; const AuthScreen(),\n      routes: [\n        GoRoute(\n          path: '/login',\n          builder: (context, state) =&gt; const LoginScreen(),\n        ),\n        GoRoute(\n          path: '/register',\n          builder: (context, state) =&gt; const RegisterScreen(),\n        ),\n      ],\n    ),\n    ShellRoute(\n      builder: (context, state, child) =&gt; MainShell(child: child),\n      routes: [\n        GoRoute(\n          path: '/home',\n          builder: (context, state) =&gt; const HomeScreen(),\n        ),\n        GoRoute(\n          path: '/profile/:userId',\n          builder: (context, state) =&gt; ProfileScreen(\n            userId: state.pathParameters['userId']!,\n          ),\n        ),\n      ],\n    ),\n  ],\n  redirect: (context, state) {\n    final isAuthenticated = /* check auth state */;\n    final isOnAuthPage = state.location.startsWith('/auth');\n\n    if (!isAuthenticated &amp;&amp; !isOnAuthPage) {\n      return '/auth/login';\n    }\n    if (isAuthenticated &amp;&amp; isOnAuthPage) {\n      return '/home';\n    }\n    return null;\n  },\n);\n</code></pre>"},{"location":"architecture/app-architecture/#error-handling-architecture","title":"Error Handling Architecture","text":""},{"location":"architecture/app-architecture/#centralized-error-handling","title":"Centralized Error Handling","text":"<pre><code>// Error Types\nabstract class AppError {\n  final String message;\n  final String? code;\n\n  const AppError(this.message, {this.code});\n}\n\nclass NetworkError extends AppError {\n  const NetworkError(String message) : super(message, code: 'NETWORK_ERROR');\n}\n\nclass AuthenticationError extends AppError {\n  const AuthenticationError(String message) : super(message, code: 'AUTH_ERROR');\n}\n\n// Error Handler\nclass ErrorHandler {\n  static void handle(Object error, StackTrace stackTrace) {\n    if (error is AppError) {\n      _handleAppError(error);\n    } else {\n      _handleUnknownError(error, stackTrace);\n    }\n  }\n\n  static void _handleAppError(AppError error) {\n    // Log error\n    logger.error(error.message, error: error);\n\n    // Show user-friendly message\n    switch (error.runtimeType) {\n      case NetworkError:\n        _showSnackBar('Network connection error');\n        break;\n      case AuthenticationError:\n        _navigateToLogin();\n        break;\n      default:\n        _showSnackBar(error.message);\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/app-architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"architecture/app-architecture/#unit-tests","title":"Unit Tests","text":"<pre><code>// Test Setup\nvoid main() {\n  group('GetFeedUseCase', () {\n    late MockPostRepository mockRepository;\n    late GetFeedUseCase useCase;\n\n    setUp(() {\n      mockRepository = MockPostRepository();\n      useCase = GetFeedUseCase(mockRepository);\n    });\n\n    test('should return list of posts when repository call is successful', () async {\n      // Arrange\n      final posts = [Post(/* test data */)];\n      when(mockRepository.getFeed(any)).thenAnswer((_) async =&gt; posts);\n\n      // Act\n      final result = await useCase('user123');\n\n      // Assert\n      expect(result, equals(posts));\n      verify(mockRepository.getFeed('user123')).called(1);\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/app-architecture/#widget-tests","title":"Widget Tests","text":"<pre><code>void main() {\n  group('PostCard', () {\n    testWidgets('should display post information correctly', (tester) async {\n      // Arrange\n      final post = Post(/* test data */);\n\n      // Act\n      await tester.pumpWidget(\n        MaterialApp(\n          home: PostCard(post: post),\n        ),\n      );\n\n      // Assert\n      expect(find.text(post.caption), findsOneWidget);\n      expect(find.byType(CachedNetworkImage), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/app-architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/app-architecture/#1-widget-optimization","title":"1. Widget Optimization","text":"<pre><code>// Use const constructors\nclass PostCard extends StatelessWidget {\n  const PostCard({super.key, required this.post});\n\n  // Implement efficient build methods\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: Card(/* widget tree */),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/app-architecture/#2-state-management-optimization","title":"2. State Management Optimization","text":"<pre><code>// Use selective rebuilds\nConsumer(\n  builder: (context, ref, child) {\n    final posts = ref.watch(feedProvider.select((state) =&gt; state.posts));\n    return PostsList(posts: posts);\n  },\n)\n</code></pre>"},{"location":"architecture/app-architecture/#3-memory-management","title":"3. Memory Management","text":"<pre><code>// Dispose resources properly\nclass FeedScreen extends StatefulWidget {\n  @override\n  _FeedScreenState createState() =&gt; _FeedScreenState();\n}\n\nclass _FeedScreenState extends State&lt;FeedScreen&gt; {\n  late ScrollController _scrollController;\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController = ScrollController();\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"architecture/app-architecture/#next-steps","title":"Next Steps","text":"<ol> <li>Choose your architecture pattern based on project complexity</li> <li>Set up dependency injection for better testability</li> <li>Implement error handling throughout your app</li> <li>Write tests for critical business logic</li> <li>Proceed to State Management</li> </ol> <p>Pro Tip: Start with a simple architecture and evolve it as your app grows. Clean architecture provides a solid foundation for scalable Flutter applications.</p>"},{"location":"architecture/navigation/","title":"Flutter Navigation","text":"<p>Comprehensive guide to navigation patterns in Flutter applications, covering different approaches and best practices for routing.</p>"},{"location":"architecture/navigation/#navigation-overview","title":"Navigation Overview","text":"<p>Flutter offers multiple navigation solutions, each with different strengths and use cases.</p>     graph TB     A[Navigation Solutions] --&gt; B[Navigator 1.0]     A --&gt; C[Navigator 2.0]     A --&gt; D[Third-Party]      B --&gt; B1[Basic Navigation]     B --&gt; B2[Named Routes]      C --&gt; C1[Router Delegate]     C --&gt; C2[Route Information Parser]      D --&gt; D1[Go Router]     D --&gt; D2[Auto Route]     D --&gt; D3[Fluro]"},{"location":"architecture/navigation/#decision-matrix","title":"Decision Matrix","text":"App Complexity Deep Linking Web Support Recommended Solution Simple No No Navigator 1.0 Medium Yes Yes Go Router Complex Yes Yes Auto Route Enterprise Yes Yes Custom Router"},{"location":"architecture/navigation/#1-go-router-recommended","title":"1. Go Router (Recommended)","text":""},{"location":"architecture/navigation/#why-go-router","title":"Why Go Router?","text":"<ul> <li>Declarative routing: Define routes in a clear, structured way</li> <li>Deep linking: Built-in support for URL-based navigation</li> <li>Type safety: Compile-time route validation</li> <li>Web support: Excellent web integration</li> <li>Maintained by Flutter team: Official support and updates</li> </ul>"},{"location":"architecture/navigation/#setup","title":"Setup","text":"<pre><code>dependencies:\n  go_router: ^12.0.0\n</code></pre>"},{"location":"architecture/navigation/#basic-configuration","title":"Basic Configuration","text":"<pre><code>// routes.dart\nfinal GoRouter router = GoRouter(\n  initialLocation: '/splash',\n  routes: [\n    // Splash Screen\n    GoRoute(\n      path: '/splash',\n      name: 'splash',\n      builder: (context, state) =&gt; const SplashScreen(),\n    ),\n\n    // Authentication Routes\n    GoRoute(\n      path: '/auth',\n      name: 'auth',\n      builder: (context, state) =&gt; const AuthScreen(),\n      routes: [\n        GoRoute(\n          path: '/login',\n          name: 'login',\n          builder: (context, state) =&gt; const LoginScreen(),\n        ),\n        GoRoute(\n          path: '/register',\n          name: 'register',\n          builder: (context, state) =&gt; const RegisterScreen(),\n        ),\n        GoRoute(\n          path: '/forgot-password',\n          name: 'forgot-password',\n          builder: (context, state) =&gt; const ForgotPasswordScreen(),\n        ),\n      ],\n    ),\n\n    // Main App Shell\n    ShellRoute(\n      builder: (context, state, child) =&gt; MainShell(child: child),\n      routes: [\n        GoRoute(\n          path: '/home',\n          name: 'home',\n          builder: (context, state) =&gt; const HomeScreen(),\n        ),\n        GoRoute(\n          path: '/search',\n          name: 'search',\n          builder: (context, state) =&gt; const SearchScreen(),\n        ),\n        GoRoute(\n          path: '/profile/:userId',\n          name: 'profile',\n          builder: (context, state) =&gt; ProfileScreen(\n            userId: state.pathParameters['userId']!,\n          ),\n        ),\n        GoRoute(\n          path: '/post/:postId',\n          name: 'post',\n          builder: (context, state) =&gt; PostDetailScreen(\n            postId: state.pathParameters['postId']!,\n          ),\n        ),\n      ],\n    ),\n\n    // Modal Routes\n    GoRoute(\n      path: '/create-post',\n      name: 'create-post',\n      pageBuilder: (context, state) =&gt; MaterialPage(\n        fullscreenDialog: true,\n        child: const CreatePostScreen(),\n      ),\n    ),\n  ],\n\n  // Redirect Logic\n  redirect: (context, state) {\n    final isAuthenticated = /* check auth state */;\n    final isOnAuthPage = state.location.startsWith('/auth');\n    final isOnSplash = state.location == '/splash';\n\n    // Show splash screen first\n    if (!isOnSplash &amp;&amp; /* app is initializing */) {\n      return '/splash';\n    }\n\n    // Redirect to login if not authenticated\n    if (!isAuthenticated &amp;&amp; !isOnAuthPage &amp;&amp; !isOnSplash) {\n      return '/auth/login';\n    }\n\n    // Redirect to home if authenticated and on auth page\n    if (isAuthenticated &amp;&amp; isOnAuthPage) {\n      return '/home';\n    }\n\n    return null; // No redirect needed\n  },\n\n  // Error Handling\n  errorBuilder: (context, state) =&gt; ErrorScreen(\n    error: state.error.toString(),\n  ),\n);\n</code></pre>"},{"location":"architecture/navigation/#navigation-usage","title":"Navigation Usage","text":"<pre><code>// Navigate to a route\ncontext.go('/profile/user123');\n\n// Navigate with named route\ncontext.goNamed('profile', pathParameters: {'userId': 'user123'});\n\n// Navigate with query parameters\ncontext.goNamed(\n  'search',\n  queryParameters: {'query': 'flutter', 'category': 'posts'},\n);\n\n// Push a new route (keeps current route in stack)\ncontext.push('/create-post');\n\n// Pop current route\ncontext.pop();\n\n// Pop with result\ncontext.pop('result_data');\n\n// Replace current route\ncontext.pushReplacement('/home');\n</code></pre>"},{"location":"architecture/navigation/#type-safe-navigation","title":"Type-Safe Navigation","text":"<pre><code>// Define route data classes\nclass ProfileRoute {\n  final String userId;\n  final String? tab;\n\n  ProfileRoute({required this.userId, this.tab});\n\n  String get path =&gt; '/profile/$userId${tab != null ? '?tab=$tab' : ''}';\n}\n\n// Extension for type-safe navigation\nextension AppNavigation on BuildContext {\n  void goToProfile(String userId, {String? tab}) {\n    final route = ProfileRoute(userId: userId, tab: tab);\n    go(route.path);\n  }\n\n  void goToPost(String postId) {\n    goNamed('post', pathParameters: {'postId': postId});\n  }\n\n  void goToCreatePost() {\n    push('/create-post');\n  }\n}\n\n// Usage\ncontext.goToProfile('user123', tab: 'posts');\n</code></pre>"},{"location":"architecture/navigation/#shell-routes-for-bottom-navigation","title":"Shell Routes for Bottom Navigation","text":"<pre><code>class MainShell extends StatelessWidget {\n  final Widget child;\n\n  const MainShell({required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: _calculateSelectedIndex(context),\n        onTap: (index) =&gt; _onItemTapped(index, context),\n        type: BottomNavigationBarType.fixed,\n        items: const [\n          BottomNavigationBarItem(\n            icon: Icon(Icons.home),\n            label: 'Home',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.search),\n            label: 'Search',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.add_box),\n            label: 'Create',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.favorite),\n            label: 'Activity',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.person),\n            label: 'Profile',\n          ),\n        ],\n      ),\n    );\n  }\n\n  int _calculateSelectedIndex(BuildContext context) {\n    final location = GoRouterState.of(context).location;\n    if (location.startsWith('/home')) return 0;\n    if (location.startsWith('/search')) return 1;\n    if (location.startsWith('/activity')) return 3;\n    if (location.startsWith('/profile')) return 4;\n    return 0;\n  }\n\n  void _onItemTapped(int index, BuildContext context) {\n    switch (index) {\n      case 0:\n        context.go('/home');\n        break;\n      case 1:\n        context.go('/search');\n        break;\n      case 2:\n        context.push('/create-post');\n        break;\n      case 3:\n        context.go('/activity');\n        break;\n      case 4:\n        final userId = /* get current user ID */;\n        context.go('/profile/$userId');\n        break;\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#2-auto-route","title":"2. Auto Route","text":""},{"location":"architecture/navigation/#when-to-use-auto-route","title":"When to Use Auto Route","text":"<ul> <li>Code generation: Automatic route generation</li> <li>Type safety: Compile-time route validation</li> <li>Complex routing: Advanced routing patterns</li> <li>Large applications: Better organization for big apps</li> </ul>"},{"location":"architecture/navigation/#setup_1","title":"Setup","text":"<pre><code>dependencies:\n  auto_route: ^7.8.0\n\ndev_dependencies:\n  auto_route_generator: ^7.3.0\n  build_runner: ^2.4.0\n</code></pre>"},{"location":"architecture/navigation/#route-configuration","title":"Route Configuration","text":"<pre><code>// app_router.dart\n@AutoRouterConfig()\nclass AppRouter extends _$AppRouter {\n  @override\n  List&lt;AutoRoute&gt; get routes =&gt; [\n    // Splash\n    AutoRoute(\n      page: SplashRoute.page,\n      path: '/splash',\n      initial: true,\n    ),\n\n    // Auth Routes\n    AutoRoute(\n      page: AuthWrapperRoute.page,\n      path: '/auth',\n      children: [\n        AutoRoute(page: LoginRoute.page, path: '/login'),\n        AutoRoute(page: RegisterRoute.page, path: '/register'),\n      ],\n    ),\n\n    // Main App\n    AutoRoute(\n      page: MainWrapperRoute.page,\n      path: '/main',\n      children: [\n        AutoRoute(page: HomeRoute.page, path: '/home'),\n        AutoRoute(page: SearchRoute.page, path: '/search'),\n        AutoRoute(page: ProfileRoute.page, path: '/profile/:userId'),\n      ],\n    ),\n\n    // Modal Routes\n    AutoRoute(\n      page: CreatePostRoute.page,\n      path: '/create-post',\n      fullscreenDialog: true,\n    ),\n  ];\n}\n\n// Generate routes\n// Run: flutter packages pub run build_runner build\n</code></pre>"},{"location":"architecture/navigation/#page-classes","title":"Page Classes","text":"<pre><code>// Define page classes\n@RoutePage()\nclass SplashScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Center(child: CircularProgressIndicator()),\n    );\n  }\n}\n\n@RoutePage()\nclass ProfileScreen extends StatelessWidget {\n  final String userId;\n\n  const ProfileScreen({required this.userId});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Profile: $userId')),\n      body: /* profile content */,\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#navigation-usage_1","title":"Navigation Usage","text":"<pre><code>// Navigate using generated routes\ncontext.router.push(ProfileRoute(userId: 'user123'));\n\n// Navigate with replacement\ncontext.router.pushAndClearStack(HomeRoute());\n\n// Pop with result\ncontext.router.pop('result');\n\n// Navigate to nested route\ncontext.router.pushPath('/main/profile/user123');\n</code></pre>"},{"location":"architecture/navigation/#3-navigator-10-basic","title":"3. Navigator 1.0 (Basic)","text":""},{"location":"architecture/navigation/#when-to-use-navigator-10","title":"When to Use Navigator 1.0","text":"<ul> <li>Simple apps: Basic navigation needs</li> <li>Learning: Understanding Flutter navigation fundamentals</li> <li>Legacy projects: Existing apps using Navigator 1.0</li> </ul>"},{"location":"architecture/navigation/#basic-navigation","title":"Basic Navigation","text":"<pre><code>// Push a new screen\nNavigator.of(context).push(\n  MaterialPageRoute(\n    builder: (context) =&gt; const ProfileScreen(),\n  ),\n);\n\n// Push with custom transition\nNavigator.of(context).push(\n  PageRouteBuilder(\n    pageBuilder: (context, animation, secondaryAnimation) =&gt; const ProfileScreen(),\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return SlideTransition(\n        position: animation.drive(\n          Tween(begin: const Offset(1.0, 0.0), end: Offset.zero),\n        ),\n        child: child,\n      );\n    },\n  ),\n);\n\n// Pop current screen\nNavigator.of(context).pop();\n\n// Pop with result\nNavigator.of(context).pop('result_data');\n\n// Push and remove all previous routes\nNavigator.of(context).pushAndRemoveUntil(\n  MaterialPageRoute(builder: (context) =&gt; const HomeScreen()),\n  (route) =&gt; false,\n);\n</code></pre>"},{"location":"architecture/navigation/#named-routes","title":"Named Routes","text":"<pre><code>// Define routes in MaterialApp\nMaterialApp(\n  routes: {\n    '/': (context) =&gt; const HomeScreen(),\n    '/profile': (context) =&gt; const ProfileScreen(),\n    '/settings': (context) =&gt; const SettingsScreen(),\n  },\n  onGenerateRoute: (settings) {\n    if (settings.name == '/profile') {\n      final args = settings.arguments as Map&lt;String, dynamic&gt;?;\n      return MaterialPageRoute(\n        builder: (context) =&gt; ProfileScreen(\n          userId: args?['userId'] ?? '',\n        ),\n      );\n    }\n    return null;\n  },\n);\n\n// Navigate using named routes\nNavigator.of(context).pushNamed('/profile', arguments: {'userId': 'user123'});\n</code></pre>"},{"location":"architecture/navigation/#navigation-patterns","title":"Navigation Patterns","text":""},{"location":"architecture/navigation/#1-authentication-flow","title":"1. Authentication Flow","text":"<pre><code>class AuthGuard {\n  static String? redirect(BuildContext context, GoRouterState state) {\n    final isAuthenticated = context.read&lt;AuthProvider&gt;().isAuthenticated;\n    final isOnAuthPage = state.location.startsWith('/auth');\n\n    if (!isAuthenticated &amp;&amp; !isOnAuthPage) {\n      return '/auth/login';\n    }\n\n    if (isAuthenticated &amp;&amp; isOnAuthPage) {\n      return '/home';\n    }\n\n    return null;\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#2-deep-linking","title":"2. Deep Linking","text":"<pre><code>// Handle deep links\nclass DeepLinkHandler {\n  static void handleDeepLink(String link) {\n    final uri = Uri.parse(link);\n\n    switch (uri.pathSegments.first) {\n      case 'profile':\n        if (uri.pathSegments.length &gt; 1) {\n          final userId = uri.pathSegments[1];\n          router.go('/profile/$userId');\n        }\n        break;\n      case 'post':\n        if (uri.pathSegments.length &gt; 1) {\n          final postId = uri.pathSegments[1];\n          router.go('/post/$postId');\n        }\n        break;\n      default:\n        router.go('/home');\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#3-modal-navigation","title":"3. Modal Navigation","text":"<pre><code>// Show modal bottom sheet\nvoid showCreatePostModal(BuildContext context) {\n  showModalBottomSheet(\n    context: context,\n    isScrollControlled: true,\n    backgroundColor: Colors.transparent,\n    builder: (context) =&gt; DraggableScrollableSheet(\n      initialChildSize: 0.9,\n      builder: (context, scrollController) =&gt; Container(\n        decoration: const BoxDecoration(\n          color: Colors.white,\n          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),\n        ),\n        child: const CreatePostScreen(),\n      ),\n    ),\n  );\n}\n\n// Show full-screen modal\nvoid showFullScreenModal(BuildContext context) {\n  Navigator.of(context).push(\n    MaterialPageRoute(\n      fullscreenDialog: true,\n      builder: (context) =&gt; const CreatePostScreen(),\n    ),\n  );\n}\n</code></pre>"},{"location":"architecture/navigation/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/navigation/#1-lazy-loading","title":"1. Lazy Loading","text":"<pre><code>// Lazy load screens\nGoRoute(\n  path: '/heavy-screen',\n  builder: (context, state) =&gt; FutureBuilder(\n    future: _loadHeavyScreen(),\n    builder: (context, snapshot) {\n      if (snapshot.hasData) {\n        return snapshot.data!;\n      }\n      return const LoadingScreen();\n    },\n  ),\n);\n\nFuture&lt;Widget&gt; _loadHeavyScreen() async {\n  // Load heavy dependencies\n  await Future.delayed(const Duration(milliseconds: 500));\n  return const HeavyScreen();\n}\n</code></pre>"},{"location":"architecture/navigation/#2-route-caching","title":"2. Route Caching","text":"<pre><code>// Cache frequently used routes\nclass RouteCache {\n  static final Map&lt;String, Widget&gt; _cache = {};\n\n  static Widget getOrCreate(String key, Widget Function() builder) {\n    if (!_cache.containsKey(key)) {\n      _cache[key] = builder();\n    }\n    return _cache[key]!;\n  }\n\n  static void clear() {\n    _cache.clear();\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#testing-navigation","title":"Testing Navigation","text":""},{"location":"architecture/navigation/#testing-go-router","title":"Testing Go Router","text":"<pre><code>void main() {\n  group('Navigation Tests', () {\n    testWidgets('should navigate to profile screen', (tester) async {\n      final router = GoRouter(\n        routes: [\n          GoRoute(\n            path: '/profile/:userId',\n            builder: (context, state) =&gt; ProfileScreen(\n              userId: state.pathParameters['userId']!,\n            ),\n          ),\n        ],\n      );\n\n      await tester.pumpWidget(\n        MaterialApp.router(\n          routerConfig: router,\n        ),\n      );\n\n      router.go('/profile/user123');\n      await tester.pumpAndSettle();\n\n      expect(find.byType(ProfileScreen), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/navigation/#best-practices","title":"Best Practices","text":""},{"location":"architecture/navigation/#1-route-organization","title":"1. Route Organization","text":"<pre><code>// Organize routes by feature\nclass AuthRoutes {\n  static const login = '/auth/login';\n  static const register = '/auth/register';\n  static const forgotPassword = '/auth/forgot-password';\n}\n\nclass MainRoutes {\n  static const home = '/home';\n  static const search = '/search';\n  static String profile(String userId) =&gt; '/profile/$userId';\n  static String post(String postId) =&gt; '/post/$postId';\n}\n</code></pre>"},{"location":"architecture/navigation/#2-navigation-extensions","title":"2. Navigation Extensions","text":"<pre><code>extension NavigationExtensions on BuildContext {\n  void goToHome() =&gt; go(MainRoutes.home);\n  void goToProfile(String userId) =&gt; go(MainRoutes.profile(userId));\n  void goToPost(String postId) =&gt; go(MainRoutes.post(postId));\n\n  Future&lt;T?&gt; showCreatePostModal&lt;T&gt;() {\n    return showModalBottomSheet&lt;T&gt;(\n      context: this,\n      builder: (context) =&gt; const CreatePostModal(),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#3-error-handling","title":"3. Error Handling","text":"<pre><code>// Global error handling for navigation\nclass NavigationErrorHandler {\n  static Widget handleError(BuildContext context, GoRouterState state) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Page Not Found')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Icon(Icons.error, size: 64),\n            const SizedBox(height: 16),\n            Text('Page \"${state.location}\" not found'),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              onPressed: () =&gt; context.go('/home'),\n              child: const Text('Go Home'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/navigation/#next-steps","title":"Next Steps","text":"<ol> <li>Choose your navigation solution based on app complexity</li> <li>Set up deep linking for better user experience</li> <li>Implement authentication guards for protected routes</li> <li>Add proper error handling for navigation failures</li> <li>Proceed to Widget Design</li> </ol> <p>Pro Tip: Start with Go Router for most projects. It provides excellent developer experience and is maintained by the Flutter team.</p>"},{"location":"architecture/state-management/","title":"Flutter State Management","text":"<p>Comprehensive guide to state management in Flutter applications, covering different patterns and when to use each approach.</p>"},{"location":"architecture/state-management/#state-management-overview","title":"State Management Overview","text":"<p>State management is crucial for building scalable Flutter applications. The choice depends on your app's complexity, team size, and specific requirements.</p>     graph TB     A[State Management] --&gt; B[Local State]     A --&gt; C[Global State]      B --&gt; B1[StatefulWidget]     B --&gt; B2[ValueNotifier]     B --&gt; B3[ChangeNotifier]      C --&gt; C1[Provider]     C --&gt; C2[Riverpod]     C --&gt; C3[BLoC]     C --&gt; C4[GetX]     C --&gt; C5[MobX]"},{"location":"architecture/state-management/#decision-matrix","title":"Decision Matrix","text":"App Complexity Team Size Learning Curve Recommended Solution Simple 1-2 devs Easy Provider Medium 2-5 devs Medium Riverpod Complex 5+ devs Steep BLoC Rapid Prototype Any Easy GetX"},{"location":"architecture/state-management/#1-riverpod-recommended","title":"1. Riverpod (Recommended)","text":""},{"location":"architecture/state-management/#why-riverpod","title":"Why Riverpod?","text":"<ul> <li>Compile-time safety: Catches errors at compile time</li> <li>No BuildContext dependency: Can be used anywhere</li> <li>Better testing: Easy to mock and test</li> <li>Performance: Automatic disposal and caching</li> <li>Developer experience: Excellent debugging tools</li> </ul>"},{"location":"architecture/state-management/#basic-setup","title":"Basic Setup","text":"<pre><code>dependencies:\n  flutter_riverpod: ^2.4.0\n  riverpod_annotation: ^2.3.0\n\ndev_dependencies:\n  riverpod_generator: ^2.3.0\n  build_runner: ^2.4.0\n</code></pre>"},{"location":"architecture/state-management/#provider-types","title":"Provider Types","text":"<pre><code>// Simple Provider\nfinal counterProvider = StateProvider&lt;int&gt;((ref) =&gt; 0);\n\n// Future Provider\nfinal userProvider = FutureProvider&lt;User&gt;((ref) async {\n  final api = ref.read(apiServiceProvider);\n  return await api.getCurrentUser();\n});\n\n// Stream Provider\nfinal postsStreamProvider = StreamProvider&lt;List&lt;Post&gt;&gt;((ref) {\n  final api = ref.read(apiServiceProvider);\n  return api.getPostsStream();\n});\n\n// StateNotifier Provider\nfinal feedProvider = StateNotifierProvider&lt;FeedNotifier, FeedState&gt;((ref) {\n  final repository = ref.read(postRepositoryProvider);\n  return FeedNotifier(repository);\n});\n</code></pre>"},{"location":"architecture/state-management/#statenotifier-implementation","title":"StateNotifier Implementation","text":"<pre><code>@freezed\nclass FeedState with _$FeedState {\n  const factory FeedState({\n    @Default([]) List&lt;Post&gt; posts,\n    @Default(false) bool isLoading,\n    String? error,\n  }) = _FeedState;\n}\n\nclass FeedNotifier extends StateNotifier&lt;FeedState&gt; {\n  final PostRepository _repository;\n\n  FeedNotifier(this._repository) : super(const FeedState());\n\n  Future&lt;void&gt; loadPosts() async {\n    state = state.copyWith(isLoading: true, error: null);\n\n    try {\n      final posts = await _repository.getPosts();\n      state = state.copyWith(\n        posts: posts,\n        isLoading: false,\n      );\n    } catch (error) {\n      state = state.copyWith(\n        isLoading: false,\n        error: error.toString(),\n      );\n    }\n  }\n\n  void addPost(Post post) {\n    state = state.copyWith(\n      posts: [post, ...state.posts],\n    );\n  }\n\n  void removePost(String postId) {\n    state = state.copyWith(\n      posts: state.posts.where((post) =&gt; post.id != postId).toList(),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#using-riverpod-in-widgets","title":"Using Riverpod in Widgets","text":"<pre><code>class FeedScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final feedState = ref.watch(feedProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Feed')),\n      body: Column(\n        children: [\n          if (feedState.isLoading)\n            const LinearProgressIndicator(),\n          if (feedState.error != null)\n            ErrorBanner(message: feedState.error!),\n          Expanded(\n            child: ListView.builder(\n              itemCount: feedState.posts.length,\n              itemBuilder: (context, index) {\n                final post = feedState.posts[index];\n                return PostCard(post: post);\n              },\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () =&gt; ref.read(feedProvider.notifier).loadPosts(),\n        child: const Icon(Icons.refresh),\n      ),\n    );\n  }\n}\n\n// Consumer for specific parts\nclass PostCard extends ConsumerWidget {\n  final Post post;\n\n  const PostCard({required this.post});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Card(\n      child: Column(\n        children: [\n          ListTile(\n            title: Text(post.caption),\n            trailing: Consumer(\n              builder: (context, ref, child) {\n                final isLiked = ref.watch(\n                  likedPostsProvider.select((posts) =&gt; posts.contains(post.id))\n                );\n\n                return IconButton(\n                  icon: Icon(\n                    isLiked ? Icons.favorite : Icons.favorite_border,\n                    color: isLiked ? Colors.red : null,\n                  ),\n                  onPressed: () {\n                    ref.read(likedPostsProvider.notifier).toggle(post.id);\n                  },\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#2-bloc-pattern","title":"2. BLoC Pattern","text":""},{"location":"architecture/state-management/#when-to-use-bloc","title":"When to Use BLoC","text":"<ul> <li>Large teams: Clear separation of concerns</li> <li>Complex business logic: Event-driven architecture</li> <li>Testability: Easy to test business logic</li> <li>Predictable state: Unidirectional data flow</li> </ul>"},{"location":"architecture/state-management/#setup","title":"Setup","text":"<pre><code>dependencies:\n  flutter_bloc: ^8.1.0\n  equatable: ^2.0.0\n</code></pre>"},{"location":"architecture/state-management/#bloc-implementation","title":"BLoC Implementation","text":"<pre><code>// Events\nabstract class FeedEvent extends Equatable {\n  @override\n  List&lt;Object?&gt; get props =&gt; [];\n}\n\nclass LoadFeed extends FeedEvent {}\n\nclass AddPost extends FeedEvent {\n  final Post post;\n\n  AddPost(this.post);\n\n  @override\n  List&lt;Object?&gt; get props =&gt; [post];\n}\n\nclass DeletePost extends FeedEvent {\n  final String postId;\n\n  DeletePost(this.postId);\n\n  @override\n  List&lt;Object?&gt; get props =&gt; [postId];\n}\n\n// States\nabstract class FeedState extends Equatable {\n  @override\n  List&lt;Object?&gt; get props =&gt; [];\n}\n\nclass FeedInitial extends FeedState {}\n\nclass FeedLoading extends FeedState {}\n\nclass FeedLoaded extends FeedState {\n  final List&lt;Post&gt; posts;\n\n  FeedLoaded(this.posts);\n\n  @override\n  List&lt;Object?&gt; get props =&gt; [posts];\n}\n\nclass FeedError extends FeedState {\n  final String message;\n\n  FeedError(this.message);\n\n  @override\n  List&lt;Object?&gt; get props =&gt; [message];\n}\n\n// BLoC\nclass FeedBloc extends Bloc&lt;FeedEvent, FeedState&gt; {\n  final PostRepository _repository;\n\n  FeedBloc(this._repository) : super(FeedInitial()) {\n    on&lt;LoadFeed&gt;(_onLoadFeed);\n    on&lt;AddPost&gt;(_onAddPost);\n    on&lt;DeletePost&gt;(_onDeletePost);\n  }\n\n  Future&lt;void&gt; _onLoadFeed(LoadFeed event, Emitter&lt;FeedState&gt; emit) async {\n    emit(FeedLoading());\n\n    try {\n      final posts = await _repository.getPosts();\n      emit(FeedLoaded(posts));\n    } catch (error) {\n      emit(FeedError(error.toString()));\n    }\n  }\n\n  Future&lt;void&gt; _onAddPost(AddPost event, Emitter&lt;FeedState&gt; emit) async {\n    if (state is FeedLoaded) {\n      final currentState = state as FeedLoaded;\n      emit(FeedLoaded([event.post, ...currentState.posts]));\n    }\n  }\n\n  Future&lt;void&gt; _onDeletePost(DeletePost event, Emitter&lt;FeedState&gt; emit) async {\n    if (state is FeedLoaded) {\n      final currentState = state as FeedLoaded;\n      final updatedPosts = currentState.posts\n          .where((post) =&gt; post.id != event.postId)\n          .toList();\n      emit(FeedLoaded(updatedPosts));\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#using-bloc-in-widgets","title":"Using BLoC in Widgets","text":"<pre><code>class FeedScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) =&gt; FeedBloc(\n        context.read&lt;PostRepository&gt;(),\n      )..add(LoadFeed()),\n      child: const FeedView(),\n    );\n  }\n}\n\nclass FeedView extends StatelessWidget {\n  const FeedView();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Feed')),\n      body: BlocBuilder&lt;FeedBloc, FeedState&gt;(\n        builder: (context, state) {\n          if (state is FeedLoading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n\n          if (state is FeedError) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Text('Error: ${state.message}'),\n                  ElevatedButton(\n                    onPressed: () {\n                      context.read&lt;FeedBloc&gt;().add(LoadFeed());\n                    },\n                    child: const Text('Retry'),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          if (state is FeedLoaded) {\n            return ListView.builder(\n              itemCount: state.posts.length,\n              itemBuilder: (context, index) {\n                return PostCard(post: state.posts[index]);\n              },\n            );\n          }\n\n          return const SizedBox.shrink();\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          context.read&lt;FeedBloc&gt;().add(LoadFeed());\n        },\n        child: const Icon(Icons.refresh),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#3-provider-pattern","title":"3. Provider Pattern","text":""},{"location":"architecture/state-management/#when-to-use-provider","title":"When to Use Provider","text":"<ul> <li>Simple to medium apps: Easy to learn and implement</li> <li>Quick development: Minimal boilerplate</li> <li>Team familiarity: Many developers know Provider</li> </ul>"},{"location":"architecture/state-management/#setup_1","title":"Setup","text":"<pre><code>dependencies:\n  provider: ^6.1.0\n</code></pre>"},{"location":"architecture/state-management/#changenotifier-implementation","title":"ChangeNotifier Implementation","text":"<pre><code>class FeedProvider extends ChangeNotifier {\n  final PostRepository _repository;\n\n  FeedProvider(this._repository);\n\n  List&lt;Post&gt; _posts = [];\n  bool _isLoading = false;\n  String? _error;\n\n  List&lt;Post&gt; get posts =&gt; _posts;\n  bool get isLoading =&gt; _isLoading;\n  String? get error =&gt; _error;\n\n  Future&lt;void&gt; loadPosts() async {\n    _isLoading = true;\n    _error = null;\n    notifyListeners();\n\n    try {\n      _posts = await _repository.getPosts();\n      _isLoading = false;\n      notifyListeners();\n    } catch (error) {\n      _isLoading = false;\n      _error = error.toString();\n      notifyListeners();\n    }\n  }\n\n  void addPost(Post post) {\n    _posts.insert(0, post);\n    notifyListeners();\n  }\n\n  void removePost(String postId) {\n    _posts.removeWhere((post) =&gt; post.id == postId);\n    notifyListeners();\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#using-provider-in-widgets","title":"Using Provider in Widgets","text":"<pre><code>class FeedScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) =&gt; FeedProvider(\n        context.read&lt;PostRepository&gt;(),\n      )..loadPosts(),\n      child: const FeedView(),\n    );\n  }\n}\n\nclass FeedView extends StatelessWidget {\n  const FeedView();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Feed')),\n      body: Consumer&lt;FeedProvider&gt;(\n        builder: (context, feedProvider, child) {\n          if (feedProvider.isLoading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n\n          if (feedProvider.error != null) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Text('Error: ${feedProvider.error}'),\n                  ElevatedButton(\n                    onPressed: () =&gt; feedProvider.loadPosts(),\n                    child: const Text('Retry'),\n                  ),\n                ],\n              ),\n            );\n          }\n\n          return ListView.builder(\n            itemCount: feedProvider.posts.length,\n            itemBuilder: (context, index) {\n              return PostCard(post: feedProvider.posts[index]);\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/state-management/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/state-management/#1-selective-rebuilds","title":"1. Selective Rebuilds","text":"<pre><code>// Riverpod - Use select for specific properties\nConsumer(\n  builder: (context, ref, child) {\n    final postCount = ref.watch(\n      feedProvider.select((state) =&gt; state.posts.length)\n    );\n    return Text('Posts: $postCount');\n  },\n)\n\n// Provider - Use Selector\nSelector&lt;FeedProvider, int&gt;(\n  selector: (context, provider) =&gt; provider.posts.length,\n  builder: (context, postCount, child) {\n    return Text('Posts: $postCount');\n  },\n)\n</code></pre>"},{"location":"architecture/state-management/#2-avoid-unnecessary-rebuilds","title":"2. Avoid Unnecessary Rebuilds","text":"<pre><code>// Use const constructors\nclass PostCard extends StatelessWidget {\n  const PostCard({super.key, required this.post});\n\n  final Post post;\n\n  @override\n  Widget build(BuildContext context) {\n    return const Card(/* ... */);\n  }\n}\n\n// Use RepaintBoundary for expensive widgets\nRepaintBoundary(\n  child: ExpensiveWidget(),\n)\n</code></pre>"},{"location":"architecture/state-management/#testing-state-management","title":"Testing State Management","text":""},{"location":"architecture/state-management/#testing-riverpod","title":"Testing Riverpod","text":"<pre><code>void main() {\n  group('FeedNotifier', () {\n    late MockPostRepository mockRepository;\n    late ProviderContainer container;\n\n    setUp(() {\n      mockRepository = MockPostRepository();\n      container = ProviderContainer(\n        overrides: [\n          postRepositoryProvider.overrideWithValue(mockRepository),\n        ],\n      );\n    });\n\n    tearDown(() {\n      container.dispose();\n    });\n\n    test('should load posts successfully', () async {\n      // Arrange\n      final posts = [Post(/* test data */)];\n      when(mockRepository.getPosts()).thenAnswer((_) async =&gt; posts);\n\n      // Act\n      await container.read(feedProvider.notifier).loadPosts();\n\n      // Assert\n      final state = container.read(feedProvider);\n      expect(state.posts, equals(posts));\n      expect(state.isLoading, false);\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/state-management/#testing-bloc","title":"Testing BLoC","text":"<pre><code>void main() {\n  group('FeedBloc', () {\n    late MockPostRepository mockRepository;\n    late FeedBloc feedBloc;\n\n    setUp(() {\n      mockRepository = MockPostRepository();\n      feedBloc = FeedBloc(mockRepository);\n    });\n\n    tearDown(() {\n      feedBloc.close();\n    });\n\n    blocTest&lt;FeedBloc, FeedState&gt;(\n      'emits [FeedLoading, FeedLoaded] when LoadFeed is successful',\n      build: () {\n        when(mockRepository.getPosts()).thenAnswer((_) async =&gt; []);\n        return feedBloc;\n      },\n      act: (bloc) =&gt; bloc.add(LoadFeed()),\n      expect: () =&gt; [FeedLoading(), FeedLoaded([])],\n    );\n  });\n}\n</code></pre>"},{"location":"architecture/state-management/#best-practices","title":"Best Practices","text":""},{"location":"architecture/state-management/#1-state-structure","title":"1. State Structure","text":"<pre><code>// Good: Immutable state\n@freezed\nclass AppState with _$AppState {\n  const factory AppState({\n    required User? user,\n    required List&lt;Post&gt; posts,\n    required bool isLoading,\n  }) = _AppState;\n}\n\n// Avoid: Mutable state\nclass AppState {\n  User? user;\n  List&lt;Post&gt; posts = [];\n  bool isLoading = false;\n}\n</code></pre>"},{"location":"architecture/state-management/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Implement proper error types\nabstract class AppError {\n  final String message;\n  const AppError(this.message);\n}\n\nclass NetworkError extends AppError {\n  const NetworkError(String message) : super(message);\n}\n\nclass AuthError extends AppError {\n  const AuthError(String message) : super(message);\n}\n</code></pre>"},{"location":"architecture/state-management/#3-dependency-injection","title":"3. Dependency Injection","text":"<pre><code>// Use providers for dependency injection\nfinal apiServiceProvider = Provider&lt;ApiService&gt;((ref) {\n  return ApiService(baseUrl: 'https://api.example.com');\n});\n\nfinal postRepositoryProvider = Provider&lt;PostRepository&gt;((ref) {\n  final apiService = ref.read(apiServiceProvider);\n  return PostRepositoryImpl(apiService);\n});\n</code></pre>"},{"location":"architecture/state-management/#next-steps","title":"Next Steps","text":"<ol> <li>Choose your state management solution based on project needs</li> <li>Set up proper testing for your state management</li> <li>Implement error handling patterns</li> <li>Optimize for performance with selective rebuilds</li> <li>Proceed to Navigation</li> </ol> <p>Pro Tip: Start with Provider or Riverpod for most projects. Only use BLoC if you have complex business logic or large teams that benefit from strict patterns.</p>"},{"location":"architecture/widget-design/","title":"Flutter Widget Design","text":"<p>Comprehensive guide to designing reusable, performant, and maintainable widgets in Flutter applications.</p>"},{"location":"architecture/widget-design/#widget-design-principles","title":"Widget Design Principles","text":""},{"location":"architecture/widget-design/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each widget should have one clear purpose and responsibility.</p> <pre><code>// Good: Focused widget\nclass UserAvatar extends StatelessWidget {\n  final String imageUrl;\n  final double size;\n  final VoidCallback? onTap;\n\n  const UserAvatar({\n    super.key,\n    required this.imageUrl,\n    this.size = 40,\n    this.onTap,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: onTap,\n      child: CircleAvatar(\n        radius: size / 2,\n        backgroundImage: NetworkImage(imageUrl),\n      ),\n    );\n  }\n}\n\n// Avoid: Widget doing too many things\nclass UserProfileSection extends StatelessWidget {\n  // Too many responsibilities: avatar, name, bio, follow button, posts count\n}\n</code></pre>"},{"location":"architecture/widget-design/#2-composition-over-inheritance","title":"2. Composition Over Inheritance","text":"<p>Build complex widgets by composing simpler widgets.</p> <pre><code>// Good: Composition\nclass PostCard extends StatelessWidget {\n  final Post post;\n\n  const PostCard({super.key, required this.post});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          PostHeader(user: post.user, timestamp: post.createdAt),\n          PostImage(imageUrl: post.imageUrl),\n          PostActions(post: post),\n          PostCaption(caption: post.caption),\n          PostComments(comments: post.comments),\n        ],\n      ),\n    );\n  }\n}\n\n// Individual components\nclass PostHeader extends StatelessWidget {\n  final User user;\n  final DateTime timestamp;\n\n  const PostHeader({super.key, required this.user, required this.timestamp});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      leading: UserAvatar(imageUrl: user.avatarUrl),\n      title: Text(user.username),\n      subtitle: Text(timeago.format(timestamp)),\n      trailing: const Icon(Icons.more_vert),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#3-immutability","title":"3. Immutability","text":"<p>Design widgets to be immutable for better performance and predictability.</p> <pre><code>// Good: Immutable widget\nclass CustomButton extends StatelessWidget {\n  final String text;\n  final VoidCallback? onPressed;\n  final Color? backgroundColor;\n  final Color? textColor;\n\n  const CustomButton({\n    super.key,\n    required this.text,\n    this.onPressed,\n    this.backgroundColor,\n    this.textColor,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      style: ElevatedButton.styleFrom(\n        backgroundColor: backgroundColor,\n        foregroundColor: textColor,\n      ),\n      child: Text(text),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#widget-categories","title":"Widget Categories","text":""},{"location":"architecture/widget-design/#1-presentation-widgets","title":"1. Presentation Widgets","text":"<p>Pure UI widgets that display data without business logic.</p> <pre><code>class PostImage extends StatelessWidget {\n  final String imageUrl;\n  final double? aspectRatio;\n  final BoxFit fit;\n\n  const PostImage({\n    super.key,\n    required this.imageUrl,\n    this.aspectRatio,\n    this.fit = BoxFit.cover,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return AspectRatio(\n      aspectRatio: aspectRatio ?? 1.0,\n      child: CachedNetworkImage(\n        imageUrl: imageUrl,\n        fit: fit,\n        placeholder: (context, url) =&gt; Container(\n          color: Colors.grey[300],\n          child: const Center(\n            child: CircularProgressIndicator(),\n          ),\n        ),\n        errorWidget: (context, url, error) =&gt; Container(\n          color: Colors.grey[300],\n          child: const Icon(Icons.error),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#2-interactive-widgets","title":"2. Interactive Widgets","text":"<p>Widgets that handle user interactions and state changes.</p> <pre><code>class LikeButton extends StatefulWidget {\n  final bool isLiked;\n  final int likeCount;\n  final ValueChanged&lt;bool&gt; onLikeChanged;\n\n  const LikeButton({\n    super.key,\n    required this.isLiked,\n    required this.likeCount,\n    required this.onLikeChanged,\n  });\n\n  @override\n  State&lt;LikeButton&gt; createState() =&gt; _LikeButtonState();\n}\n\nclass _LikeButtonState extends State&lt;LikeButton&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _animationController;\n  late Animation&lt;double&gt; _scaleAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n    _animationController = AnimationController(\n      duration: const Duration(milliseconds: 200),\n      vsync: this,\n    );\n    _scaleAnimation = Tween&lt;double&gt;(\n      begin: 1.0,\n      end: 1.2,\n    ).animate(CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.elasticOut,\n    ));\n  }\n\n  @override\n  void dispose() {\n    _animationController.dispose();\n    super.dispose();\n  }\n\n  void _handleTap() {\n    widget.onLikeChanged(!widget.isLiked);\n    _animationController.forward().then((_) {\n      _animationController.reverse();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        AnimatedBuilder(\n          animation: _scaleAnimation,\n          builder: (context, child) {\n            return Transform.scale(\n              scale: _scaleAnimation.value,\n              child: IconButton(\n                onPressed: _handleTap,\n                icon: Icon(\n                  widget.isLiked ? Icons.favorite : Icons.favorite_border,\n                  color: widget.isLiked ? Colors.red : null,\n                ),\n              ),\n            );\n          },\n        ),\n        Text('${widget.likeCount}'),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#3-layout-widgets","title":"3. Layout Widgets","text":"<p>Widgets that organize and structure other widgets.</p> <pre><code>class ResponsiveLayout extends StatelessWidget {\n  final Widget mobile;\n  final Widget? tablet;\n  final Widget? desktop;\n\n  const ResponsiveLayout({\n    super.key,\n    required this.mobile,\n    this.tablet,\n    this.desktop,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        if (constraints.maxWidth &gt;= 1200) {\n          return desktop ?? tablet ?? mobile;\n        } else if (constraints.maxWidth &gt;= 800) {\n          return tablet ?? mobile;\n        } else {\n          return mobile;\n        }\n      },\n    );\n  }\n}\n\nclass GridLayout extends StatelessWidget {\n  final List&lt;Widget&gt; children;\n  final int crossAxisCount;\n  final double spacing;\n\n  const GridLayout({\n    super.key,\n    required this.children,\n    this.crossAxisCount = 2,\n    this.spacing = 8.0,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView.builder(\n      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: crossAxisCount,\n        crossAxisSpacing: spacing,\n        mainAxisSpacing: spacing,\n      ),\n      itemCount: children.length,\n      itemBuilder: (context, index) =&gt; children[index],\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/widget-design/#1-use-const-constructors","title":"1. Use const Constructors","text":"<pre><code>// Good: const constructor\nclass AppLogo extends StatelessWidget {\n  const AppLogo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const FlutterLogo(size: 100);\n  }\n}\n\n// Usage\nconst AppLogo() // Widget won't rebuild unnecessarily\n</code></pre>"},{"location":"architecture/widget-design/#2-implement-repaintboundary","title":"2. Implement RepaintBoundary","text":"<pre><code>class ExpensiveWidget extends StatelessWidget {\n  const ExpensiveWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: CustomPaint(\n        painter: ComplexPainter(),\n        child: const SizedBox(width: 200, height: 200),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#3-use-builder-widgets-for-localized-rebuilds","title":"3. Use Builder Widgets for Localized Rebuilds","text":"<pre><code>class OptimizedCounter extends StatefulWidget {\n  @override\n  State&lt;OptimizedCounter&gt; createState() =&gt; _OptimizedCounterState();\n}\n\nclass _OptimizedCounterState extends State&lt;OptimizedCounter&gt; {\n  int _counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        const Text('This text never rebuilds'),\n        Builder(\n          builder: (context) {\n            // Only this part rebuilds when counter changes\n            return Text('Counter: $_counter');\n          },\n        ),\n        ElevatedButton(\n          onPressed: () =&gt; setState(() =&gt; _counter++),\n          child: const Text('Increment'),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#4-lazy-loading-with-listviewbuilder","title":"4. Lazy Loading with ListView.builder","text":"<pre><code>class PostsList extends StatelessWidget {\n  final List&lt;Post&gt; posts;\n\n  const PostsList({super.key, required this.posts});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: posts.length,\n      itemBuilder: (context, index) {\n        // Only builds visible items\n        return PostCard(post: posts[index]);\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#accessibility","title":"Accessibility","text":""},{"location":"architecture/widget-design/#1-semantic-labels","title":"1. Semantic Labels","text":"<pre><code>class AccessibleButton extends StatelessWidget {\n  final String text;\n  final VoidCallback? onPressed;\n  final String? semanticLabel;\n\n  const AccessibleButton({\n    super.key,\n    required this.text,\n    this.onPressed,\n    this.semanticLabel,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Semantics(\n      label: semanticLabel ?? text,\n      button: true,\n      enabled: onPressed != null,\n      child: ElevatedButton(\n        onPressed: onPressed,\n        child: Text(text),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#2-focus-management","title":"2. Focus Management","text":"<pre><code>class SearchField extends StatefulWidget {\n  final ValueChanged&lt;String&gt;? onChanged;\n\n  const SearchField({super.key, this.onChanged});\n\n  @override\n  State&lt;SearchField&gt; createState() =&gt; _SearchFieldState();\n}\n\nclass _SearchFieldState extends State&lt;SearchField&gt; {\n  late FocusNode _focusNode;\n  late TextEditingController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _focusNode = FocusNode();\n    _controller = TextEditingController();\n  }\n\n  @override\n  void dispose() {\n    _focusNode.dispose();\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return TextField(\n      controller: _controller,\n      focusNode: _focusNode,\n      decoration: InputDecoration(\n        hintText: 'Search...',\n        prefixIcon: const Icon(Icons.search),\n        suffixIcon: IconButton(\n          icon: const Icon(Icons.clear),\n          onPressed: () {\n            _controller.clear();\n            widget.onChanged?.call('');\n          },\n        ),\n      ),\n      onChanged: widget.onChanged,\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#testing-widgets","title":"Testing Widgets","text":""},{"location":"architecture/widget-design/#1-widget-tests","title":"1. Widget Tests","text":"<pre><code>void main() {\n  group('UserAvatar', () {\n    testWidgets('should display user avatar', (tester) async {\n      const imageUrl = 'https://example.com/avatar.jpg';\n\n      await tester.pumpWidget(\n        const MaterialApp(\n          home: UserAvatar(imageUrl: imageUrl),\n        ),\n      );\n\n      expect(find.byType(CircleAvatar), findsOneWidget);\n      expect(find.byType(NetworkImage), findsOneWidget);\n    });\n\n    testWidgets('should handle tap events', (tester) async {\n      bool tapped = false;\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: UserAvatar(\n            imageUrl: 'https://example.com/avatar.jpg',\n            onTap: () =&gt; tapped = true,\n          ),\n        ),\n      );\n\n      await tester.tap(find.byType(UserAvatar));\n      expect(tapped, isTrue);\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/widget-design/#2-golden-tests","title":"2. Golden Tests","text":"<pre><code>void main() {\n  group('PostCard Golden Tests', () {\n    testWidgets('should match golden file', (tester) async {\n      final post = Post(\n        id: '1',\n        user: User(username: 'testuser'),\n        imageUrl: 'https://example.com/image.jpg',\n        caption: 'Test caption',\n        createdAt: DateTime(2023, 1, 1),\n      );\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: Scaffold(\n            body: PostCard(post: post),\n          ),\n        ),\n      );\n\n      await expectLater(\n        find.byType(PostCard),\n        matchesGoldenFile('post_card.png'),\n      );\n    });\n  });\n}\n</code></pre>"},{"location":"architecture/widget-design/#widget-patterns","title":"Widget Patterns","text":""},{"location":"architecture/widget-design/#1-builder-pattern","title":"1. Builder Pattern","text":"<pre><code>class CustomDialog {\n  String? title;\n  String? content;\n  List&lt;Widget&gt; actions = [];\n\n  CustomDialog setTitle(String title) {\n    this.title = title;\n    return this;\n  }\n\n  CustomDialog setContent(String content) {\n    this.content = content;\n    return this;\n  }\n\n  CustomDialog addAction(Widget action) {\n    actions.add(action);\n    return this;\n  }\n\n  Widget build() {\n    return AlertDialog(\n      title: title != null ? Text(title!) : null,\n      content: content != null ? Text(content!) : null,\n      actions: actions,\n    );\n  }\n}\n\n// Usage\nfinal dialog = CustomDialog()\n    .setTitle('Confirm')\n    .setContent('Are you sure?')\n    .addAction(TextButton(\n      onPressed: () {},\n      child: const Text('Cancel'),\n    ))\n    .addAction(TextButton(\n      onPressed: () {},\n      child: const Text('OK'),\n    ))\n    .build();\n</code></pre>"},{"location":"architecture/widget-design/#2-factory-pattern","title":"2. Factory Pattern","text":"<pre><code>abstract class ButtonFactory {\n  static Widget primary({\n    required String text,\n    required VoidCallback? onPressed,\n  }) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      style: ElevatedButton.styleFrom(\n        backgroundColor: Colors.blue,\n        foregroundColor: Colors.white,\n      ),\n      child: Text(text),\n    );\n  }\n\n  static Widget secondary({\n    required String text,\n    required VoidCallback? onPressed,\n  }) {\n    return OutlinedButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n\n  static Widget danger({\n    required String text,\n    required VoidCallback? onPressed,\n  }) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      style: ElevatedButton.styleFrom(\n        backgroundColor: Colors.red,\n        foregroundColor: Colors.white,\n      ),\n      child: Text(text),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#3-mixin-pattern","title":"3. Mixin Pattern","text":"<pre><code>mixin LoadingStateMixin&lt;T extends StatefulWidget&gt; on State&lt;T&gt; {\n  bool _isLoading = false;\n\n  bool get isLoading =&gt; _isLoading;\n\n  void setLoading(bool loading) {\n    if (mounted) {\n      setState(() {\n        _isLoading = loading;\n      });\n    }\n  }\n\n  Widget buildWithLoading(Widget child) {\n    return Stack(\n      children: [\n        child,\n        if (_isLoading)\n          Container(\n            color: Colors.black26,\n            child: const Center(\n              child: CircularProgressIndicator(),\n            ),\n          ),\n      ],\n    );\n  }\n}\n\n// Usage\nclass MyScreen extends StatefulWidget {\n  @override\n  State&lt;MyScreen&gt; createState() =&gt; _MyScreenState();\n}\n\nclass _MyScreenState extends State&lt;MyScreen&gt; with LoadingStateMixin {\n  @override\n  Widget build(BuildContext context) {\n    return buildWithLoading(\n      Scaffold(\n        body: const Center(child: Text('Content')),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () async {\n            setLoading(true);\n            await Future.delayed(const Duration(seconds: 2));\n            setLoading(false);\n          },\n          child: const Icon(Icons.refresh),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#best-practices","title":"Best Practices","text":""},{"location":"architecture/widget-design/#1-widget-naming","title":"1. Widget Naming","text":"<pre><code>// Good: Descriptive names\nclass UserProfileHeader extends StatelessWidget {}\nclass PostActionButtons extends StatelessWidget {}\nclass CommentInputField extends StatelessWidget {}\n\n// Avoid: Generic names\nclass Container extends StatelessWidget {} // Conflicts with Flutter's Container\nclass Widget extends StatelessWidget {} // Too generic\n</code></pre>"},{"location":"architecture/widget-design/#2-parameter-validation","title":"2. Parameter Validation","text":"<pre><code>class ProgressBar extends StatelessWidget {\n  final double progress;\n  final Color? color;\n\n  const ProgressBar({\n    super.key,\n    required this.progress,\n    this.color,\n  }) : assert(progress &gt;= 0.0 &amp;&amp; progress &lt;= 1.0, 'Progress must be between 0.0 and 1.0');\n\n  @override\n  Widget build(BuildContext context) {\n    return LinearProgressIndicator(\n      value: progress,\n      backgroundColor: Colors.grey[300],\n      valueColor: AlwaysStoppedAnimation&lt;Color&gt;(\n        color ?? Theme.of(context).primaryColor,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#3-documentation","title":"3. Documentation","text":"<pre><code>/// A customizable avatar widget that displays a user's profile image.\n/// \n/// The [UserAvatar] widget displays a circular image with optional tap handling.\n/// It supports network images with automatic fallback to a default avatar.\n/// \n/// Example usage:\n/// ```dart\n/// UserAvatar(\n///   imageUrl: 'https://example.com/avatar.jpg',\n///   size: 50,\n///   onTap: () =&gt; print('Avatar tapped'),\n/// )\n/// ```\nclass UserAvatar extends StatelessWidget {\n  /// The URL of the user's avatar image.\n  final String imageUrl;\n\n  /// The diameter of the avatar. Defaults to 40.\n  final double size;\n\n  /// Callback function called when the avatar is tapped.\n  final VoidCallback? onTap;\n\n  const UserAvatar({\n    super.key,\n    required this.imageUrl,\n    this.size = 40,\n    this.onTap,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    // Implementation...\n  }\n}\n</code></pre>"},{"location":"architecture/widget-design/#next-steps","title":"Next Steps","text":"<ol> <li>Design your widget hierarchy following composition principles</li> <li>Implement performance optimizations for complex widgets</li> <li>Add accessibility features to all interactive widgets</li> <li>Write comprehensive tests for your custom widgets</li> <li>Proceed to Supabase Integration</li> </ol> <p>Pro Tip: Start with simple, focused widgets and compose them into more complex UI elements. This approach leads to better maintainability and reusability.</p>"},{"location":"data/api-integration/","title":"API Integration","text":"<p>Comprehensive guide to integrating REST APIs and GraphQL in Flutter applications with proper error handling and caching.</p>"},{"location":"data/api-integration/#overview","title":"Overview","text":"<p>API integration is crucial for modern Flutter applications. This guide covers REST APIs, GraphQL, authentication, caching, and best practices for robust data fetching.</p>"},{"location":"data/api-integration/#http-client-setup","title":"HTTP Client Setup","text":""},{"location":"data/api-integration/#1-dio-configuration-recommended","title":"1. Dio Configuration (Recommended)","text":"<pre><code># pubspec.yaml\ndependencies:\n  dio: ^5.3.2\n  pretty_dio_logger: ^1.3.1\n  dio_cache_interceptor: ^3.4.2\n</code></pre> <pre><code>// lib/services/api_client.dart\nimport 'package:dio/dio.dart';\nimport 'package:pretty_dio_logger/pretty_dio_logger.dart';\n\nclass ApiClient {\n  static final Dio _dio = Dio();\n\n  static void initialize() {\n    _dio.options = BaseOptions(\n      baseUrl: 'https://api.example.com',\n      connectTimeout: const Duration(seconds: 30),\n      receiveTimeout: const Duration(seconds: 30),\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n    );\n\n    // Add interceptors\n    _dio.interceptors.addAll([\n      AuthInterceptor(),\n      ErrorInterceptor(),\n      if (kDebugMode) PrettyDioLogger(\n        requestHeader: true,\n        requestBody: true,\n        responseBody: true,\n        responseHeader: false,\n        error: true,\n        compact: true,\n      ),\n    ]);\n  }\n\n  static Dio get instance =&gt; _dio;\n}\n</code></pre>"},{"location":"data/api-integration/#2-authentication-interceptor","title":"2. Authentication Interceptor","text":"<pre><code>// lib/interceptors/auth_interceptor.dart\nclass AuthInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {\n    final token = await TokenService.getAccessToken();\n    if (token != null) {\n      options.headers['Authorization'] = 'Bearer $token';\n    }\n    handler.next(options);\n  }\n\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) async {\n    if (err.response?.statusCode == 401) {\n      // Token expired, try to refresh\n      final refreshed = await TokenService.refreshToken();\n      if (refreshed) {\n        // Retry the request\n        final options = err.requestOptions;\n        final token = await TokenService.getAccessToken();\n        options.headers['Authorization'] = 'Bearer $token';\n\n        try {\n          final response = await ApiClient.instance.fetch(options);\n          handler.resolve(response);\n          return;\n        } catch (e) {\n          // Refresh failed, redirect to login\n          AuthService.logout();\n        }\n      }\n    }\n    handler.next(err);\n  }\n}\n</code></pre>"},{"location":"data/api-integration/#3-error-handling-interceptor","title":"3. Error Handling Interceptor","text":"<pre><code>// lib/interceptors/error_interceptor.dart\nclass ErrorInterceptor extends Interceptor {\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    final apiError = _handleError(err);\n    handler.next(DioException(\n      requestOptions: err.requestOptions,\n      error: apiError,\n      type: err.type,\n      response: err.response,\n    ));\n  }\n\n  ApiError _handleError(DioException error) {\n    switch (error.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        return ApiError(\n          code: 'TIMEOUT',\n          message: 'Connection timeout. Please check your internet connection.',\n        );\n\n      case DioExceptionType.badResponse:\n        return _handleHttpError(error.response!);\n\n      case DioExceptionType.cancel:\n        return ApiError(\n          code: 'CANCELLED',\n          message: 'Request was cancelled.',\n        );\n\n      default:\n        return ApiError(\n          code: 'UNKNOWN',\n          message: 'An unexpected error occurred.',\n        );\n    }\n  }\n\n  ApiError _handleHttpError(Response response) {\n    switch (response.statusCode) {\n      case 400:\n        return ApiError(\n          code: 'BAD_REQUEST',\n          message: 'Invalid request parameters.',\n          details: response.data,\n        );\n      case 401:\n        return ApiError(\n          code: 'UNAUTHORIZED',\n          message: 'Authentication required.',\n        );\n      case 403:\n        return ApiError(\n          code: 'FORBIDDEN',\n          message: 'Access denied.',\n        );\n      case 404:\n        return ApiError(\n          code: 'NOT_FOUND',\n          message: 'Resource not found.',\n        );\n      case 500:\n        return ApiError(\n          code: 'SERVER_ERROR',\n          message: 'Internal server error.',\n        );\n      default:\n        return ApiError(\n          code: 'HTTP_ERROR',\n          message: 'HTTP ${response.statusCode}: ${response.statusMessage}',\n        );\n    }\n  }\n}\n\nclass ApiError {\n  final String code;\n  final String message;\n  final dynamic details;\n\n  ApiError({\n    required this.code,\n    required this.message,\n    this.details,\n  });\n}\n</code></pre>"},{"location":"data/api-integration/#repository-pattern","title":"Repository Pattern","text":""},{"location":"data/api-integration/#1-abstract-repository","title":"1. Abstract Repository","text":"<pre><code>// lib/repositories/base_repository.dart\nabstract class BaseRepository&lt;T&gt; {\n  Future&lt;List&lt;T&gt;&gt; getAll();\n  Future&lt;T?&gt; getById(String id);\n  Future&lt;T&gt; create(T item);\n  Future&lt;T&gt; update(String id, T item);\n  Future&lt;void&gt; delete(String id);\n}\n</code></pre>"},{"location":"data/api-integration/#2-concrete-implementation","title":"2. Concrete Implementation","text":"<pre><code>// lib/repositories/user_repository.dart\nclass UserRepository implements BaseRepository&lt;User&gt; {\n  final Dio _dio = ApiClient.instance;\n\n  @override\n  Future&lt;List&lt;User&gt;&gt; getAll() async {\n    try {\n      final response = await _dio.get('/users');\n      final List&lt;dynamic&gt; data = response.data['data'];\n      return data.map((json) =&gt; User.fromJson(json)).toList();\n    } catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  @override\n  Future&lt;User?&gt; getById(String id) async {\n    try {\n      final response = await _dio.get('/users/$id');\n      return User.fromJson(response.data['data']);\n    } on DioException catch (e) {\n      if (e.response?.statusCode == 404) {\n        return null;\n      }\n      throw _handleError(e);\n    }\n  }\n\n  @override\n  Future&lt;User&gt; create(User user) async {\n    try {\n      final response = await _dio.post('/users', data: user.toJson());\n      return User.fromJson(response.data['data']);\n    } catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  @override\n  Future&lt;User&gt; update(String id, User user) async {\n    try {\n      final response = await _dio.put('/users/$id', data: user.toJson());\n      return User.fromJson(response.data['data']);\n    } catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  @override\n  Future&lt;void&gt; delete(String id) async {\n    try {\n      await _dio.delete('/users/$id');\n    } catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  // Custom methods\n  Future&lt;List&lt;User&gt;&gt; searchUsers(String query) async {\n    try {\n      final response = await _dio.get('/users/search', queryParameters: {\n        'q': query,\n        'limit': 20,\n      });\n      final List&lt;dynamic&gt; data = response.data['data'];\n      return data.map((json) =&gt; User.fromJson(json)).toList();\n    } catch (e) {\n      throw _handleError(e);\n    }\n  }\n\n  RepositoryException _handleError(dynamic error) {\n    if (error is DioException &amp;&amp; error.error is ApiError) {\n      final apiError = error.error as ApiError;\n      return RepositoryException(\n        message: apiError.message,\n        code: apiError.code,\n        details: apiError.details,\n      );\n    }\n    return RepositoryException(\n      message: 'An unexpected error occurred',\n      code: 'UNKNOWN',\n    );\n  }\n}\n\nclass RepositoryException implements Exception {\n  final String message;\n  final String code;\n  final dynamic details;\n\n  RepositoryException({\n    required this.message,\n    required this.code,\n    this.details,\n  });\n}\n</code></pre>"},{"location":"data/api-integration/#data-models","title":"Data Models","text":""},{"location":"data/api-integration/#1-model-with-json-serialization","title":"1. Model with JSON Serialization","text":"<pre><code>// lib/models/user.dart\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'user.g.dart';\n\n@JsonSerializable()\nclass User {\n  final String id;\n  final String email;\n  final String name;\n  @JsonKey(name: 'avatar_url')\n  final String? avatarUrl;\n  @JsonKey(name: 'created_at')\n  final DateTime createdAt;\n  @JsonKey(name: 'updated_at')\n  final DateTime updatedAt;\n\n  User({\n    required this.id,\n    required this.email,\n    required this.name,\n    this.avatarUrl,\n    required this.createdAt,\n    required this.updatedAt,\n  });\n\n  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);\n  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);\n\n  User copyWith({\n    String? id,\n    String? email,\n    String? name,\n    String? avatarUrl,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) {\n    return User(\n      id: id ?? this.id,\n      email: email ?? this.email,\n      name: name ?? this.name,\n      avatarUrl: avatarUrl ?? this.avatarUrl,\n      createdAt: createdAt ?? this.createdAt,\n      updatedAt: updatedAt ?? this.updatedAt,\n    );\n  }\n}\n</code></pre>"},{"location":"data/api-integration/#2-api-response-wrapper","title":"2. API Response Wrapper","text":"<pre><code>// lib/models/api_response.dart\n@JsonSerializable(genericArgumentFactories: true)\nclass ApiResponse&lt;T&gt; {\n  final bool success;\n  final String? message;\n  final T? data;\n  final Map&lt;String, dynamic&gt;? errors;\n  final PaginationMeta? meta;\n\n  ApiResponse({\n    required this.success,\n    this.message,\n    this.data,\n    this.errors,\n    this.meta,\n  });\n\n  factory ApiResponse.fromJson(\n    Map&lt;String, dynamic&gt; json,\n    T Function(Object? json) fromJsonT,\n  ) =&gt; _$ApiResponseFromJson(json, fromJsonT);\n\n  Map&lt;String, dynamic&gt; toJson(Object Function(T value) toJsonT) =&gt;\n      _$ApiResponseToJson(this, toJsonT);\n}\n\n@JsonSerializable()\nclass PaginationMeta {\n  final int currentPage;\n  final int lastPage;\n  final int perPage;\n  final int total;\n\n  PaginationMeta({\n    required this.currentPage,\n    required this.lastPage,\n    required this.perPage,\n    required this.total,\n  });\n\n  factory PaginationMeta.fromJson(Map&lt;String, dynamic&gt; json) =&gt;\n      _$PaginationMetaFromJson(json);\n  Map&lt;String, dynamic&gt; toJson() =&gt; _$PaginationMetaToJson(this);\n}\n</code></pre>"},{"location":"data/api-integration/#caching-strategy","title":"Caching Strategy","text":""},{"location":"data/api-integration/#1-http-cache-with-dio","title":"1. HTTP Cache with Dio","text":"<pre><code>// lib/services/cache_service.dart\nimport 'package:dio_cache_interceptor/dio_cache_interceptor.dart';\n\nclass CacheService {\n  static CacheOptions get defaultCacheOptions =&gt; CacheOptions(\n    store: MemCacheStore(),\n    policy: CachePolicy.request,\n    hitCacheOnErrorExcept: [401, 403],\n    maxStale: const Duration(days: 7),\n    priority: CachePriority.normal,\n    cipher: null,\n    keyBuilder: CacheOptions.defaultCacheKeyBuilder,\n    allowPostMethod: false,\n  );\n\n  static CacheOptions get longTermCache =&gt; CacheOptions(\n    store: HiveCacheStore(null),\n    policy: CachePolicy.cacheFirst,\n    maxStale: const Duration(days: 30),\n    priority: CachePriority.high,\n  );\n\n  static CacheOptions get shortTermCache =&gt; CacheOptions(\n    store: MemCacheStore(),\n    policy: CachePolicy.refreshForceCache,\n    maxStale: const Duration(minutes: 5),\n    priority: CachePriority.low,\n  );\n}\n\n// Usage in repository\nclass CachedUserRepository extends UserRepository {\n  @override\n  Future&lt;List&lt;User&gt;&gt; getAll() async {\n    final response = await _dio.get(\n      '/users',\n      options: CacheService.shortTermCache.toOptions(),\n    );\n    final List&lt;dynamic&gt; data = response.data['data'];\n    return data.map((json) =&gt; User.fromJson(json)).toList();\n  }\n}\n</code></pre>"},{"location":"data/api-integration/#2-custom-cache-implementation","title":"2. Custom Cache Implementation","text":"<pre><code>// lib/services/custom_cache.dart\nclass CustomCache&lt;T&gt; {\n  final Map&lt;String, CacheEntry&lt;T&gt;&gt; _cache = {};\n  final Duration defaultTtl;\n\n  CustomCache({this.defaultTtl = const Duration(minutes: 5)});\n\n  void put(String key, T value, {Duration? ttl}) {\n    final expiry = DateTime.now().add(ttl ?? defaultTtl);\n    _cache[key] = CacheEntry(value, expiry);\n  }\n\n  T? get(String key) {\n    final entry = _cache[key];\n    if (entry == null) return null;\n\n    if (DateTime.now().isAfter(entry.expiry)) {\n      _cache.remove(key);\n      return null;\n    }\n\n    return entry.value;\n  }\n\n  void remove(String key) {\n    _cache.remove(key);\n  }\n\n  void clear() {\n    _cache.clear();\n  }\n\n  bool containsKey(String key) {\n    final entry = _cache[key];\n    if (entry == null) return false;\n\n    if (DateTime.now().isAfter(entry.expiry)) {\n      _cache.remove(key);\n      return false;\n    }\n\n    return true;\n  }\n}\n\nclass CacheEntry&lt;T&gt; {\n  final T value;\n  final DateTime expiry;\n\n  CacheEntry(this.value, this.expiry);\n}\n</code></pre>"},{"location":"data/api-integration/#graphql-integration","title":"GraphQL Integration","text":""},{"location":"data/api-integration/#1-graphql-setup","title":"1. GraphQL Setup","text":"<pre><code># pubspec.yaml\ndependencies:\n  graphql_flutter: ^5.1.2\n</code></pre> <pre><code>// lib/services/graphql_client.dart\nimport 'package:graphql_flutter/graphql_flutter.dart';\n\nclass GraphQLService {\n  static GraphQLClient? _client;\n\n  static void initialize() {\n    final HttpLink httpLink = HttpLink('https://api.example.com/graphql');\n\n    final AuthLink authLink = AuthLink(\n      getToken: () async {\n        final token = await TokenService.getAccessToken();\n        return token != null ? 'Bearer $token' : null;\n      },\n    );\n\n    final Link link = authLink.concat(httpLink);\n\n    _client = GraphQLClient(\n      cache: GraphQLCache(store: InMemoryStore()),\n      link: link,\n    );\n  }\n\n  static GraphQLClient get client {\n    if (_client == null) {\n      throw Exception('GraphQL client not initialized');\n    }\n    return _client!;\n  }\n}\n</code></pre>"},{"location":"data/api-integration/#2-graphql-queries","title":"2. GraphQL Queries","text":"<pre><code>// lib/graphql/queries.dart\nclass GraphQLQueries {\n  static const String getUsers = '''\n    query GetUsers(\\$limit: Int, \\$offset: Int) {\n      users(limit: \\$limit, offset: \\$offset) {\n        id\n        email\n        name\n        avatarUrl\n        createdAt\n        updatedAt\n      }\n    }\n  ''';\n\n  static const String getUserById = '''\n    query GetUser(\\$id: ID!) {\n      user(id: \\$id) {\n        id\n        email\n        name\n        avatarUrl\n        posts {\n          id\n          title\n          content\n          createdAt\n        }\n      }\n    }\n  ''';\n\n  static const String createUser = '''\n    mutation CreateUser(\\$input: CreateUserInput!) {\n      createUser(input: \\$input) {\n        id\n        email\n        name\n        avatarUrl\n      }\n    }\n  ''';\n}\n\n// lib/repositories/graphql_user_repository.dart\nclass GraphQLUserRepository {\n  final GraphQLClient _client = GraphQLService.client;\n\n  Future&lt;List&lt;User&gt;&gt; getUsers({int limit = 20, int offset = 0}) async {\n    final QueryOptions options = QueryOptions(\n      document: gql(GraphQLQueries.getUsers),\n      variables: {'limit': limit, 'offset': offset},\n      fetchPolicy: FetchPolicy.cacheAndNetwork,\n    );\n\n    final QueryResult result = await _client.query(options);\n\n    if (result.hasException) {\n      throw GraphQLException(result.exception!);\n    }\n\n    final List&lt;dynamic&gt; usersData = result.data!['users'];\n    return usersData.map((json) =&gt; User.fromJson(json)).toList();\n  }\n\n  Future&lt;User&gt; createUser(CreateUserInput input) async {\n    final MutationOptions options = MutationOptions(\n      document: gql(GraphQLQueries.createUser),\n      variables: {'input': input.toJson()},\n    );\n\n    final QueryResult result = await _client.mutate(options);\n\n    if (result.hasException) {\n      throw GraphQLException(result.exception!);\n    }\n\n    return User.fromJson(result.data!['createUser']);\n  }\n}\n\nclass GraphQLException implements Exception {\n  final OperationException exception;\n\n  GraphQLException(this.exception);\n\n  String get message {\n    if (exception.graphqlErrors.isNotEmpty) {\n      return exception.graphqlErrors.first.message;\n    }\n    if (exception.linkException != null) {\n      return exception.linkException.toString();\n    }\n    return 'Unknown GraphQL error';\n  }\n}\n</code></pre>"},{"location":"data/api-integration/#file-upload","title":"File Upload","text":""},{"location":"data/api-integration/#1-multipart-file-upload","title":"1. Multipart File Upload","text":"<pre><code>// lib/services/upload_service.dart\nclass UploadService {\n  final Dio _dio = ApiClient.instance;\n\n  Future&lt;String&gt; uploadFile(File file, {\n    String? fileName,\n    Function(int, int)? onProgress,\n  }) async {\n    final formData = FormData.fromMap({\n      'file': await MultipartFile.fromFile(\n        file.path,\n        filename: fileName ?? file.path.split('/').last,\n      ),\n    });\n\n    try {\n      final response = await _dio.post(\n        '/upload',\n        data: formData,\n        onSendProgress: onProgress,\n      );\n\n      return response.data['url'];\n    } catch (e) {\n      throw UploadException('Failed to upload file: ${e.toString()}');\n    }\n  }\n\n  Future&lt;List&lt;String&gt;&gt; uploadMultipleFiles(\n    List&lt;File&gt; files, {\n    Function(int, int)? onProgress,\n  }) async {\n    final formData = FormData();\n\n    for (int i = 0; i &lt; files.length; i++) {\n      formData.files.add(MapEntry(\n        'files',\n        await MultipartFile.fromFile(\n          files[i].path,\n          filename: files[i].path.split('/').last,\n        ),\n      ));\n    }\n\n    try {\n      final response = await _dio.post(\n        '/upload/multiple',\n        data: formData,\n        onSendProgress: onProgress,\n      );\n\n      return List&lt;String&gt;.from(response.data['urls']);\n    } catch (e) {\n      throw UploadException('Failed to upload files: ${e.toString()}');\n    }\n  }\n}\n\nclass UploadException implements Exception {\n  final String message;\n  UploadException(this.message);\n}\n</code></pre>"},{"location":"data/api-integration/#testing-api-integration","title":"Testing API Integration","text":""},{"location":"data/api-integration/#1-mock-http-client","title":"1. Mock HTTP Client","text":"<pre><code>// test/mocks/mock_dio.dart\nimport 'package:dio/dio.dart';\nimport 'package:mockito/mockito.dart';\n\nclass MockDio extends Mock implements Dio {}\n\n// test/repositories/user_repository_test.dart\nvoid main() {\n  group('UserRepository Tests', () {\n    late MockDio mockDio;\n    late UserRepository repository;\n\n    setUp(() {\n      mockDio = MockDio();\n      repository = UserRepository();\n      // Inject mock dio\n    });\n\n    test('should return users when API call is successful', () async {\n      // Arrange\n      final mockResponse = Response(\n        data: {\n          'data': [\n            {'id': '1', 'email': 'test@example.com', 'name': 'Test User'}\n          ]\n        },\n        statusCode: 200,\n        requestOptions: RequestOptions(path: '/users'),\n      );\n\n      when(mockDio.get('/users')).thenAnswer((_) async =&gt; mockResponse);\n\n      // Act\n      final users = await repository.getAll();\n\n      // Assert\n      expect(users, isA&lt;List&lt;User&gt;&gt;());\n      expect(users.length, 1);\n      expect(users.first.email, 'test@example.com');\n    });\n  });\n}\n</code></pre>"},{"location":"data/api-integration/#2-integration-tests","title":"2. Integration Tests","text":"<pre><code>// integration_test/api_integration_test.dart\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('API Integration Tests', () {\n    setUpAll(() {\n      ApiClient.initialize();\n    });\n\n    testWidgets('should fetch users from real API', (tester) async {\n      final repository = UserRepository();\n      final users = await repository.getAll();\n\n      expect(users, isNotEmpty);\n      expect(users.first, isA&lt;User&gt;());\n    });\n  });\n}\n</code></pre> <p>API integration is fundamental to modern app development. Follow these patterns for robust, maintainable, and testable API integration in your Flutter applications.</p>"},{"location":"data/offline-support/","title":"Offline Support","text":"<p>Comprehensive guide to implementing robust offline functionality in Flutter applications.</p>"},{"location":"data/offline-support/#overview","title":"Overview","text":"<p>Offline support ensures your Flutter app remains functional when network connectivity is limited or unavailable. This guide covers caching strategies, data synchronization, and offline-first architecture.</p>"},{"location":"data/offline-support/#offline-architecture","title":"Offline Architecture","text":""},{"location":"data/offline-support/#1-offline-first-design","title":"1. Offline-First Design","text":"<pre><code>// lib/architecture/offline_repository.dart\nabstract class OfflineRepository&lt;T&gt; {\n  Future&lt;List&lt;T&gt;&gt; getAll();\n  Future&lt;T?&gt; getById(String id);\n  Future&lt;void&gt; save(T item);\n  Future&lt;void&gt; delete(String id);\n  Future&lt;void&gt; syncWithServer();\n}\n\nclass PostRepository implements OfflineRepository&lt;Post&gt; {\n  final LocalDatabase _localDb;\n  final ApiClient _apiClient;\n  final ConnectivityService _connectivity;\n\n  PostRepository(this._localDb, this._apiClient, this._connectivity);\n\n  @override\n  Future&lt;List&lt;Post&gt;&gt; getAll() async {\n    // Always return local data first\n    final localPosts = await _localDb.getAllPosts();\n\n    // Try to sync with server if online\n    if (await _connectivity.isConnected()) {\n      try {\n        await syncWithServer();\n        return await _localDb.getAllPosts();\n      } catch (e) {\n        // Return local data if sync fails\n        return localPosts;\n      }\n    }\n\n    return localPosts;\n  }\n\n  @override\n  Future&lt;Post?&gt; getById(String id) async {\n    final localPost = await _localDb.getPostById(id);\n\n    if (await _connectivity.isConnected()) {\n      try {\n        final serverPost = await _apiClient.getPost(id);\n        await _localDb.savePost(serverPost);\n        return serverPost;\n      } catch (e) {\n        return localPost;\n      }\n    }\n\n    return localPost;\n  }\n\n  @override\n  Future&lt;void&gt; save(Post post) async {\n    // Save locally first\n    await _localDb.savePost(post);\n\n    // Queue for server sync\n    await _queueForSync(post);\n\n    // Try immediate sync if online\n    if (await _connectivity.isConnected()) {\n      try {\n        await _syncPostToServer(post);\n      } catch (e) {\n        // Will be synced later\n      }\n    }\n  }\n\n  @override\n  Future&lt;void&gt; syncWithServer() async {\n    if (!await _connectivity.isConnected()) return;\n\n    try {\n      // Sync pending changes to server\n      await _syncPendingChanges();\n\n      // Fetch latest from server\n      final serverPosts = await _apiClient.getAllPosts();\n      await _localDb.savePosts(serverPosts);\n    } catch (e) {\n      throw SyncException('Failed to sync with server: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#2-local-database-setup","title":"2. Local Database Setup","text":"<pre><code>// lib/database/local_database.dart\nimport 'package:sqflite/sqflite.dart';\n\nclass LocalDatabase {\n  static Database? _database;\n\n  Future&lt;Database&gt; get database async {\n    _database ??= await _initDatabase();\n    return _database!;\n  }\n\n  Future&lt;Database&gt; _initDatabase() async {\n    final path = await getDatabasesPath();\n    return await openDatabase(\n      '$path/app_database.db',\n      version: 1,\n      onCreate: _onCreate,\n    );\n  }\n\n  Future&lt;void&gt; _onCreate(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE posts (\n        id TEXT PRIMARY KEY,\n        content TEXT NOT NULL,\n        user_id TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER,\n        is_synced INTEGER DEFAULT 0,\n        is_deleted INTEGER DEFAULT 0\n      )\n    ''');\n\n    await db.execute('''\n      CREATE TABLE sync_queue (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        table_name TEXT NOT NULL,\n        record_id TEXT NOT NULL,\n        operation TEXT NOT NULL,\n        data TEXT,\n        created_at INTEGER NOT NULL\n      )\n    ''');\n  }\n\n  // Posts operations\n  Future&lt;List&lt;Post&gt;&gt; getAllPosts() async {\n    final db = await database;\n    final maps = await db.query(\n      'posts',\n      where: 'is_deleted = ?',\n      whereArgs: [0],\n      orderBy: 'created_at DESC',\n    );\n\n    return maps.map((map) =&gt; Post.fromMap(map)).toList();\n  }\n\n  Future&lt;Post?&gt; getPostById(String id) async {\n    final db = await database;\n    final maps = await db.query(\n      'posts',\n      where: 'id = ? AND is_deleted = ?',\n      whereArgs: [id, 0],\n      limit: 1,\n    );\n\n    return maps.isNotEmpty ? Post.fromMap(maps.first) : null;\n  }\n\n  Future&lt;void&gt; savePost(Post post) async {\n    final db = await database;\n    await db.insert(\n      'posts',\n      post.toMap(),\n      conflictAlgorithm: ConflictAlgorithm.replace,\n    );\n  }\n\n  Future&lt;void&gt; deletePost(String id) async {\n    final db = await database;\n    await db.update(\n      'posts',\n      {'is_deleted': 1},\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n  }\n\n  // Sync queue operations\n  Future&lt;void&gt; addToSyncQueue(String tableName, String recordId, String operation, [Map&lt;String, dynamic&gt;? data]) async {\n    final db = await database;\n    await db.insert('sync_queue', {\n      'table_name': tableName,\n      'record_id': recordId,\n      'operation': operation,\n      'data': data != null ? jsonEncode(data) : null,\n      'created_at': DateTime.now().millisecondsSinceEpoch,\n    });\n  }\n\n  Future&lt;List&lt;SyncQueueItem&gt;&gt; getPendingSyncItems() async {\n    final db = await database;\n    final maps = await db.query('sync_queue', orderBy: 'created_at ASC');\n    return maps.map((map) =&gt; SyncQueueItem.fromMap(map)).toList();\n  }\n\n  Future&lt;void&gt; removeSyncQueueItem(int id) async {\n    final db = await database;\n    await db.delete('sync_queue', where: 'id = ?', whereArgs: [id]);\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#3-connectivity-service","title":"3. Connectivity Service","text":"<pre><code>// lib/services/connectivity_service.dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nclass ConnectivityService {\n  final Connectivity _connectivity = Connectivity();\n  final StreamController&lt;bool&gt; _connectionController = StreamController&lt;bool&gt;.broadcast();\n\n  Stream&lt;bool&gt; get connectionStream =&gt; _connectionController.stream;\n  bool _isConnected = false;\n\n  bool get isConnected =&gt; _isConnected;\n\n  void initialize() {\n    _connectivity.onConnectivityChanged.listen((ConnectivityResult result) {\n      final wasConnected = _isConnected;\n      _isConnected = result != ConnectivityResult.none;\n\n      if (!wasConnected &amp;&amp; _isConnected) {\n        // Connection restored\n        _connectionController.add(true);\n        _onConnectionRestored();\n      } else if (wasConnected &amp;&amp; !_isConnected) {\n        // Connection lost\n        _connectionController.add(false);\n        _onConnectionLost();\n      }\n    });\n\n    // Check initial connectivity\n    _checkInitialConnectivity();\n  }\n\n  Future&lt;void&gt; _checkInitialConnectivity() async {\n    final result = await _connectivity.checkConnectivity();\n    _isConnected = result != ConnectivityResult.none;\n    _connectionController.add(_isConnected);\n  }\n\n  void _onConnectionRestored() {\n    // Trigger sync when connection is restored\n    GetIt.instance&lt;SyncService&gt;().syncAll();\n  }\n\n  void _onConnectionLost() {\n    // Handle offline mode\n    print('Connection lost - entering offline mode');\n  }\n\n  void dispose() {\n    _connectionController.close();\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#caching-strategies","title":"Caching Strategies","text":""},{"location":"data/offline-support/#1-multi-level-caching","title":"1. Multi-Level Caching","text":"<pre><code>// lib/services/cache_service.dart\nclass CacheService {\n  final Map&lt;String, dynamic&gt; _memoryCache = {};\n  final LocalDatabase _localStorage;\n  final Duration _memoryTtl;\n  final Duration _diskTtl;\n\n  CacheService(this._localStorage, {\n    this._memoryTtl = const Duration(minutes: 5),\n    this._diskTtl = const Duration(hours: 24),\n  });\n\n  Future&lt;T?&gt; get&lt;T&gt;(String key, T Function(Map&lt;String, dynamic&gt;) fromJson) async {\n    // Check memory cache first\n    final memoryItem = _memoryCache[key];\n    if (memoryItem != null &amp;&amp; !_isExpired(memoryItem['timestamp'], _memoryTtl)) {\n      return fromJson(memoryItem['data']);\n    }\n\n    // Check disk cache\n    final diskItem = await _localStorage.getCacheItem(key);\n    if (diskItem != null &amp;&amp; !_isExpired(diskItem.timestamp, _diskTtl)) {\n      // Update memory cache\n      _memoryCache[key] = {\n        'data': diskItem.data,\n        'timestamp': DateTime.now(),\n      };\n      return fromJson(diskItem.data);\n    }\n\n    return null;\n  }\n\n  Future&lt;void&gt; set&lt;T&gt;(String key, T data, Map&lt;String, dynamic&gt; Function(T) toJson) async {\n    final jsonData = toJson(data);\n    final timestamp = DateTime.now();\n\n    // Update memory cache\n    _memoryCache[key] = {\n      'data': jsonData,\n      'timestamp': timestamp,\n    };\n\n    // Update disk cache\n    await _localStorage.setCacheItem(CacheItem(\n      key: key,\n      data: jsonData,\n      timestamp: timestamp,\n    ));\n  }\n\n  Future&lt;void&gt; invalidate(String key) async {\n    _memoryCache.remove(key);\n    await _localStorage.removeCacheItem(key);\n  }\n\n  Future&lt;void&gt; clear() async {\n    _memoryCache.clear();\n    await _localStorage.clearCache();\n  }\n\n  bool _isExpired(DateTime timestamp, Duration ttl) {\n    return DateTime.now().difference(timestamp) &gt; ttl;\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#2-image-caching","title":"2. Image Caching","text":"<pre><code>// lib/services/image_cache_service.dart\nclass OfflineImageCache {\n  static final Map&lt;String, Uint8List&gt; _memoryCache = {};\n  static const String _cacheDir = 'image_cache';\n\n  static Future&lt;Uint8List?&gt; getImage(String url) async {\n    // Check memory cache\n    if (_memoryCache.containsKey(url)) {\n      return _memoryCache[url];\n    }\n\n    // Check disk cache\n    final file = await _getCacheFile(url);\n    if (await file.exists()) {\n      final bytes = await file.readAsBytes();\n      _memoryCache[url] = bytes;\n      return bytes;\n    }\n\n    return null;\n  }\n\n  static Future&lt;void&gt; cacheImage(String url, Uint8List bytes) async {\n    // Cache in memory\n    _memoryCache[url] = bytes;\n\n    // Cache on disk\n    final file = await _getCacheFile(url);\n    await file.writeAsBytes(bytes);\n  }\n\n  static Future&lt;File&gt; _getCacheFile(String url) async {\n    final directory = await getApplicationDocumentsDirectory();\n    final cacheDirectory = Directory('${directory.path}/$_cacheDir');\n\n    if (!await cacheDirectory.exists()) {\n      await cacheDirectory.create(recursive: true);\n    }\n\n    final fileName = url.hashCode.toString();\n    return File('${cacheDirectory.path}/$fileName');\n  }\n\n  static Future&lt;void&gt; clearCache() async {\n    _memoryCache.clear();\n\n    final directory = await getApplicationDocumentsDirectory();\n    final cacheDirectory = Directory('${directory.path}/$_cacheDir');\n\n    if (await cacheDirectory.exists()) {\n      await cacheDirectory.delete(recursive: true);\n    }\n  }\n}\n\n// Offline-aware image widget\nclass OfflineImage extends StatelessWidget {\n  final String imageUrl;\n  final double? width;\n  final double? height;\n  final BoxFit fit;\n\n  const OfflineImage({\n    Key? key,\n    required this.imageUrl,\n    this.width,\n    this.height,\n    this.fit = BoxFit.cover,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder&lt;Uint8List?&gt;(\n      future: OfflineImageCache.getImage(imageUrl),\n      builder: (context, snapshot) {\n        if (snapshot.hasData) {\n          return Image.memory(\n            snapshot.data!,\n            width: width,\n            height: height,\n            fit: fit,\n          );\n        }\n\n        // Try to load from network if not cached\n        return Image.network(\n          imageUrl,\n          width: width,\n          height: height,\n          fit: fit,\n          loadingBuilder: (context, child, loadingProgress) {\n            if (loadingProgress == null) {\n              // Cache the image when loaded\n              _cacheNetworkImage();\n              return child;\n            }\n            return const CircularProgressIndicator();\n          },\n          errorBuilder: (context, error, stackTrace) {\n            return Container(\n              width: width,\n              height: height,\n              color: Colors.grey[300],\n              child: const Icon(Icons.image_not_supported),\n            );\n          },\n        );\n      },\n    );\n  }\n\n  void _cacheNetworkImage() async {\n    try {\n      final response = await http.get(Uri.parse(imageUrl));\n      if (response.statusCode == 200) {\n        await OfflineImageCache.cacheImage(imageUrl, response.bodyBytes);\n      }\n    } catch (e) {\n      // Ignore caching errors\n    }\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#sync-management","title":"Sync Management","text":""},{"location":"data/offline-support/#1-sync-service","title":"1. Sync Service","text":"<pre><code>// lib/services/sync_service.dart\nclass SyncService {\n  final LocalDatabase _localDb;\n  final ApiClient _apiClient;\n  final ConnectivityService _connectivity;\n  bool _isSyncing = false;\n\n  SyncService(this._localDb, this._apiClient, this._connectivity);\n\n  Future&lt;void&gt; syncAll() async {\n    if (_isSyncing || !_connectivity.isConnected) return;\n\n    _isSyncing = true;\n\n    try {\n      await _syncPendingChanges();\n      await _syncFromServer();\n    } catch (e) {\n      print('Sync failed: $e');\n    } finally {\n      _isSyncing = false;\n    }\n  }\n\n  Future&lt;void&gt; _syncPendingChanges() async {\n    final pendingItems = await _localDb.getPendingSyncItems();\n\n    for (final item in pendingItems) {\n      try {\n        await _processSyncItem(item);\n        await _localDb.removeSyncQueueItem(item.id);\n      } catch (e) {\n        print('Failed to sync item ${item.id}: $e');\n        // Keep item in queue for retry\n      }\n    }\n  }\n\n  Future&lt;void&gt; _processSyncItem(SyncQueueItem item) async {\n    switch (item.operation) {\n      case 'CREATE':\n        await _syncCreate(item);\n        break;\n      case 'UPDATE':\n        await _syncUpdate(item);\n        break;\n      case 'DELETE':\n        await _syncDelete(item);\n        break;\n    }\n  }\n\n  Future&lt;void&gt; _syncCreate(SyncQueueItem item) async {\n    if (item.tableName == 'posts') {\n      final postData = jsonDecode(item.data!);\n      final post = Post.fromMap(postData);\n      await _apiClient.createPost(post);\n    }\n  }\n\n  Future&lt;void&gt; _syncFromServer() async {\n    // Fetch latest data from server\n    final serverPosts = await _apiClient.getAllPosts();\n\n    for (final serverPost in serverPosts) {\n      final localPost = await _localDb.getPostById(serverPost.id);\n\n      if (localPost == null) {\n        // New post from server\n        await _localDb.savePost(serverPost.copyWith(isSynced: true));\n      } else if (serverPost.updatedAt.isAfter(localPost.updatedAt)) {\n        // Server version is newer\n        await _localDb.savePost(serverPost.copyWith(isSynced: true));\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#2-conflict-resolution","title":"2. Conflict Resolution","text":"<pre><code>// lib/services/conflict_resolver.dart\nclass ConflictResolver {\n  static Future&lt;T&gt; resolveConflict&lt;T&gt;({\n    required T localVersion,\n    required T serverVersion,\n    required ConflictResolutionStrategy strategy,\n  }) async {\n    switch (strategy) {\n      case ConflictResolutionStrategy.serverWins:\n        return serverVersion;\n\n      case ConflictResolutionStrategy.clientWins:\n        return localVersion;\n\n      case ConflictResolutionStrategy.manual:\n        return await _showConflictDialog(localVersion, serverVersion);\n\n      case ConflictResolutionStrategy.merge:\n        return _mergeVersions(localVersion, serverVersion);\n    }\n  }\n\n  static Future&lt;T&gt; _showConflictDialog&lt;T&gt;(T local, T server) async {\n    // Show dialog to user for manual resolution\n    // This is a simplified example\n    return server; // Default to server version\n  }\n\n  static T _mergeVersions&lt;T&gt;(T local, T server) {\n    // Implement merge logic based on type\n    // This is a simplified example\n    return server;\n  }\n}\n\nenum ConflictResolutionStrategy {\n  serverWins,\n  clientWins,\n  manual,\n  merge,\n}\n</code></pre>"},{"location":"data/offline-support/#offline-ui-components","title":"Offline UI Components","text":""},{"location":"data/offline-support/#1-offline-indicator","title":"1. Offline Indicator","text":"<pre><code>// lib/widgets/offline_indicator.dart\nclass OfflineIndicator extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder&lt;bool&gt;(\n      stream: GetIt.instance&lt;ConnectivityService&gt;().connectionStream,\n      builder: (context, snapshot) {\n        final isConnected = snapshot.data ?? true;\n\n        if (isConnected) {\n          return const SizedBox.shrink();\n        }\n\n        return Container(\n          width: double.infinity,\n          padding: const EdgeInsets.all(8),\n          color: Colors.orange,\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: const [\n              Icon(Icons.cloud_off, color: Colors.white, size: 16),\n              SizedBox(width: 8),\n              Text(\n                'You are offline',\n                style: TextStyle(color: Colors.white, fontSize: 14),\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#2-sync-status-widget","title":"2. Sync Status Widget","text":"<pre><code>// lib/widgets/sync_status_widget.dart\nclass SyncStatusWidget extends StatefulWidget {\n  @override\n  _SyncStatusWidgetState createState() =&gt; _SyncStatusWidgetState();\n}\n\nclass _SyncStatusWidgetState extends State&lt;SyncStatusWidget&gt; {\n  bool _isSyncing = false;\n  DateTime? _lastSyncTime;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: Row(\n        children: [\n          if (_isSyncing)\n            const SizedBox(\n              width: 16,\n              height: 16,\n              child: CircularProgressIndicator(strokeWidth: 2),\n            )\n          else\n            Icon(\n              Icons.sync,\n              size: 16,\n              color: _lastSyncTime != null ? Colors.green : Colors.grey,\n            ),\n          const SizedBox(width: 8),\n          Text(\n            _getSyncStatusText(),\n            style: const TextStyle(fontSize: 12),\n          ),\n        ],\n      ),\n    );\n  }\n\n  String _getSyncStatusText() {\n    if (_isSyncing) return 'Syncing...';\n    if (_lastSyncTime == null) return 'Not synced';\n\n    final difference = DateTime.now().difference(_lastSyncTime!);\n    if (difference.inMinutes &lt; 1) return 'Just synced';\n    if (difference.inHours &lt; 1) return '${difference.inMinutes}m ago';\n    return '${difference.inHours}h ago';\n  }\n}\n</code></pre>"},{"location":"data/offline-support/#testing-offline-functionality","title":"Testing Offline Functionality","text":""},{"location":"data/offline-support/#1-offline-testing","title":"1. Offline Testing","text":"<pre><code>// test/offline/offline_repository_test.dart\nvoid main() {\n  group('Offline Repository Tests', () {\n    late PostRepository repository;\n    late MockLocalDatabase mockLocalDb;\n    late MockApiClient mockApiClient;\n    late MockConnectivityService mockConnectivity;\n\n    setUp(() {\n      mockLocalDb = MockLocalDatabase();\n      mockApiClient = MockApiClient();\n      mockConnectivity = MockConnectivityService();\n      repository = PostRepository(mockLocalDb, mockApiClient, mockConnectivity);\n    });\n\n    test('should return local data when offline', () async {\n      // Arrange\n      when(mockConnectivity.isConnected()).thenAnswer((_) async =&gt; false);\n      when(mockLocalDb.getAllPosts()).thenAnswer((_) async =&gt; [testPost]);\n\n      // Act\n      final posts = await repository.getAll();\n\n      // Assert\n      expect(posts, [testPost]);\n      verify(mockLocalDb.getAllPosts()).called(1);\n      verifyNever(mockApiClient.getAllPosts());\n    });\n\n    test('should sync with server when online', () async {\n      // Arrange\n      when(mockConnectivity.isConnected()).thenAnswer((_) async =&gt; true);\n      when(mockApiClient.getAllPosts()).thenAnswer((_) async =&gt; [serverPost]);\n      when(mockLocalDb.getAllPosts()).thenAnswer((_) async =&gt; [serverPost]);\n\n      // Act\n      final posts = await repository.getAll();\n\n      // Assert\n      expect(posts, [serverPost]);\n      verify(mockApiClient.getAllPosts()).called(1);\n      verify(mockLocalDb.savePosts([serverPost])).called(1);\n    });\n  });\n}\n</code></pre> <p>Offline support is essential for modern mobile apps. Design your data layer with offline-first principles and provide clear feedback to users about connectivity status.</p>"},{"location":"data/realtime-data/","title":"Real-time Data","text":"<p>Comprehensive guide to implementing real-time data synchronization in Flutter applications using WebSockets, Server-Sent Events, and Supabase Realtime.</p>"},{"location":"data/realtime-data/#overview","title":"Overview","text":"<p>Real-time data enables instant updates across your Flutter app, providing users with live information and collaborative features. This guide covers various real-time technologies and implementation patterns.</p>"},{"location":"data/realtime-data/#supabase-realtime","title":"Supabase Realtime","text":""},{"location":"data/realtime-data/#1-realtime-setup","title":"1. Realtime Setup","text":"<pre><code>// lib/services/realtime_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass RealtimeService {\n  final SupabaseClient _supabase = Supabase.instance.client;\n  final Map&lt;String, RealtimeChannel&gt; _channels = {};\n  final Map&lt;String, StreamController&gt; _controllers = {};\n\n  // Posts realtime stream\n  Stream&lt;List&lt;Post&gt;&gt; get postsStream {\n    if (!_controllers.containsKey('posts')) {\n      _controllers['posts'] = StreamController&lt;List&lt;Post&gt;&gt;.broadcast();\n      _setupPostsChannel();\n    }\n    return _controllers['posts']!.stream as Stream&lt;List&lt;Post&gt;&gt;;\n  }\n\n  // Comments realtime stream\n  Stream&lt;List&lt;Comment&gt;&gt; commentsStream(String postId) {\n    final key = 'comments_$postId';\n    if (!_controllers.containsKey(key)) {\n      _controllers[key] = StreamController&lt;List&lt;Comment&gt;&gt;.broadcast();\n      _setupCommentsChannel(postId);\n    }\n    return _controllers[key]!.stream as Stream&lt;List&lt;Comment&gt;&gt;;\n  }\n\n  void _setupPostsChannel() {\n    final channel = _supabase.channel('public:posts');\n\n    // Listen to INSERT events\n    channel.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'INSERT',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final newPost = Post.fromJson(payload['new']);\n        _handlePostInsert(newPost);\n      },\n    );\n\n    // Listen to UPDATE events\n    channel.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'UPDATE',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final updatedPost = Post.fromJson(payload['new']);\n        _handlePostUpdate(updatedPost);\n      },\n    );\n\n    // Listen to DELETE events\n    channel.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'DELETE',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final deletedPostId = payload['old']['id'];\n        _handlePostDelete(deletedPostId);\n      },\n    );\n\n    channel.subscribe();\n    _channels['posts'] = channel;\n  }\n\n  void _setupCommentsChannel(String postId) {\n    final channel = _supabase.channel('comments_$postId');\n\n    channel.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: '*',\n        schema: 'public',\n        table: 'comments',\n        filter: 'post_id=eq.$postId',\n      ),\n      (payload) {\n        _handleCommentChange(postId, payload);\n      },\n    );\n\n    channel.subscribe();\n    _channels['comments_$postId'] = channel;\n  }\n\n  void _handlePostInsert(Post post) {\n    // Update local state and notify listeners\n    final controller = _controllers['posts'] as StreamController&lt;List&lt;Post&gt;&gt;;\n    // Implementation depends on your state management\n  }\n\n  void _handlePostUpdate(Post post) {\n    // Update existing post in local state\n  }\n\n  void _handlePostDelete(String postId) {\n    // Remove post from local state\n  }\n\n  void _handleCommentChange(String postId, Map&lt;String, dynamic&gt; payload) {\n    final event = payload['eventType'];\n    final controller = _controllers['comments_$postId'] as StreamController&lt;List&lt;Comment&gt;&gt;;\n\n    switch (event) {\n      case 'INSERT':\n        final newComment = Comment.fromJson(payload['new']);\n        // Add to local state\n        break;\n      case 'UPDATE':\n        final updatedComment = Comment.fromJson(payload['new']);\n        // Update in local state\n        break;\n      case 'DELETE':\n        final deletedCommentId = payload['old']['id'];\n        // Remove from local state\n        break;\n    }\n  }\n\n  void dispose() {\n    for (final channel in _channels.values) {\n      channel.unsubscribe();\n    }\n    _channels.clear();\n\n    for (final controller in _controllers.values) {\n      controller.close();\n    }\n    _controllers.clear();\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#2-realtime-provider-integration","title":"2. Realtime Provider Integration","text":"<pre><code>// lib/providers/realtime_posts_provider.dart\nclass RealtimePostsNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt; {\n  final PostRepository _repository;\n  final RealtimeService _realtimeService;\n  StreamSubscription? _subscription;\n\n  RealtimePostsNotifier(this._repository, this._realtimeService) \n      : super(const AsyncValue.loading()) {\n    _initialize();\n  }\n\n  void _initialize() async {\n    // Load initial data\n    try {\n      final posts = await _repository.getAllPosts();\n      state = AsyncValue.data(posts);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n\n    // Subscribe to realtime updates\n    _subscription = _realtimeService.postsStream.listen(\n      (posts) {\n        state = AsyncValue.data(posts);\n      },\n      onError: (error) {\n        // Handle realtime errors gracefully\n        print('Realtime error: $error');\n      },\n    );\n  }\n\n  Future&lt;void&gt; createPost(CreatePostRequest request) async {\n    try {\n      // Optimistic update\n      final currentPosts = state.valueOrNull ?? [];\n      final optimisticPost = Post(\n        id: 'temp_${DateTime.now().millisecondsSinceEpoch}',\n        content: request.content,\n        userId: request.userId,\n        createdAt: DateTime.now(),\n        isOptimistic: true,\n      );\n\n      state = AsyncValue.data([optimisticPost, ...currentPosts]);\n\n      // Create on server (realtime will handle the update)\n      await _repository.createPost(request);\n\n    } catch (error) {\n      // Revert optimistic update\n      final currentPosts = state.valueOrNull ?? [];\n      final revertedPosts = currentPosts.where((post) =&gt; !post.isOptimistic).toList();\n      state = AsyncValue.data(revertedPosts);\n      rethrow;\n    }\n  }\n\n  @override\n  void dispose() {\n    _subscription?.cancel();\n    super.dispose();\n  }\n}\n\nfinal realtimePostsProvider = StateNotifierProvider&lt;RealtimePostsNotifier, AsyncValue&lt;List&lt;Post&gt;&gt;&gt;((ref) {\n  final repository = ref.read(postRepositoryProvider);\n  final realtimeService = ref.read(realtimeServiceProvider);\n  return RealtimePostsNotifier(repository, realtimeService);\n});\n</code></pre>"},{"location":"data/realtime-data/#websocket-implementation","title":"WebSocket Implementation","text":""},{"location":"data/realtime-data/#1-websocket-service","title":"1. WebSocket Service","text":"<pre><code>// lib/services/websocket_service.dart\nimport 'package:web_socket_channel/web_socket_channel.dart';\n\nclass WebSocketService {\n  WebSocketChannel? _channel;\n  final String _url;\n  final Map&lt;String, StreamController&gt; _controllers = {};\n  bool _isConnected = false;\n  Timer? _heartbeatTimer;\n  Timer? _reconnectTimer;\n  int _reconnectAttempts = 0;\n  static const int _maxReconnectAttempts = 5;\n\n  WebSocketService(this._url);\n\n  bool get isConnected =&gt; _isConnected;\n\n  Future&lt;void&gt; connect() async {\n    try {\n      _channel = WebSocketChannel.connect(Uri.parse(_url));\n      _isConnected = true;\n      _reconnectAttempts = 0;\n\n      // Listen to messages\n      _channel!.stream.listen(\n        _handleMessage,\n        onError: _handleError,\n        onDone: _handleDisconnection,\n      );\n\n      // Start heartbeat\n      _startHeartbeat();\n\n      print('WebSocket connected');\n    } catch (error) {\n      print('WebSocket connection failed: $error');\n      _scheduleReconnect();\n    }\n  }\n\n  void _handleMessage(dynamic message) {\n    try {\n      final data = jsonDecode(message);\n      final type = data['type'];\n      final payload = data['payload'];\n\n      switch (type) {\n        case 'post_created':\n          _notifyListeners('posts', payload);\n          break;\n        case 'post_updated':\n          _notifyListeners('posts', payload);\n          break;\n        case 'comment_created':\n          _notifyListeners('comments_${payload['post_id']}', payload);\n          break;\n        case 'user_online':\n          _notifyListeners('user_status', payload);\n          break;\n        case 'heartbeat':\n          // Heartbeat response\n          break;\n      }\n    } catch (error) {\n      print('Error handling WebSocket message: $error');\n    }\n  }\n\n  void _handleError(error) {\n    print('WebSocket error: $error');\n    _isConnected = false;\n    _scheduleReconnect();\n  }\n\n  void _handleDisconnection() {\n    print('WebSocket disconnected');\n    _isConnected = false;\n    _heartbeatTimer?.cancel();\n    _scheduleReconnect();\n  }\n\n  void _scheduleReconnect() {\n    if (_reconnectAttempts &gt;= _maxReconnectAttempts) {\n      print('Max reconnection attempts reached');\n      return;\n    }\n\n    _reconnectAttempts++;\n    final delay = Duration(seconds: math.pow(2, _reconnectAttempts).toInt());\n\n    _reconnectTimer = Timer(delay, () {\n      print('Attempting to reconnect... (${_reconnectAttempts}/$_maxReconnectAttempts)');\n      connect();\n    });\n  }\n\n  void _startHeartbeat() {\n    _heartbeatTimer = Timer.periodic(const Duration(seconds: 30), (_) {\n      if (_isConnected) {\n        send('heartbeat', {});\n      }\n    });\n  }\n\n  void send(String type, Map&lt;String, dynamic&gt; payload) {\n    if (_isConnected &amp;&amp; _channel != null) {\n      final message = jsonEncode({\n        'type': type,\n        'payload': payload,\n      });\n      _channel!.sink.add(message);\n    }\n  }\n\n  Stream&lt;T&gt; subscribe&lt;T&gt;(String channel, T Function(Map&lt;String, dynamic&gt;) fromJson) {\n    if (!_controllers.containsKey(channel)) {\n      _controllers[channel] = StreamController&lt;T&gt;.broadcast();\n    }\n    return _controllers[channel]!.stream as Stream&lt;T&gt;;\n  }\n\n  void _notifyListeners(String channel, Map&lt;String, dynamic&gt; data) {\n    if (_controllers.containsKey(channel)) {\n      _controllers[channel]!.add(data);\n    }\n  }\n\n  void disconnect() {\n    _heartbeatTimer?.cancel();\n    _reconnectTimer?.cancel();\n    _channel?.sink.close();\n    _isConnected = false;\n\n    for (final controller in _controllers.values) {\n      controller.close();\n    }\n    _controllers.clear();\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#2-websocket-provider","title":"2. WebSocket Provider","text":"<pre><code>// lib/providers/websocket_provider.dart\nfinal webSocketServiceProvider = Provider&lt;WebSocketService&gt;((ref) {\n  final service = WebSocketService('wss://your-websocket-url.com');\n\n  // Auto-connect when provider is created\n  service.connect();\n\n  // Dispose when provider is disposed\n  ref.onDispose(() {\n    service.disconnect();\n  });\n\n  return service;\n});\n\nfinal webSocketConnectionProvider = StreamProvider&lt;bool&gt;((ref) {\n  final service = ref.watch(webSocketServiceProvider);\n  return Stream.periodic(const Duration(seconds: 1), (_) =&gt; service.isConnected);\n});\n</code></pre>"},{"location":"data/realtime-data/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":""},{"location":"data/realtime-data/#1-sse-service","title":"1. SSE Service","text":"<pre><code>// lib/services/sse_service.dart\nimport 'package:http/http.dart' as http;\n\nclass SSEService {\n  final String _url;\n  final Map&lt;String, StreamController&gt; _controllers = {};\n  http.Client? _client;\n  bool _isConnected = false;\n\n  SSEService(this._url);\n\n  bool get isConnected =&gt; _isConnected;\n\n  Stream&lt;T&gt; subscribe&lt;T&gt;(String endpoint, T Function(Map&lt;String, dynamic&gt;) fromJson) {\n    final key = endpoint;\n    if (!_controllers.containsKey(key)) {\n      _controllers[key] = StreamController&lt;T&gt;.broadcast();\n      _startListening(endpoint, fromJson);\n    }\n    return _controllers[key]!.stream as Stream&lt;T&gt;;\n  }\n\n  void _startListening&lt;T&gt;(String endpoint, T Function(Map&lt;String, dynamic&gt;) fromJson) async {\n    try {\n      _client = http.Client();\n      final request = http.Request('GET', Uri.parse('$_url/$endpoint'));\n      request.headers['Accept'] = 'text/event-stream';\n      request.headers['Cache-Control'] = 'no-cache';\n\n      final response = await _client!.send(request);\n      _isConnected = true;\n\n      response.stream\n          .transform(utf8.decoder)\n          .transform(const LineSplitter())\n          .listen(\n            (line) =&gt; _handleSSELine(endpoint, line, fromJson),\n            onError: (error) =&gt; _handleError(endpoint, error),\n            onDone: () =&gt; _handleDisconnection(endpoint),\n          );\n    } catch (error) {\n      _handleError(endpoint, error);\n    }\n  }\n\n  void _handleSSELine&lt;T&gt;(String endpoint, String line, T Function(Map&lt;String, dynamic&gt;) fromJson) {\n    if (line.startsWith('data: ')) {\n      try {\n        final jsonData = line.substring(6);\n        final data = jsonDecode(jsonData);\n        final parsedData = fromJson(data);\n\n        if (_controllers.containsKey(endpoint)) {\n          _controllers[endpoint]!.add(parsedData);\n        }\n      } catch (error) {\n        print('Error parsing SSE data: $error');\n      }\n    }\n  }\n\n  void _handleError(String endpoint, dynamic error) {\n    print('SSE error for $endpoint: $error');\n    _isConnected = false;\n    // Implement reconnection logic if needed\n  }\n\n  void _handleDisconnection(String endpoint) {\n    print('SSE disconnected for $endpoint');\n    _isConnected = false;\n  }\n\n  void dispose() {\n    _client?.close();\n    _isConnected = false;\n\n    for (final controller in _controllers.values) {\n      controller.close();\n    }\n    _controllers.clear();\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#real-time-ui-components","title":"Real-time UI Components","text":""},{"location":"data/realtime-data/#1-live-feed-widget","title":"1. Live Feed Widget","text":"<pre><code>// lib/widgets/live_feed_widget.dart\nclass LiveFeedWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final postsAsync = ref.watch(realtimePostsProvider);\n\n    return postsAsync.when(\n      data: (posts) =&gt; _buildFeed(posts),\n      loading: () =&gt; const Center(child: CircularProgressIndicator()),\n      error: (error, stack) =&gt; _buildErrorWidget(error),\n    );\n  }\n\n  Widget _buildFeed(List&lt;Post&gt; posts) {\n    return RefreshIndicator(\n      onRefresh: () async {\n        // Manual refresh if needed\n      },\n      child: ListView.builder(\n        itemCount: posts.length,\n        itemBuilder: (context, index) {\n          final post = posts[index];\n          return AnimatedContainer(\n            duration: const Duration(milliseconds: 300),\n            child: PostWidget(\n              post: post,\n              isNew: post.isNew, // Highlight new posts\n            ),\n          );\n        },\n      ),\n    );\n  }\n\n  Widget _buildErrorWidget(Object error) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          const Icon(Icons.error, size: 48, color: Colors.red),\n          const SizedBox(height: 16),\n          Text('Failed to load feed: $error'),\n          const SizedBox(height: 16),\n          ElevatedButton(\n            onPressed: () {\n              // Retry logic\n            },\n            child: const Text('Retry'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#2-real-time-comments","title":"2. Real-time Comments","text":"<pre><code>// lib/widgets/realtime_comments_widget.dart\nclass RealtimeCommentsWidget extends ConsumerWidget {\n  final String postId;\n\n  const RealtimeCommentsWidget({Key? key, required this.postId}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final commentsAsync = ref.watch(realtimeCommentsProvider(postId));\n\n    return commentsAsync.when(\n      data: (comments) =&gt; _buildComments(comments, ref),\n      loading: () =&gt; const CircularProgressIndicator(),\n      error: (error, stack) =&gt; Text('Error: $error'),\n    );\n  }\n\n  Widget _buildComments(List&lt;Comment&gt; comments, WidgetRef ref) {\n    return Column(\n      children: [\n        Expanded(\n          child: ListView.builder(\n            itemCount: comments.length,\n            itemBuilder: (context, index) {\n              final comment = comments[index];\n              return AnimatedSlide(\n                offset: comment.isNew ? const Offset(1, 0) : Offset.zero,\n                duration: const Duration(milliseconds: 300),\n                child: CommentWidget(comment: comment),\n              );\n            },\n          ),\n        ),\n        CommentInputWidget(\n          onSubmit: (content) {\n            ref.read(realtimeCommentsProvider(postId).notifier)\n                .addComment(content);\n          },\n        ),\n      ],\n    );\n  }\n}\n\nfinal realtimeCommentsProvider = StateNotifierProvider.family&lt;\n    RealtimeCommentsNotifier, \n    AsyncValue&lt;List&lt;Comment&gt;&gt;, \n    String\n&gt;((ref, postId) {\n  final realtimeService = ref.read(realtimeServiceProvider);\n  return RealtimeCommentsNotifier(postId, realtimeService);\n});\n</code></pre>"},{"location":"data/realtime-data/#3-connection-status-indicator","title":"3. Connection Status Indicator","text":"<pre><code>// lib/widgets/connection_status_widget.dart\nclass ConnectionStatusWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final isConnected = ref.watch(webSocketConnectionProvider).valueOrNull ?? false;\n\n    return AnimatedContainer(\n      duration: const Duration(milliseconds: 300),\n      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),\n      decoration: BoxDecoration(\n        color: isConnected ? Colors.green : Colors.red,\n        borderRadius: BorderRadius.circular(12),\n      ),\n      child: Row(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Icon(\n            isConnected ? Icons.wifi : Icons.wifi_off,\n            size: 16,\n            color: Colors.white,\n          ),\n          const SizedBox(width: 4),\n          Text(\n            isConnected ? 'Live' : 'Offline',\n            style: const TextStyle(\n              color: Colors.white,\n              fontSize: 12,\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#performance-optimization","title":"Performance Optimization","text":""},{"location":"data/realtime-data/#1-message-throttling","title":"1. Message Throttling","text":"<pre><code>// lib/utils/message_throttler.dart\nclass MessageThrottler {\n  final Duration _throttleDuration;\n  final Map&lt;String, Timer&gt; _timers = {};\n  final Map&lt;String, dynamic&gt; _pendingMessages = {};\n\n  MessageThrottler({Duration throttleDuration = const Duration(milliseconds: 100)})\n      : _throttleDuration = throttleDuration;\n\n  void throttle(String key, dynamic message, void Function(dynamic) callback) {\n    _pendingMessages[key] = message;\n\n    if (_timers.containsKey(key)) {\n      _timers[key]!.cancel();\n    }\n\n    _timers[key] = Timer(_throttleDuration, () {\n      final pendingMessage = _pendingMessages[key];\n      if (pendingMessage != null) {\n        callback(pendingMessage);\n        _pendingMessages.remove(key);\n      }\n      _timers.remove(key);\n    });\n  }\n\n  void dispose() {\n    for (final timer in _timers.values) {\n      timer.cancel();\n    }\n    _timers.clear();\n    _pendingMessages.clear();\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#2-efficient-state-updates","title":"2. Efficient State Updates","text":"<pre><code>// lib/providers/optimized_realtime_provider.dart\nclass OptimizedRealtimeNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt; {\n  final MessageThrottler _throttler = MessageThrottler();\n\n  OptimizedRealtimeNotifier() : super(const AsyncValue.loading());\n\n  void handleRealtimeUpdate(Post updatedPost) {\n    _throttler.throttle('posts_update', updatedPost, (post) {\n      final currentPosts = state.valueOrNull ?? [];\n      final updatedPosts = currentPosts.map((p) {\n        return p.id == post.id ? post : p;\n      }).toList();\n\n      state = AsyncValue.data(updatedPosts);\n    });\n  }\n\n  @override\n  void dispose() {\n    _throttler.dispose();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"data/realtime-data/#testing-real-time-features","title":"Testing Real-time Features","text":""},{"location":"data/realtime-data/#1-real-time-testing","title":"1. Real-time Testing","text":"<pre><code>// test/realtime/realtime_service_test.dart\nvoid main() {\n  group('Realtime Service Tests', () {\n    late RealtimeService service;\n    late MockSupabaseClient mockSupabase;\n\n    setUp(() {\n      mockSupabase = MockSupabaseClient();\n      service = RealtimeService();\n    });\n\n    test('should handle post insertion', () async {\n      // Arrange\n      final testPost = Post(id: '1', content: 'Test', userId: 'user1');\n\n      // Act\n      service._handlePostInsert(testPost);\n\n      // Assert\n      // Verify that the post was added to the stream\n    });\n\n    test('should reconnect on connection loss', () async {\n      // Test reconnection logic\n    });\n  });\n}\n</code></pre> <p>Real-time features enhance user engagement but require careful implementation to handle connection issues and optimize performance. Always provide fallbacks for offline scenarios.</p>"},{"location":"data/state-sync/","title":"State Synchronization","text":"<p>Comprehensive guide to synchronizing application state across different parts of your Flutter app and with external data sources.</p>"},{"location":"data/state-sync/#overview","title":"Overview","text":"<p>State synchronization ensures data consistency across your Flutter application, from local state management to server synchronization. This guide covers patterns, tools, and best practices.</p>"},{"location":"data/state-sync/#local-state-synchronization","title":"Local State Synchronization","text":""},{"location":"data/state-sync/#1-riverpod-state-sync","title":"1. Riverpod State Sync","text":"<pre><code>// lib/providers/sync_provider.dart\nimport 'package:riverpod/riverpod.dart';\n\n// Global state that needs to be synced\nfinal userProvider = StateNotifierProvider&lt;UserNotifier, AsyncValue&lt;User&gt;&gt;((ref) {\n  return UserNotifier(ref);\n});\n\nfinal postsProvider = StateNotifierProvider&lt;PostsNotifier, AsyncValue&lt;List&lt;Post&gt;&gt;&gt;((ref) {\n  return PostsNotifier(ref);\n});\n\nclass UserNotifier extends StateNotifier&lt;AsyncValue&lt;User&gt;&gt; {\n  final Ref ref;\n\n  UserNotifier(this.ref) : super(const AsyncValue.loading());\n\n  Future&lt;void&gt; updateUser(User user) async {\n    state = AsyncValue.data(user);\n\n    // Sync with other providers that depend on user\n    ref.read(postsProvider.notifier).onUserChanged(user);\n    ref.read(settingsProvider.notifier).onUserChanged(user);\n  }\n\n  Future&lt;void&gt; syncWithServer() async {\n    try {\n      final user = await userRepository.getCurrentUser();\n      state = AsyncValue.data(user);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n}\n\nclass PostsNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt; {\n  final Ref ref;\n\n  PostsNotifier(this.ref) : super(const AsyncValue.loading());\n\n  void onUserChanged(User user) {\n    // Reload posts when user changes\n    loadUserPosts(user.id);\n  }\n\n  Future&lt;void&gt; loadUserPosts(String userId) async {\n    try {\n      final posts = await postRepository.getUserPosts(userId);\n      state = AsyncValue.data(posts);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#2-cross-provider-dependencies","title":"2. Cross-Provider Dependencies","text":"<pre><code>// lib/providers/dependent_providers.dart\n\n// Provider that depends on user state\nfinal userPostsProvider = FutureProvider.family&lt;List&lt;Post&gt;, String&gt;((ref, userId) async {\n  // Watch user changes\n  final user = ref.watch(userProvider);\n\n  return user.when(\n    data: (userData) =&gt; postRepository.getUserPosts(userData.id),\n    loading: () =&gt; [],\n    error: (_, __) =&gt; [],\n  );\n});\n\n// Provider that combines multiple states\nfinal dashboardProvider = Provider&lt;DashboardData&gt;((ref) {\n  final user = ref.watch(userProvider);\n  final posts = ref.watch(postsProvider);\n  final notifications = ref.watch(notificationsProvider);\n\n  return DashboardData(\n    user: user.valueOrNull,\n    posts: posts.valueOrNull ?? [],\n    notifications: notifications.valueOrNull ?? [],\n  );\n});\n\nclass DashboardData {\n  final User? user;\n  final List&lt;Post&gt; posts;\n  final List&lt;Notification&gt; notifications;\n\n  const DashboardData({\n    this.user,\n    required this.posts,\n    required this.notifications,\n  });\n}\n</code></pre>"},{"location":"data/state-sync/#3-state-synchronization-service","title":"3. State Synchronization Service","text":"<pre><code>// lib/services/state_sync_service.dart\nclass StateSyncService {\n  final Ref ref;\n  final List&lt;StreamSubscription&gt; _subscriptions = [];\n\n  StateSyncService(this.ref);\n\n  void initialize() {\n    // Listen to user changes and sync dependent states\n    _subscriptions.add(\n      ref.listen(userProvider, (previous, next) {\n        next.whenData((user) {\n          _syncUserDependentStates(user);\n        });\n      }),\n    );\n\n    // Listen to connectivity changes\n    _subscriptions.add(\n      ref.listen(connectivityProvider, (previous, next) {\n        if (next == ConnectivityResult.wifi || next == ConnectivityResult.mobile) {\n          _syncAllStatesWithServer();\n        }\n      }),\n    );\n  }\n\n  void _syncUserDependentStates(User user) {\n    // Trigger sync for all user-dependent providers\n    ref.read(postsProvider.notifier).loadUserPosts(user.id);\n    ref.read(settingsProvider.notifier).loadUserSettings(user.id);\n    ref.read(friendsProvider.notifier).loadUserFriends(user.id);\n  }\n\n  Future&lt;void&gt; _syncAllStatesWithServer() async {\n    await Future.wait([\n      ref.read(userProvider.notifier).syncWithServer(),\n      ref.read(postsProvider.notifier).syncWithServer(),\n      ref.read(settingsProvider.notifier).syncWithServer(),\n    ]);\n  }\n\n  void dispose() {\n    for (final subscription in _subscriptions) {\n      subscription.cancel();\n    }\n    _subscriptions.clear();\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#server-state-synchronization","title":"Server State Synchronization","text":""},{"location":"data/state-sync/#1-real-time-sync-with-supabase","title":"1. Real-time Sync with Supabase","text":"<pre><code>// lib/services/realtime_sync_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass RealtimeSyncService {\n  final SupabaseClient _supabase = Supabase.instance.client;\n  final Ref ref;\n  RealtimeChannel? _channel;\n\n  RealtimeSyncService(this.ref);\n\n  void initialize() {\n    _setupRealtimeSubscriptions();\n  }\n\n  void _setupRealtimeSubscriptions() {\n    _channel = _supabase.channel('public:posts');\n\n    // Listen to post insertions\n    _channel!.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'INSERT',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final newPost = Post.fromJson(payload['new']);\n        ref.read(postsProvider.notifier).addPost(newPost);\n      },\n    );\n\n    // Listen to post updates\n    _channel!.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'UPDATE',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final updatedPost = Post.fromJson(payload['new']);\n        ref.read(postsProvider.notifier).updatePost(updatedPost);\n      },\n    );\n\n    // Listen to post deletions\n    _channel!.on(\n      RealtimeListenTypes.postgresChanges,\n      ChannelFilter(\n        event: 'DELETE',\n        schema: 'public',\n        table: 'posts',\n      ),\n      (payload) {\n        final deletedPostId = payload['old']['id'];\n        ref.read(postsProvider.notifier).removePost(deletedPostId);\n      },\n    );\n\n    _channel!.subscribe();\n  }\n\n  void dispose() {\n    _channel?.unsubscribe();\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#2-optimistic-updates","title":"2. Optimistic Updates","text":"<pre><code>// lib/providers/optimistic_posts_provider.dart\nclass OptimisticPostsNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt; {\n  final PostRepository repository;\n  final Ref ref;\n\n  OptimisticPostsNotifier(this.repository, this.ref) : super(const AsyncValue.loading());\n\n  Future&lt;void&gt; createPost(CreatePostRequest request) async {\n    final currentPosts = state.valueOrNull ?? [];\n\n    // Create optimistic post\n    final optimisticPost = Post(\n      id: 'temp_${DateTime.now().millisecondsSinceEpoch}',\n      content: request.content,\n      userId: request.userId,\n      createdAt: DateTime.now(),\n      isOptimistic: true,\n    );\n\n    // Update state optimistically\n    state = AsyncValue.data([optimisticPost, ...currentPosts]);\n\n    try {\n      // Send to server\n      final serverPost = await repository.createPost(request);\n\n      // Replace optimistic post with server response\n      final updatedPosts = currentPosts.map((post) {\n        return post.id == optimisticPost.id ? serverPost : post;\n      }).toList();\n\n      state = AsyncValue.data(updatedPosts);\n    } catch (error) {\n      // Revert optimistic update on error\n      state = AsyncValue.data(currentPosts);\n\n      // Show error to user\n      ref.read(errorProvider.notifier).showError('Failed to create post');\n      rethrow;\n    }\n  }\n\n  Future&lt;void&gt; deletePost(String postId) async {\n    final currentPosts = state.valueOrNull ?? [];\n    final postToDelete = currentPosts.firstWhere((post) =&gt; post.id == postId);\n\n    // Remove optimistically\n    final optimisticPosts = currentPosts.where((post) =&gt; post.id != postId).toList();\n    state = AsyncValue.data(optimisticPosts);\n\n    try {\n      await repository.deletePost(postId);\n    } catch (error) {\n      // Revert on error\n      state = AsyncValue.data([...optimisticPosts, postToDelete]);\n      ref.read(errorProvider.notifier).showError('Failed to delete post');\n      rethrow;\n    }\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#3-conflict-resolution","title":"3. Conflict Resolution","text":"<pre><code>// lib/services/conflict_resolution_service.dart\nclass ConflictResolutionService {\n  static T resolveConflict&lt;T&gt;({\n    required T localVersion,\n    required T serverVersion,\n    required DateTime localTimestamp,\n    required DateTime serverTimestamp,\n    ConflictResolutionStrategy strategy = ConflictResolutionStrategy.serverWins,\n  }) {\n    switch (strategy) {\n      case ConflictResolutionStrategy.serverWins:\n        return serverVersion;\n\n      case ConflictResolutionStrategy.clientWins:\n        return localVersion;\n\n      case ConflictResolutionStrategy.lastWriteWins:\n        return localTimestamp.isAfter(serverTimestamp) ? localVersion : serverVersion;\n\n      case ConflictResolutionStrategy.merge:\n        return _mergeVersions(localVersion, serverVersion);\n    }\n  }\n\n  static T _mergeVersions&lt;T&gt;(T local, T server) {\n    // Implement merge logic based on type\n    if (T == Post) {\n      return _mergePosts(local as Post, server as Post) as T;\n    }\n\n    // Default to server version\n    return server;\n  }\n\n  static Post _mergePosts(Post local, Post server) {\n    return Post(\n      id: server.id,\n      content: local.content.isNotEmpty ? local.content : server.content,\n      userId: server.userId,\n      createdAt: server.createdAt,\n      updatedAt: DateTime.now(),\n      likes: server.likes, // Server has authoritative like count\n    );\n  }\n}\n\nenum ConflictResolutionStrategy {\n  serverWins,\n  clientWins,\n  lastWriteWins,\n  merge,\n}\n</code></pre>"},{"location":"data/state-sync/#background-synchronization","title":"Background Synchronization","text":""},{"location":"data/state-sync/#1-background-sync-service","title":"1. Background Sync Service","text":"<pre><code>// lib/services/background_sync_service.dart\nclass BackgroundSyncService {\n  final Ref ref;\n  Timer? _syncTimer;\n\n  BackgroundSyncService(this.ref);\n\n  void startPeriodicSync({Duration interval = const Duration(minutes: 5)}) {\n    _syncTimer = Timer.periodic(interval, (_) {\n      _performBackgroundSync();\n    });\n  }\n\n  Future&lt;void&gt; _performBackgroundSync() async {\n    try {\n      // Only sync if app is in background and connected\n      final appState = ref.read(appLifecycleProvider);\n      final connectivity = ref.read(connectivityProvider);\n\n      if (appState != AppLifecycleState.paused) return;\n      if (connectivity == ConnectivityResult.none) return;\n\n      // Sync critical data\n      await Future.wait([\n        _syncUserData(),\n        _syncNotifications(),\n        _syncCriticalPosts(),\n      ]);\n\n    } catch (error) {\n      // Log error but don't throw\n      debugPrint('Background sync failed: $error');\n    }\n  }\n\n  Future&lt;void&gt; _syncUserData() async {\n    await ref.read(userProvider.notifier).syncWithServer();\n  }\n\n  Future&lt;void&gt; _syncNotifications() async {\n    await ref.read(notificationsProvider.notifier).syncWithServer();\n  }\n\n  Future&lt;void&gt; _syncCriticalPosts() async {\n    // Only sync recent posts to save bandwidth\n    await ref.read(postsProvider.notifier).syncRecentPosts();\n  }\n\n  void stopPeriodicSync() {\n    _syncTimer?.cancel();\n    _syncTimer = null;\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#2-sync-queue-management","title":"2. Sync Queue Management","text":"<pre><code>// lib/services/sync_queue_service.dart\nclass SyncQueueService {\n  final Queue&lt;SyncOperation&gt; _queue = Queue();\n  bool _isProcessing = false;\n\n  void addOperation(SyncOperation operation) {\n    _queue.add(operation);\n    _processQueue();\n  }\n\n  Future&lt;void&gt; _processQueue() async {\n    if (_isProcessing || _queue.isEmpty) return;\n\n    _isProcessing = true;\n\n    while (_queue.isNotEmpty) {\n      final operation = _queue.removeFirst();\n\n      try {\n        await operation.execute();\n      } catch (error) {\n        // Handle retry logic\n        if (operation.retryCount &lt; operation.maxRetries) {\n          operation.retryCount++;\n          _queue.add(operation);\n        } else {\n          // Log failed operation\n          debugPrint('Sync operation failed permanently: ${operation.id}');\n        }\n      }\n    }\n\n    _isProcessing = false;\n  }\n}\n\nabstract class SyncOperation {\n  final String id;\n  final int maxRetries;\n  int retryCount;\n\n  SyncOperation({\n    required this.id,\n    this.maxRetries = 3,\n    this.retryCount = 0,\n  });\n\n  Future&lt;void&gt; execute();\n}\n\nclass PostSyncOperation extends SyncOperation {\n  final Post post;\n  final PostRepository repository;\n\n  PostSyncOperation({\n    required this.post,\n    required this.repository,\n  }) : super(id: 'post_${post.id}');\n\n  @override\n  Future&lt;void&gt; execute() async {\n    await repository.syncPost(post);\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#state-persistence","title":"State Persistence","text":""},{"location":"data/state-sync/#1-persistent-state-provider","title":"1. Persistent State Provider","text":"<pre><code>// lib/providers/persistent_state_provider.dart\nclass PersistentStateNotifier&lt;T&gt; extends StateNotifier&lt;T&gt; {\n  final String key;\n  final T Function(Map&lt;String, dynamic&gt;) fromJson;\n  final Map&lt;String, dynamic&gt; Function(T) toJson;\n\n  PersistentStateNotifier({\n    required T initialState,\n    required this.key,\n    required this.fromJson,\n    required this.toJson,\n  }) : super(initialState) {\n    _loadState();\n  }\n\n  Future&lt;void&gt; _loadState() async {\n    try {\n      final prefs = await SharedPreferences.getInstance();\n      final jsonString = prefs.getString(key);\n\n      if (jsonString != null) {\n        final json = jsonDecode(jsonString) as Map&lt;String, dynamic&gt;;\n        state = fromJson(json);\n      }\n    } catch (error) {\n      debugPrint('Failed to load state for $key: $error');\n    }\n  }\n\n  @override\n  set state(T value) {\n    super.state = value;\n    _saveState(value);\n  }\n\n  Future&lt;void&gt; _saveState(T value) async {\n    try {\n      final prefs = await SharedPreferences.getInstance();\n      final jsonString = jsonEncode(toJson(value));\n      await prefs.setString(key, jsonString);\n    } catch (error) {\n      debugPrint('Failed to save state for $key: $error');\n    }\n  }\n}\n\n// Usage\nfinal userSettingsProvider = StateNotifierProvider&lt;PersistentStateNotifier&lt;UserSettings&gt;, UserSettings&gt;((ref) {\n  return PersistentStateNotifier&lt;UserSettings&gt;(\n    initialState: UserSettings.defaultSettings(),\n    key: 'user_settings',\n    fromJson: UserSettings.fromJson,\n    toJson: (settings) =&gt; settings.toJson(),\n  );\n});\n</code></pre>"},{"location":"data/state-sync/#2-sync-status-tracking","title":"2. Sync Status Tracking","text":"<pre><code>// lib/providers/sync_status_provider.dart\nclass SyncStatusNotifier extends StateNotifier&lt;SyncStatus&gt; {\n  SyncStatusNotifier() : super(SyncStatus.idle);\n\n  Future&lt;void&gt; performSync(Future&lt;void&gt; Function() syncOperation) async {\n    state = SyncStatus.syncing;\n\n    try {\n      await syncOperation();\n      state = SyncStatus.success;\n\n      // Reset to idle after showing success\n      Timer(const Duration(seconds: 2), () {\n        if (mounted) state = SyncStatus.idle;\n      });\n    } catch (error) {\n      state = SyncStatus.error;\n\n      // Reset to idle after showing error\n      Timer(const Duration(seconds: 5), () {\n        if (mounted) state = SyncStatus.idle;\n      });\n    }\n  }\n}\n\nenum SyncStatus {\n  idle,\n  syncing,\n  success,\n  error,\n}\n\nfinal syncStatusProvider = StateNotifierProvider&lt;SyncStatusNotifier, SyncStatus&gt;((ref) {\n  return SyncStatusNotifier();\n});\n\n// UI Widget to show sync status\nclass SyncStatusIndicator extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final syncStatus = ref.watch(syncStatusProvider);\n\n    return AnimatedSwitcher(\n      duration: const Duration(milliseconds: 300),\n      child: _buildStatusWidget(syncStatus),\n    );\n  }\n\n  Widget _buildStatusWidget(SyncStatus status) {\n    switch (status) {\n      case SyncStatus.syncing:\n        return const CircularProgressIndicator();\n      case SyncStatus.success:\n        return const Icon(Icons.check_circle, color: Colors.green);\n      case SyncStatus.error:\n        return const Icon(Icons.error, color: Colors.red);\n      case SyncStatus.idle:\n        return const SizedBox.shrink();\n    }\n  }\n}\n</code></pre>"},{"location":"data/state-sync/#testing-state-synchronization","title":"Testing State Synchronization","text":""},{"location":"data/state-sync/#1-sync-testing","title":"1. Sync Testing","text":"<pre><code>// test/sync/state_sync_test.dart\nvoid main() {\n  group('State Synchronization Tests', () {\n    testWidgets('should sync user state across providers', (tester) async {\n      final container = ProviderContainer();\n\n      // Update user\n      final user = User(id: '1', name: 'John', email: 'john@example.com');\n      container.read(userProvider.notifier).updateUser(user);\n\n      // Verify dependent providers are updated\n      await tester.pump();\n\n      final posts = container.read(userPostsProvider('1'));\n      expect(posts, isA&lt;AsyncValue&lt;List&lt;Post&gt;&gt;&gt;());\n    });\n\n    test('should handle optimistic updates correctly', () async {\n      final notifier = OptimisticPostsNotifier(MockPostRepository(), MockRef());\n\n      // Perform optimistic update\n      await notifier.createPost(CreatePostRequest(content: 'Test post'));\n\n      // Verify optimistic state\n      final posts = notifier.state.valueOrNull;\n      expect(posts?.first.content, 'Test post');\n      expect(posts?.first.isOptimistic, true);\n    });\n  });\n}\n</code></pre> <p>State synchronization is critical for maintaining data consistency. Design your sync strategy early and test thoroughly to ensure reliable user experiences.</p>"},{"location":"data/supabase-integration/","title":"Supabase Integration","text":"<p>Comprehensive guide to integrating Supabase as the backend service for Flutter applications, covering authentication, database operations, real-time features, and storage.</p>"},{"location":"data/supabase-integration/#overview","title":"Overview","text":"<p>Supabase is an open-source Firebase alternative that provides a complete backend solution with PostgreSQL database, authentication, real-time subscriptions, and storage. This guide covers full integration with Flutter.</p>"},{"location":"data/supabase-integration/#setup-and-configuration","title":"Setup and Configuration","text":""},{"location":"data/supabase-integration/#1-project-setup","title":"1. Project Setup","text":"<pre><code># pubspec.yaml\ndependencies:\n  supabase_flutter: ^2.3.4\n  supabase: ^2.2.2\n\ndev_dependencies:\n  supabase_test_helpers: ^0.4.0\n</code></pre> <pre><code>// lib/config/supabase_config.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass SupabaseConfig {\n  static const String supabaseUrl = String.fromEnvironment(\n    'SUPABASE_URL',\n    defaultValue: 'https://your-project.supabase.co',\n  );\n\n  static const String supabaseAnonKey = String.fromEnvironment(\n    'SUPABASE_ANON_KEY',\n    defaultValue: 'your-anon-key',\n  );\n\n  static const String supabaseServiceKey = String.fromEnvironment(\n    'SUPABASE_SERVICE_KEY',\n    defaultValue: 'your-service-key',\n  );\n\n  // Initialize Supabase\n  static Future&lt;void&gt; initialize() async {\n    await Supabase.initialize(\n      url: supabaseUrl,\n      anonKey: supabaseAnonKey,\n      debug: kDebugMode,\n    );\n  }\n\n  // Get Supabase client\n  static SupabaseClient get client =&gt; Supabase.instance.client;\n\n  // Get current user\n  static User? get currentUser =&gt; client.auth.currentUser;\n\n  // Check if user is authenticated\n  static bool get isAuthenticated =&gt; currentUser != null;\n}\n</code></pre>"},{"location":"data/supabase-integration/#2-environment-configuration","title":"2. Environment Configuration","text":"<pre><code># .env\nSUPABASE_URL=https://your-project.supabase.co\nSUPABASE_ANON_KEY=your-anon-key\nSUPABASE_SERVICE_KEY=your-service-key\n</code></pre> <pre><code>// lib/main.dart\nFuture&lt;void&gt; main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Supabase\n  await SupabaseConfig.initialize();\n\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"data/supabase-integration/#authentication-service","title":"Authentication Service","text":""},{"location":"data/supabase-integration/#1-authentication-manager","title":"1. Authentication Manager","text":"<pre><code>// lib/services/supabase_auth_service.dart\nclass SupabaseAuthService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n\n  // Sign up with email and password\n  static Future&lt;AuthResponse&gt; signUp({\n    required String email,\n    required String password,\n    Map&lt;String, dynamic&gt;? metadata,\n  }) async {\n    try {\n      final response = await _client.auth.signUp(\n        email: email,\n        password: password,\n        data: metadata,\n      );\n\n      if (response.user != null) {\n        await _createUserProfile(response.user!, metadata);\n      }\n\n      return response;\n    } catch (e) {\n      throw AuthException('Sign up failed: $e');\n    }\n  }\n\n  // Sign in with email and password\n  static Future&lt;AuthResponse&gt; signIn({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      return await _client.auth.signInWithPassword(\n        email: email,\n        password: password,\n      );\n    } catch (e) {\n      throw AuthException('Sign in failed: $e');\n    }\n  }\n\n  // Sign in with OAuth provider\n  static Future&lt;bool&gt; signInWithOAuth(OAuthProvider provider) async {\n    try {\n      await _client.auth.signInWithOAuth(\n        provider,\n        redirectTo: 'your-app://auth-callback',\n      );\n      return true;\n    } catch (e) {\n      throw AuthException('OAuth sign in failed: $e');\n    }\n  }\n\n  // Sign out\n  static Future&lt;void&gt; signOut() async {\n    try {\n      await _client.auth.signOut();\n    } catch (e) {\n      throw AuthException('Sign out failed: $e');\n    }\n  }\n\n  // Reset password\n  static Future&lt;void&gt; resetPassword(String email) async {\n    try {\n      await _client.auth.resetPasswordForEmail(\n        email,\n        redirectTo: 'your-app://reset-password',\n      );\n    } catch (e) {\n      throw AuthException('Password reset failed: $e');\n    }\n  }\n\n  // Update password\n  static Future&lt;UserResponse&gt; updatePassword(String newPassword) async {\n    try {\n      return await _client.auth.updateUser(\n        UserAttributes(password: newPassword),\n      );\n    } catch (e) {\n      throw AuthException('Password update failed: $e');\n    }\n  }\n\n  // Get current session\n  static Session? getCurrentSession() {\n    return _client.auth.currentSession;\n  }\n\n  // Listen to auth state changes\n  static Stream&lt;AuthState&gt; get authStateChanges {\n    return _client.auth.onAuthStateChange;\n  }\n\n  // Create user profile after signup\n  static Future&lt;void&gt; _createUserProfile(\n    User user,\n    Map&lt;String, dynamic&gt;? metadata,\n  ) async {\n    try {\n      await _client.from('profiles').insert({\n        'id': user.id,\n        'email': user.email,\n        'username': metadata?['username'] ?? user.email?.split('@').first,\n        'display_name': metadata?['display_name'] ?? '',\n        'bio': metadata?['bio'] ?? '',\n        'avatar_url': user.userMetadata?['avatar_url'],\n        'created_at': DateTime.now().toIso8601String(),\n        'updated_at': DateTime.now().toIso8601String(),\n      });\n    } catch (e) {\n      print('Failed to create user profile: $e');\n    }\n  }\n}\n\nclass AuthException implements Exception {\n  final String message;\n  AuthException(this.message);\n\n  @override\n  String toString() =&gt; 'AuthException: $message';\n}\n</code></pre>"},{"location":"data/supabase-integration/#2-user-profile-service","title":"2. User Profile Service","text":"<pre><code>// lib/services/user_profile_service.dart\nclass UserProfileService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n\n  // Get user profile\n  static Future&lt;Map&lt;String, dynamic&gt;?&gt; getUserProfile(String userId) async {\n    try {\n      final response = await _client\n          .from('profiles')\n          .select()\n          .eq('id', userId)\n          .single();\n\n      return response;\n    } catch (e) {\n      print('Failed to get user profile: $e');\n      return null;\n    }\n  }\n\n  // Update user profile\n  static Future&lt;void&gt; updateUserProfile({\n    required String userId,\n    String? username,\n    String? displayName,\n    String? bio,\n    String? avatarUrl,\n  }) async {\n    try {\n      final updates = &lt;String, dynamic&gt;{\n        'updated_at': DateTime.now().toIso8601String(),\n      };\n\n      if (username != null) updates['username'] = username;\n      if (displayName != null) updates['display_name'] = displayName;\n      if (bio != null) updates['bio'] = bio;\n      if (avatarUrl != null) updates['avatar_url'] = avatarUrl;\n\n      await _client\n          .from('profiles')\n          .update(updates)\n          .eq('id', userId);\n    } catch (e) {\n      throw Exception('Failed to update profile: $e');\n    }\n  }\n\n  // Search users\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; searchUsers(String query) async {\n    try {\n      final response = await _client\n          .from('profiles')\n          .select('id, username, display_name, avatar_url')\n          .or('username.ilike.%$query%,display_name.ilike.%$query%')\n          .limit(20);\n\n      return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n    } catch (e) {\n      print('Failed to search users: $e');\n      return [];\n    }\n  }\n\n  // Follow user\n  static Future&lt;void&gt; followUser(String followerId, String followingId) async {\n    try {\n      await _client.from('follows').insert({\n        'follower_id': followerId,\n        'following_id': followingId,\n        'created_at': DateTime.now().toIso8601String(),\n      });\n\n      // Update follower counts\n      await _updateFollowerCounts(followerId, followingId);\n    } catch (e) {\n      throw Exception('Failed to follow user: $e');\n    }\n  }\n\n  // Unfollow user\n  static Future&lt;void&gt; unfollowUser(String followerId, String followingId) async {\n    try {\n      await _client\n          .from('follows')\n          .delete()\n          .eq('follower_id', followerId)\n          .eq('following_id', followingId);\n\n      // Update follower counts\n      await _updateFollowerCounts(followerId, followingId);\n    } catch (e) {\n      throw Exception('Failed to unfollow user: $e');\n    }\n  }\n\n  // Check if user is following another user\n  static Future&lt;bool&gt; isFollowing(String followerId, String followingId) async {\n    try {\n      final response = await _client\n          .from('follows')\n          .select('id')\n          .eq('follower_id', followerId)\n          .eq('following_id', followingId)\n          .maybeSingle();\n\n      return response != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Update follower counts\n  static Future&lt;void&gt; _updateFollowerCounts(String followerId, String followingId) async {\n    try {\n      // Update follower count for the followed user\n      final followerCount = await _client\n          .from('follows')\n          .select('id', const FetchOptions(count: CountOption.exact))\n          .eq('following_id', followingId);\n\n      await _client\n          .from('profiles')\n          .update({'follower_count': followerCount.count})\n          .eq('id', followingId);\n\n      // Update following count for the follower\n      final followingCount = await _client\n          .from('follows')\n          .select('id', const FetchOptions(count: CountOption.exact))\n          .eq('follower_id', followerId);\n\n      await _client\n          .from('profiles')\n          .update({'following_count': followingCount.count})\n          .eq('id', followerId);\n    } catch (e) {\n      print('Failed to update follower counts: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"data/supabase-integration/#database-operations","title":"Database Operations","text":""},{"location":"data/supabase-integration/#1-posts-service","title":"1. Posts Service","text":"<pre><code>// lib/services/posts_service.dart\nclass PostsService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n\n  // Create a new post\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; createPost({\n    required String userId,\n    required String imageUrl,\n    String? caption,\n    List&lt;String&gt;? tags,\n    Map&lt;String, dynamic&gt;? location,\n  }) async {\n    try {\n      final response = await _client.from('posts').insert({\n        'user_id': userId,\n        'image_url': imageUrl,\n        'caption': caption ?? '',\n        'tags': tags ?? [],\n        'location': location,\n        'created_at': DateTime.now().toIso8601String(),\n        'updated_at': DateTime.now().toIso8601String(),\n      }).select().single();\n\n      return response;\n    } catch (e) {\n      throw Exception('Failed to create post: $e');\n    }\n  }\n\n  // Get posts feed\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getPostsFeed({\n    String? userId,\n    int limit = 20,\n    int offset = 0,\n  }) async {\n    try {\n      var query = _client\n          .from('posts')\n          .select('''\n            *,\n            profiles:user_id (\n              id,\n              username,\n              display_name,\n              avatar_url\n            ),\n            likes:post_likes (count),\n            comments:post_comments (count)\n          ''')\n          .order('created_at', ascending: false)\n          .range(offset, offset + limit - 1);\n\n      if (userId != null) {\n        query = query.eq('user_id', userId);\n      }\n\n      final response = await query;\n      return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n    } catch (e) {\n      print('Failed to get posts feed: $e');\n      return [];\n    }\n  }\n\n  // Get single post\n  static Future&lt;Map&lt;String, dynamic&gt;?&gt; getPost(String postId) async {\n    try {\n      final response = await _client\n          .from('posts')\n          .select('''\n            *,\n            profiles:user_id (\n              id,\n              username,\n              display_name,\n              avatar_url\n            ),\n            likes:post_likes (count),\n            comments:post_comments (count)\n          ''')\n          .eq('id', postId)\n          .single();\n\n      return response;\n    } catch (e) {\n      print('Failed to get post: $e');\n      return null;\n    }\n  }\n\n  // Update post\n  static Future&lt;void&gt; updatePost({\n    required String postId,\n    String? caption,\n    List&lt;String&gt;? tags,\n  }) async {\n    try {\n      final updates = &lt;String, dynamic&gt;{\n        'updated_at': DateTime.now().toIso8601String(),\n      };\n\n      if (caption != null) updates['caption'] = caption;\n      if (tags != null) updates['tags'] = tags;\n\n      await _client\n          .from('posts')\n          .update(updates)\n          .eq('id', postId);\n    } catch (e) {\n      throw Exception('Failed to update post: $e');\n    }\n  }\n\n  // Delete post\n  static Future&lt;void&gt; deletePost(String postId) async {\n    try {\n      await _client\n          .from('posts')\n          .delete()\n          .eq('id', postId);\n    } catch (e) {\n      throw Exception('Failed to delete post: $e');\n    }\n  }\n\n  // Like post\n  static Future&lt;void&gt; likePost(String postId, String userId) async {\n    try {\n      await _client.from('post_likes').insert({\n        'post_id': postId,\n        'user_id': userId,\n        'created_at': DateTime.now().toIso8601String(),\n      });\n\n      // Update like count\n      await _updateLikeCount(postId);\n    } catch (e) {\n      throw Exception('Failed to like post: $e');\n    }\n  }\n\n  // Unlike post\n  static Future&lt;void&gt; unlikePost(String postId, String userId) async {\n    try {\n      await _client\n          .from('post_likes')\n          .delete()\n          .eq('post_id', postId)\n          .eq('user_id', userId);\n\n      // Update like count\n      await _updateLikeCount(postId);\n    } catch (e) {\n      throw Exception('Failed to unlike post: $e');\n    }\n  }\n\n  // Check if user liked post\n  static Future&lt;bool&gt; isPostLiked(String postId, String userId) async {\n    try {\n      final response = await _client\n          .from('post_likes')\n          .select('id')\n          .eq('post_id', postId)\n          .eq('user_id', userId)\n          .maybeSingle();\n\n      return response != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Update like count\n  static Future&lt;void&gt; _updateLikeCount(String postId) async {\n    try {\n      final likeCount = await _client\n          .from('post_likes')\n          .select('id', const FetchOptions(count: CountOption.exact))\n          .eq('post_id', postId);\n\n      await _client\n          .from('posts')\n          .update({'like_count': likeCount.count})\n          .eq('id', postId);\n    } catch (e) {\n      print('Failed to update like count: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"data/supabase-integration/#2-comments-service","title":"2. Comments Service","text":"<pre><code>// lib/services/comments_service.dart\nclass CommentsService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n\n  // Add comment to post\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; addComment({\n    required String postId,\n    required String userId,\n    required String content,\n    String? parentCommentId,\n  }) async {\n    try {\n      final response = await _client.from('post_comments').insert({\n        'post_id': postId,\n        'user_id': userId,\n        'content': content,\n        'parent_comment_id': parentCommentId,\n        'created_at': DateTime.now().toIso8601String(),\n      }).select('''\n        *,\n        profiles:user_id (\n          id,\n          username,\n          display_name,\n          avatar_url\n        )\n      ''').single();\n\n      // Update comment count\n      await _updateCommentCount(postId);\n\n      return response;\n    } catch (e) {\n      throw Exception('Failed to add comment: $e');\n    }\n  }\n\n  // Get comments for post\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getComments({\n    required String postId,\n    int limit = 50,\n    int offset = 0,\n  }) async {\n    try {\n      final response = await _client\n          .from('post_comments')\n          .select('''\n            *,\n            profiles:user_id (\n              id,\n              username,\n              display_name,\n              avatar_url\n            ),\n            replies:post_comments!parent_comment_id (\n              *,\n              profiles:user_id (\n                id,\n                username,\n                display_name,\n                avatar_url\n              )\n            )\n          ''')\n          .eq('post_id', postId)\n          .is_('parent_comment_id', null)\n          .order('created_at', ascending: true)\n          .range(offset, offset + limit - 1);\n\n      return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n    } catch (e) {\n      print('Failed to get comments: $e');\n      return [];\n    }\n  }\n\n  // Delete comment\n  static Future&lt;void&gt; deleteComment(String commentId, String postId) async {\n    try {\n      await _client\n          .from('post_comments')\n          .delete()\n          .eq('id', commentId);\n\n      // Update comment count\n      await _updateCommentCount(postId);\n    } catch (e) {\n      throw Exception('Failed to delete comment: $e');\n    }\n  }\n\n  // Update comment count\n  static Future&lt;void&gt; _updateCommentCount(String postId) async {\n    try {\n      final commentCount = await _client\n          .from('post_comments')\n          .select('id', const FetchOptions(count: CountOption.exact))\n          .eq('post_id', postId);\n\n      await _client\n          .from('posts')\n          .update({'comment_count': commentCount.count})\n          .eq('id', postId);\n    } catch (e) {\n      print('Failed to update comment count: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"data/supabase-integration/#real-time-features","title":"Real-time Features","text":""},{"location":"data/supabase-integration/#1-real-time-service","title":"1. Real-time Service","text":"<pre><code>// lib/services/realtime_service.dart\nclass RealtimeService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n  static final Map&lt;String, RealtimeChannel&gt; _channels = {};\n\n  // Subscribe to posts changes\n  static RealtimeChannel subscribeToPostsChanges({\n    required Function(Map&lt;String, dynamic&gt;) onInsert,\n    required Function(Map&lt;String, dynamic&gt;) onUpdate,\n    required Function(Map&lt;String, dynamic&gt;) onDelete,\n  }) {\n    const channelName = 'posts_changes';\n\n    final channel = _client.channel(channelName);\n\n    channel\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onInsert(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.update,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onUpdate(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.delete,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onDelete(payload.oldRecord),\n        )\n        .subscribe();\n\n    _channels[channelName] = channel;\n    return channel;\n  }\n\n  // Subscribe to likes changes for a specific post\n  static RealtimeChannel subscribeToPostLikes({\n    required String postId,\n    required Function(Map&lt;String, dynamic&gt;) onLike,\n    required Function(Map&lt;String, dynamic&gt;) onUnlike,\n  }) {\n    final channelName = 'post_likes_$postId';\n\n    final channel = _client.channel(channelName);\n\n    channel\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'post_likes',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onLike(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.delete,\n          schema: 'public',\n          table: 'post_likes',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onUnlike(payload.oldRecord),\n        )\n        .subscribe();\n\n    _channels[channelName] = channel;\n    return channel;\n  }\n\n  // Subscribe to comments changes for a specific post\n  static RealtimeChannel subscribeToPostComments({\n    required String postId,\n    required Function(Map&lt;String, dynamic&gt;) onNewComment,\n    required Function(Map&lt;String, dynamic&gt;) onDeleteComment,\n  }) {\n    final channelName = 'post_comments_$postId';\n\n    final channel = _client.channel(channelName);\n\n    channel\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'post_comments',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onNewComment(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.delete,\n          schema: 'public',\n          table: 'post_comments',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onDeleteComment(payload.oldRecord),\n        )\n        .subscribe();\n\n    _channels[channelName] = channel;\n    return channel;\n  }\n\n  // Subscribe to user presence\n  static RealtimeChannel subscribeToPresence({\n    required String channelName,\n    required Function(String, Map&lt;String, dynamic&gt;) onJoin,\n    required Function(String, Map&lt;String, dynamic&gt;) onLeave,\n  }) {\n    final channel = _client.channel(channelName);\n\n    channel\n        .onPresenceSync((syncs) {\n          for (final sync in syncs) {\n            onJoin(sync.key, sync.currentPresences.first.payload);\n          }\n        })\n        .onPresenceJoin((key, currentPresences, newPresences) {\n          onJoin(key, newPresences.first.payload);\n        })\n        .onPresenceLeave((key, currentPresences, leftPresences) {\n          onLeave(key, leftPresences.first.payload);\n        })\n        .subscribe();\n\n    _channels[channelName] = channel;\n    return channel;\n  }\n\n  // Track user presence\n  static Future&lt;void&gt; trackPresence({\n    required String channelName,\n    required Map&lt;String, dynamic&gt; presenceData,\n  }) async {\n    final channel = _channels[channelName];\n    if (channel != null) {\n      await channel.track(presenceData);\n    }\n  }\n\n  // Unsubscribe from channel\n  static Future&lt;void&gt; unsubscribe(String channelName) async {\n    final channel = _channels.remove(channelName);\n    if (channel != null) {\n      await _client.removeChannel(channel);\n    }\n  }\n\n  // Unsubscribe from all channels\n  static Future&lt;void&gt; unsubscribeAll() async {\n    for (final channel in _channels.values) {\n      await _client.removeChannel(channel);\n    }\n    _channels.clear();\n  }\n}\n</code></pre>"},{"location":"data/supabase-integration/#storage-service","title":"Storage Service","text":""},{"location":"data/supabase-integration/#1-file-upload-service","title":"1. File Upload Service","text":"<pre><code>// lib/services/storage_service.dart\nclass StorageService {\n  static final SupabaseClient _client = SupabaseConfig.client;\n  static const String _avatarsBucket = 'avatars';\n  static const String _postsBucket = 'posts';\n\n  // Upload avatar image\n  static Future&lt;String&gt; uploadAvatar({\n    required String userId,\n    required File imageFile,\n  }) async {\n    try {\n      final fileExt = path.extension(imageFile.path);\n      final fileName = '${userId}_${DateTime.now().millisecondsSinceEpoch}$fileExt';\n\n      await _client.storage\n          .from(_avatarsBucket)\n          .upload(fileName, imageFile);\n\n      final publicUrl = _client.storage\n          .from(_avatarsBucket)\n          .getPublicUrl(fileName);\n\n      return publicUrl;\n    } catch (e) {\n      throw Exception('Failed to upload avatar: $e');\n    }\n  }\n\n  // Upload post image\n  static Future&lt;String&gt; uploadPostImage({\n    required String userId,\n    required File imageFile,\n  }) async {\n    try {\n      final fileExt = path.extension(imageFile.path);\n      final fileName = '${userId}_${DateTime.now().millisecondsSinceEpoch}$fileExt';\n\n      await _client.storage\n          .from(_postsBucket)\n          .upload(fileName, imageFile);\n\n      final publicUrl = _client.storage\n          .from(_postsBucket)\n          .getPublicUrl(fileName);\n\n      return publicUrl;\n    } catch (e) {\n      throw Exception('Failed to upload post image: $e');\n    }\n  }\n\n  // Delete file\n  static Future&lt;void&gt; deleteFile({\n    required String bucket,\n    required String fileName,\n  }) async {\n    try {\n      await _client.storage\n          .from(bucket)\n          .remove([fileName]);\n    } catch (e) {\n      throw Exception('Failed to delete file: $e');\n    }\n  }\n\n  // Get file URL\n  static String getFileUrl({\n    required String bucket,\n    required String fileName,\n  }) {\n    return _client.storage\n        .from(bucket)\n        .getPublicUrl(fileName);\n  }\n\n  // Create signed URL for private files\n  static Future&lt;String&gt; createSignedUrl({\n    required String bucket,\n    required String fileName,\n    int expiresInSeconds = 3600,\n  }) async {\n    try {\n      return await _client.storage\n          .from(bucket)\n          .createSignedUrl(fileName, expiresInSeconds);\n    } catch (e) {\n      throw Exception('Failed to create signed URL: $e');\n    }\n  }\n}\n</code></pre> <p>Supabase provides a comprehensive backend solution for Flutter applications. Implement proper authentication, database operations, real-time features, and storage to build scalable and feature-rich applications.</p>"},{"location":"deployment/app-store/","title":"App Store Deployment","text":"<p>Comprehensive guide to deploying Flutter applications to the Apple App Store, including preparation, submission, and post-launch management.</p>"},{"location":"deployment/app-store/#overview","title":"Overview","text":"<p>App Store deployment involves preparing your iOS app, configuring metadata, submitting for review, and managing releases. This guide covers the complete process from build preparation to app store optimization.</p>"},{"location":"deployment/app-store/#prerequisites","title":"Prerequisites","text":""},{"location":"deployment/app-store/#1-apple-developer-account-setup","title":"1. Apple Developer Account Setup","text":"<pre><code># Required accounts and memberships\n- Apple Developer Program membership ($99/year)\n- App Store Connect access\n- Xcode installed on macOS\n- Valid certificates and provisioning profiles\n</code></pre>"},{"location":"deployment/app-store/#2-app-store-connect-configuration","title":"2. App Store Connect Configuration","text":"<pre><code>// App Store Connect setup checklist\n1. Create App ID in Developer Portal\n2. Generate certificates (Development, Distribution)\n3. Create provisioning profiles\n4. Set up App Store Connect app record\n5. Configure app metadata and descriptions\n6. Prepare app screenshots and assets\n</code></pre>"},{"location":"deployment/app-store/#build-preparation","title":"Build Preparation","text":""},{"location":"deployment/app-store/#1-ios-build-configuration","title":"1. iOS Build Configuration","text":"<pre><code># pubspec.yaml - iOS specific configuration\nflutter:\n  assets:\n    - assets/images/\n    - assets/icons/\n\n  # iOS app icons\n  icons:\n    ios: true\n    image_path: \"assets/icons/app_icon.png\"\n    adaptive_icon_background: \"#ffffff\"\n    adaptive_icon_foreground: \"assets/icons/app_icon_foreground.png\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.6\n</code></pre>"},{"location":"deployment/app-store/#2-ios-infoplist-configuration","title":"2. iOS Info.plist Configuration","text":"<pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;!-- App Information --&gt;\n    &lt;key&gt;CFBundleDisplayName&lt;/key&gt;\n    &lt;string&gt;YourApp&lt;/string&gt;\n    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;\n    &lt;string&gt;com.yourcompany.yourapp&lt;/string&gt;\n    &lt;key&gt;CFBundleName&lt;/key&gt;\n    &lt;string&gt;YourApp&lt;/string&gt;\n    &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;\n    &lt;string&gt;1.0.0&lt;/string&gt;\n    &lt;key&gt;CFBundleVersion&lt;/key&gt;\n    &lt;string&gt;1&lt;/string&gt;\n\n    &lt;!-- Privacy Permissions --&gt;\n    &lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n    &lt;string&gt;This app needs camera access to take photos for posts&lt;/string&gt;\n    &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n    &lt;string&gt;This app needs photo library access to select images&lt;/string&gt;\n    &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;\n    &lt;string&gt;This app needs location access to show nearby content&lt;/string&gt;\n    &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n    &lt;string&gt;This app needs microphone access to record audio&lt;/string&gt;\n\n    &lt;!-- App Transport Security --&gt;\n    &lt;key&gt;NSAppTransportSecurity&lt;/key&gt;\n    &lt;dict&gt;\n        &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;\n        &lt;false/&gt;\n        &lt;key&gt;NSExceptionDomains&lt;/key&gt;\n        &lt;dict&gt;\n            &lt;key&gt;yourapi.com&lt;/key&gt;\n            &lt;dict&gt;\n                &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt;\n                &lt;false/&gt;\n                &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt;\n                &lt;string&gt;TLSv1.2&lt;/string&gt;\n            &lt;/dict&gt;\n        &lt;/dict&gt;\n    &lt;/dict&gt;\n\n    &lt;!-- Supported Interface Orientations --&gt;\n    &lt;key&gt;UISupportedInterfaceOrientations&lt;/key&gt;\n    &lt;array&gt;\n        &lt;key&gt;UIInterfaceOrientationPortrait&lt;/key&gt;\n        &lt;key&gt;UIInterfaceOrientationLandscapeLeft&lt;/key&gt;\n        &lt;key&gt;UIInterfaceOrientationLandscapeRight&lt;/key&gt;\n    &lt;/array&gt;\n\n    &lt;!-- Launch Screen --&gt;\n    &lt;key&gt;UILaunchStoryboardName&lt;/key&gt;\n    &lt;string&gt;LaunchScreen&lt;/string&gt;\n\n    &lt;!-- Status Bar --&gt;\n    &lt;key&gt;UIStatusBarHidden&lt;/key&gt;\n    &lt;false/&gt;\n    &lt;key&gt;UIViewControllerBasedStatusBarAppearance&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre>"},{"location":"deployment/app-store/#3-build-script-for-app-store","title":"3. Build Script for App Store","text":"<pre><code>#!/bin/bash\n# scripts/build-ios-appstore.sh\n\nset -e\n\necho \"Building iOS app for App Store submission...\"\n\n# Clean previous builds\nflutter clean\ncd ios &amp;&amp; rm -rf Pods &amp;&amp; pod install &amp;&amp; cd ..\n\n# Build for release\nflutter build ios --release \\\n  --dart-define=ENVIRONMENT=production \\\n  --dart-define-from-file=.env.production\n\necho \"iOS build completed successfully!\"\n\n# Archive the app (requires Xcode)\necho \"Creating archive...\"\ncd ios\nxcodebuild -workspace Runner.xcworkspace \\\n  -scheme Runner \\\n  -configuration Release \\\n  -destination generic/platform=iOS \\\n  -archivePath build/Runner.xcarchive \\\n  archive\n\n# Export IPA\necho \"Exporting IPA...\"\nxcodebuild -exportArchive \\\n  -archivePath build/Runner.xcarchive \\\n  -exportPath build \\\n  -exportOptionsPlist ExportOptions.plist\n\necho \"IPA export completed!\"\ncd ..\n</code></pre>"},{"location":"deployment/app-store/#4-export-options-configuration","title":"4. Export Options Configuration","text":"<pre><code>&lt;!-- ios/ExportOptions.plist --&gt;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;method&lt;/key&gt;\n    &lt;string&gt;app-store&lt;/string&gt;\n    &lt;key&gt;teamID&lt;/key&gt;\n    &lt;string&gt;YOUR_TEAM_ID&lt;/string&gt;\n    &lt;key&gt;uploadBitcode&lt;/key&gt;\n    &lt;false/&gt;\n    &lt;key&gt;uploadSymbols&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;compileBitcode&lt;/key&gt;\n    &lt;false/&gt;\n    &lt;key&gt;signingStyle&lt;/key&gt;\n    &lt;string&gt;automatic&lt;/string&gt;\n    &lt;key&gt;signingCertificate&lt;/key&gt;\n    &lt;string&gt;Apple Distribution&lt;/string&gt;\n    &lt;key&gt;provisioningProfiles&lt;/key&gt;\n    &lt;dict&gt;\n        &lt;key&gt;com.yourcompany.yourapp&lt;/key&gt;\n        &lt;string&gt;YourApp App Store Profile&lt;/string&gt;\n    &lt;/dict&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre>"},{"location":"deployment/app-store/#fastlane-integration","title":"Fastlane Integration","text":""},{"location":"deployment/app-store/#1-fastlane-setup","title":"1. Fastlane Setup","text":"<pre><code># ios/fastlane/Fastfile\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Build and upload to App Store Connect\"\n  lane :release do\n    # Ensure we're on the right branch\n    ensure_git_branch(branch: 'main')\n    ensure_git_status_clean\n\n    # Increment build number\n    increment_build_number(xcodeproj: \"Runner.xcodeproj\")\n\n    # Setup certificates and provisioning profiles\n    setup_ci if ENV['CI']\n    match(type: \"appstore\", readonly: true)\n\n    # Build the app\n    build_app(\n      workspace: \"Runner.xcworkspace\",\n      scheme: \"Runner\",\n      configuration: \"Release\",\n      export_method: \"app-store\",\n      export_options: {\n        provisioningProfiles: {\n          \"com.yourcompany.yourapp\" =&gt; \"YourApp App Store Profile\"\n        }\n      }\n    )\n\n    # Upload to App Store Connect\n    upload_to_app_store(\n      skip_metadata: false,\n      skip_screenshots: false,\n      submit_for_review: false,\n      automatic_release: false,\n      force: true\n    )\n\n    # Commit version bump\n    commit_version_bump(\n      message: \"Version bump for App Store release\",\n      xcodeproj: \"Runner.xcodeproj\"\n    )\n\n    # Create git tag\n    add_git_tag(\n      tag: get_version_number(xcodeproj: \"Runner.xcodeproj\")\n    )\n\n    # Push changes\n    push_to_git_remote\n  end\n\n  desc \"Upload to TestFlight\"\n  lane :beta do\n    setup_ci if ENV['CI']\n    match(type: \"appstore\", readonly: true)\n\n    increment_build_number(xcodeproj: \"Runner.xcodeproj\")\n\n    build_app(\n      workspace: \"Runner.xcworkspace\",\n      scheme: \"Runner\",\n      configuration: \"Release\",\n      export_method: \"app-store\"\n    )\n\n    upload_to_testflight(\n      skip_waiting_for_build_processing: true,\n      changelog: \"Bug fixes and improvements\"\n    )\n  end\n\n  desc \"Take screenshots\"\n  lane :screenshots do\n    capture_screenshots\n    upload_to_app_store(skip_binary_upload: true, skip_metadata: true)\n  end\nend\n</code></pre>"},{"location":"deployment/app-store/#2-fastlane-metadata","title":"2. Fastlane Metadata","text":"<pre><code># ios/fastlane/metadata/en-US/description.txt\nYourApp is a revolutionary social media platform that connects people through shared interests and experiences.\n\nKey Features:\n\u2022 Share photos and videos with friends\n\u2022 Discover new content based on your interests\n\u2022 Connect with like-minded individuals\n\u2022 Real-time messaging and notifications\n\u2022 Privacy-focused design\n\nJoin millions of users who are already sharing their stories on YourApp!\n</code></pre> <pre><code># ios/fastlane/metadata/en-US/keywords.txt\nsocial media,photo sharing,video sharing,social network,friends,community,messaging,stories\n</code></pre> <pre><code># ios/fastlane/metadata/en-US/marketing_url.txt\nhttps://yourapp.com\n</code></pre> <pre><code># ios/fastlane/metadata/en-US/privacy_url.txt\nhttps://yourapp.com/privacy\n</code></pre> <pre><code># ios/fastlane/metadata/en-US/support_url.txt\nhttps://yourapp.com/support\n</code></pre>"},{"location":"deployment/app-store/#app-store-assets","title":"App Store Assets","text":""},{"location":"deployment/app-store/#1-app-icons","title":"1. App Icons","text":"<pre><code># Required app icon sizes for iOS\nIcon-App-20x20@1x.png (20x20)\nIcon-App-20x20@2x.png (40x40)\nIcon-App-20x20@3x.png (60x60)\nIcon-App-29x29@1x.png (29x29)\nIcon-App-29x29@2x.png (58x58)\nIcon-App-29x29@3x.png (87x87)\nIcon-App-40x40@1x.png (40x40)\nIcon-App-40x40@2x.png (80x80)\nIcon-App-40x40@3x.png (120x120)\nIcon-App-60x60@2x.png (120x120)\nIcon-App-60x60@3x.png (180x180)\nIcon-App-76x76@1x.png (76x76)\nIcon-App-76x76@2x.png (152x152)\nIcon-App-83.5x83.5@2x.png (167x167)\nIcon-App-1024x1024@1x.png (1024x1024)\n</code></pre>"},{"location":"deployment/app-store/#2-screenshots","title":"2. Screenshots","text":"<pre><code># Required screenshot sizes\niPhone 6.7\" Display (1290x2796)\niPhone 6.5\" Display (1242x2688)\niPhone 5.5\" Display (1242x2208)\niPad Pro (6th Gen) 12.9\" Display (2048x2732)\niPad Pro (2nd Gen) 12.9\" Display (2048x2732)\n</code></pre>"},{"location":"deployment/app-store/#3-screenshot-generation-script","title":"3. Screenshot Generation Script","text":"<pre><code>// test/screenshots/screenshot_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:yourapp/main.dart' as app;\n\nvoid main() {\n  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('App Screenshots', () {\n    testWidgets('Home Screen', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to home screen\n      await tester.tap(find.byIcon(Icons.home));\n      await tester.pumpAndSettle();\n\n      // Take screenshot\n      await binding.convertFlutterSurfaceToImage();\n      await tester.pumpAndSettle();\n    });\n\n    testWidgets('Profile Screen', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to profile\n      await tester.tap(find.byIcon(Icons.person));\n      await tester.pumpAndSettle();\n\n      // Take screenshot\n      await binding.convertFlutterSurfaceToImage();\n      await tester.pumpAndSettle();\n    });\n  });\n}\n</code></pre>"},{"location":"deployment/app-store/#app-store-review-guidelines","title":"App Store Review Guidelines","text":""},{"location":"deployment/app-store/#1-pre-submission-checklist","title":"1. Pre-Submission Checklist","text":"<pre><code>## Technical Requirements\n- [ ] App builds and runs without crashes\n- [ ] All features work as described\n- [ ] App follows iOS Human Interface Guidelines\n- [ ] Proper error handling implemented\n- [ ] Network connectivity handled gracefully\n- [ ] App works on all supported devices and iOS versions\n\n## Content Requirements\n- [ ] App metadata is accurate and complete\n- [ ] Screenshots represent actual app functionality\n- [ ] App description matches app functionality\n- [ ] No misleading or false information\n- [ ] Appropriate age rating selected\n\n## Privacy Requirements\n- [ ] Privacy policy URL provided\n- [ ] Data collection practices disclosed\n- [ ] User consent obtained for data collection\n- [ ] Sensitive permissions properly justified\n- [ ] COPPA compliance if targeting children\n\n## Legal Requirements\n- [ ] App complies with local laws\n- [ ] Intellectual property rights respected\n- [ ] Terms of service provided if applicable\n- [ ] Content moderation implemented if needed\n</code></pre>"},{"location":"deployment/app-store/#2-common-rejection-reasons","title":"2. Common Rejection Reasons","text":"<pre><code>## App Functionality\n- App crashes or has significant bugs\n- Features don't work as described\n- App is incomplete or placeholder content\n- Poor user experience or confusing navigation\n\n## Metadata Issues\n- Screenshots don't match app functionality\n- App description is misleading\n- Keywords are irrelevant or spam\n- Inappropriate content rating\n\n## Privacy Violations\n- Missing privacy policy\n- Collecting data without disclosure\n- Accessing sensitive data without permission\n- Not handling user data securely\n\n## Design Issues\n- Poor user interface design\n- Not following iOS design guidelines\n- Inconsistent user experience\n- Accessibility issues\n</code></pre>"},{"location":"deployment/app-store/#post-launch-management","title":"Post-Launch Management","text":""},{"location":"deployment/app-store/#1-app-store-optimization-aso","title":"1. App Store Optimization (ASO)","text":"<pre><code>// lib/services/aso_service.dart\nclass ASOService {\n  // Track app store metrics\n  static void trackAppStoreMetrics() {\n    // Track downloads, ratings, reviews\n    AnalyticsService.track('app_store_metrics', {\n      'downloads': getDownloadCount(),\n      'rating': getCurrentRating(),\n      'reviews': getReviewCount(),\n    });\n  }\n\n  // Monitor keyword rankings\n  static Future&lt;Map&lt;String, int&gt;&gt; getKeywordRankings() async {\n    // Implementation to track keyword rankings\n    return {\n      'social media': 45,\n      'photo sharing': 23,\n      'social network': 67,\n    };\n  }\n\n  // A/B test app store assets\n  static void trackAssetPerformance(String assetType, String variant) {\n    AnalyticsService.track('asset_performance', {\n      'asset_type': assetType,\n      'variant': variant,\n      'conversion_rate': getConversionRate(),\n    });\n  }\n}\n</code></pre>"},{"location":"deployment/app-store/#2-update-management","title":"2. Update Management","text":"<pre><code>#!/bin/bash\n# scripts/app-store-update.sh\n\nset -e\n\nVERSION_TYPE=${1:-patch}\nRELEASE_NOTES=${2:-\"Bug fixes and improvements\"}\n\necho \"Preparing App Store update...\"\n\n# Update version\n./scripts/version.sh $VERSION_TYPE\n\n# Build for App Store\n./scripts/build-ios-appstore.sh\n\n# Upload to App Store Connect\ncd ios\nfastlane release\n\necho \"App Store update submitted successfully!\"\n</code></pre>"},{"location":"deployment/app-store/#3-review-response-management","title":"3. Review Response Management","text":"<pre><code>## Review Response Templates\n\n### Positive Review Response\nThank you for the 5-star review! We're thrilled that you're enjoying YourApp. \nYour feedback motivates us to keep improving. If you have any suggestions, \nplease don't hesitate to reach out to our support team.\n\n### Negative Review Response\nThank you for your feedback. We're sorry to hear about your experience. \nWe take all feedback seriously and would love to help resolve any issues. \nPlease contact our support team at support@yourapp.com so we can assist you directly.\n\n### Bug Report Response\nThank you for reporting this issue. We've identified the problem and are \nworking on a fix that will be included in our next update. We appreciate \nyour patience and will notify you once the update is available.\n</code></pre>"},{"location":"deployment/app-store/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"deployment/app-store/#1-app-store-connect-analytics","title":"1. App Store Connect Analytics","text":"<pre><code>// lib/services/app_store_analytics.dart\nclass AppStoreAnalytics {\n  // Track app store conversion funnel\n  static void trackConversionFunnel() {\n    final metrics = {\n      'impressions': getImpressions(),\n      'product_page_views': getProductPageViews(),\n      'downloads': getDownloads(),\n      'conversion_rate': getConversionRate(),\n    };\n\n    AnalyticsService.track('app_store_funnel', metrics);\n  }\n\n  // Monitor app store search performance\n  static void trackSearchPerformance() {\n    final searchMetrics = {\n      'search_impressions': getSearchImpressions(),\n      'search_downloads': getSearchDownloads(),\n      'top_keywords': getTopKeywords(),\n    };\n\n    AnalyticsService.track('app_store_search', searchMetrics);\n  }\n}\n</code></pre>"},{"location":"deployment/app-store/#2-crash-reporting-integration","title":"2. Crash Reporting Integration","text":"<pre><code>// lib/services/crash_reporting.dart\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nclass CrashReporting {\n  static Future&lt;void&gt; initialize() async {\n    // Enable crash reporting for release builds\n    if (!kDebugMode) {\n      FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError;\n\n      PlatformDispatcher.instance.onError = (error, stack) {\n        FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n        return true;\n      };\n    }\n  }\n\n  static void recordError(dynamic error, StackTrace? stackTrace) {\n    if (!kDebugMode) {\n      FirebaseCrashlytics.instance.recordError(error, stackTrace);\n    }\n  }\n\n  static void setUserIdentifier(String userId) {\n    if (!kDebugMode) {\n      FirebaseCrashlytics.instance.setUserIdentifier(userId);\n    }\n  }\n}\n</code></pre> <p>App Store deployment requires careful preparation, adherence to guidelines, and ongoing optimization. Focus on quality, user experience, and compliance to ensure successful app store approval and long-term success.</p>"},{"location":"deployment/build-config/","title":"Build Configuration","text":"<p>Comprehensive guide to configuring Flutter builds for different environments, platforms, and deployment scenarios.</p>"},{"location":"deployment/build-config/#overview","title":"Overview","text":"<p>Build configuration involves setting up different build variants, managing environment variables, configuring signing, and optimizing builds for production. This guide covers all aspects of Flutter build configuration.</p>"},{"location":"deployment/build-config/#build-variants-flavors","title":"Build Variants &amp; Flavors","text":""},{"location":"deployment/build-config/#1-android-build-flavors","title":"1. Android Build Flavors","text":"<pre><code>// android/app/build.gradle\nandroid {\n    compileSdkVersion 34\n\n    defaultConfig {\n        applicationId \"com.yourapp.flutter\"\n        minSdkVersion 21\n        targetSdkVersion 34\n        versionCode flutterVersionCode.toInteger()\n        versionName flutterVersionName\n    }\n\n    flavorDimensions \"environment\"\n\n    productFlavors {\n        development {\n            dimension \"environment\"\n            applicationIdSuffix \".dev\"\n            versionNameSuffix \"-dev\"\n            resValue \"string\", \"app_name\", \"YourApp Dev\"\n            buildConfigField \"String\", \"API_BASE_URL\", '\"https://dev-api.yourapp.com\"'\n            buildConfigField \"String\", \"SUPABASE_URL\", '\"https://dev-project.supabase.co\"'\n            buildConfigField \"boolean\", \"ENABLE_LOGGING\", \"true\"\n        }\n\n        staging {\n            dimension \"environment\"\n            applicationIdSuffix \".staging\"\n            versionNameSuffix \"-staging\"\n            resValue \"string\", \"app_name\", \"YourApp Staging\"\n            buildConfigField \"String\", \"API_BASE_URL\", '\"https://staging-api.yourapp.com\"'\n            buildConfigField \"String\", \"SUPABASE_URL\", '\"https://staging-project.supabase.co\"'\n            buildConfigField \"boolean\", \"ENABLE_LOGGING\", \"true\"\n        }\n\n        production {\n            dimension \"environment\"\n            resValue \"string\", \"app_name\", \"YourApp\"\n            buildConfigField \"String\", \"API_BASE_URL\", '\"https://api.yourapp.com\"'\n            buildConfigField \"String\", \"SUPABASE_URL\", '\"https://prod-project.supabase.co\"'\n            buildConfigField \"boolean\", \"ENABLE_LOGGING\", \"false\"\n        }\n    }\n\n    buildTypes {\n        debug {\n            debuggable true\n            minifyEnabled false\n            shrinkResources false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n\n        release {\n            debuggable false\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n\n            signingConfig signingConfigs.release\n        }\n    }\n\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n}\n</code></pre>"},{"location":"deployment/build-config/#2-ios-build-configurations","title":"2. iOS Build Configurations","text":"<pre><code># ios/Flutter/Release.xcconfig\n#include \"Generated.xcconfig\"\n\n// Environment-specific configurations\nAPI_BASE_URL=https://api.yourapp.com\nSUPABASE_URL=https://prod-project.supabase.co\nENABLE_LOGGING=NO\n\n// App configuration\nPRODUCT_BUNDLE_IDENTIFIER=com.yourapp.flutter\nPRODUCT_NAME=YourApp\n</code></pre> <pre><code># ios/Flutter/Debug.xcconfig\n#include \"Generated.xcconfig\"\n\n// Environment-specific configurations\nAPI_BASE_URL=https://dev-api.yourapp.com\nSUPABASE_URL=https://dev-project.supabase.co\nENABLE_LOGGING=YES\n\n// App configuration\nPRODUCT_BUNDLE_IDENTIFIER=com.yourapp.flutter.dev\nPRODUCT_NAME=YourApp Dev\n</code></pre>"},{"location":"deployment/build-config/#3-flutter-build-configuration","title":"3. Flutter Build Configuration","text":"<pre><code>// lib/config/build_config.dart\nclass BuildConfig {\n  static const String environment = String.fromEnvironment(\n    'ENVIRONMENT',\n    defaultValue: 'development',\n  );\n\n  static const String apiBaseUrl = String.fromEnvironment(\n    'API_BASE_URL',\n    defaultValue: 'https://dev-api.yourapp.com',\n  );\n\n  static const String supabaseUrl = String.fromEnvironment(\n    'SUPABASE_URL',\n    defaultValue: 'https://dev-project.supabase.co',\n  );\n\n  static const String supabaseAnonKey = String.fromEnvironment(\n    'SUPABASE_ANON_KEY',\n    defaultValue: '',\n  );\n\n  static const bool enableLogging = bool.fromEnvironment(\n    'ENABLE_LOGGING',\n    defaultValue: true,\n  );\n\n  static const bool enableAnalytics = bool.fromEnvironment(\n    'ENABLE_ANALYTICS',\n    defaultValue: false,\n  );\n\n  static const String appName = String.fromEnvironment(\n    'APP_NAME',\n    defaultValue: 'YourApp',\n  );\n\n  static const String buildNumber = String.fromEnvironment(\n    'BUILD_NUMBER',\n    defaultValue: '1',\n  );\n\n  static const String versionName = String.fromEnvironment(\n    'VERSION_NAME',\n    defaultValue: '1.0.0',\n  );\n\n  // Computed properties\n  static bool get isProduction =&gt; environment == 'production';\n  static bool get isDevelopment =&gt; environment == 'development';\n  static bool get isStaging =&gt; environment == 'staging';\n  static bool get isDebug =&gt; !isProduction;\n}\n</code></pre>"},{"location":"deployment/build-config/#environment-variables","title":"Environment Variables","text":""},{"location":"deployment/build-config/#1-environment-file-management","title":"1. Environment File Management","text":"<pre><code># .env.development\nENVIRONMENT=development\nAPI_BASE_URL=https://dev-api.yourapp.com\nSUPABASE_URL=https://dev-project.supabase.co\nSUPABASE_ANON_KEY=your_dev_anon_key\nENABLE_LOGGING=true\nENABLE_ANALYTICS=false\nAPP_NAME=YourApp Dev\n</code></pre> <pre><code># .env.staging\nENVIRONMENT=staging\nAPI_BASE_URL=https://staging-api.yourapp.com\nSUPABASE_URL=https://staging-project.supabase.co\nSUPABASE_ANON_KEY=your_staging_anon_key\nENABLE_LOGGING=true\nENABLE_ANALYTICS=true\nAPP_NAME=YourApp Staging\n</code></pre> <pre><code># .env.production\nENVIRONMENT=production\nAPI_BASE_URL=https://api.yourapp.com\nSUPABASE_URL=https://prod-project.supabase.co\nSUPABASE_ANON_KEY=your_prod_anon_key\nENABLE_LOGGING=false\nENABLE_ANALYTICS=true\nAPP_NAME=YourApp\n</code></pre>"},{"location":"deployment/build-config/#2-environment-loader","title":"2. Environment Loader","text":"<pre><code>// lib/config/environment_loader.dart\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nclass EnvironmentLoader {\n  static Future&lt;void&gt; load() async {\n    const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');\n\n    try {\n      await dotenv.load(fileName: '.env.$environment');\n    } catch (e) {\n      // Fallback to default environment file\n      await dotenv.load(fileName: '.env.development');\n    }\n  }\n\n  static String get(String key, {String defaultValue = ''}) {\n    return dotenv.env[key] ?? \n           const String.fromEnvironment(key, defaultValue: '') ??\n           defaultValue;\n  }\n\n  static bool getBool(String key, {bool defaultValue = false}) {\n    final value = get(key).toLowerCase();\n    return value == 'true' || value == '1';\n  }\n\n  static int getInt(String key, {int defaultValue = 0}) {\n    return int.tryParse(get(key)) ?? defaultValue;\n  }\n}\n</code></pre>"},{"location":"deployment/build-config/#build-scripts","title":"Build Scripts","text":""},{"location":"deployment/build-config/#1-cross-platform-build-script","title":"1. Cross-Platform Build Script","text":"<pre><code>#!/bin/bash\n# scripts/build.sh\n\nset -e\n\n# Default values\nENVIRONMENT=\"development\"\nPLATFORM=\"android\"\nBUILD_TYPE=\"debug\"\nOUTPUT_DIR=\"build/outputs\"\n\n# Parse command line arguments\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    -e|--environment)\n      ENVIRONMENT=\"$2\"\n      shift 2\n      ;;\n    -p|--platform)\n      PLATFORM=\"$2\"\n      shift 2\n      ;;\n    -t|--type)\n      BUILD_TYPE=\"$2\"\n      shift 2\n      ;;\n    -o|--output)\n      OUTPUT_DIR=\"$2\"\n      shift 2\n      ;;\n    -h|--help)\n      echo \"Usage: $0 [OPTIONS]\"\n      echo \"Options:\"\n      echo \"  -e, --environment  Environment (development, staging, production)\"\n      echo \"  -p, --platform     Platform (android, ios, web, linux, macos, windows)\"\n      echo \"  -t, --type         Build type (debug, release)\"\n      echo \"  -o, --output       Output directory\"\n      echo \"  -h, --help         Show this help message\"\n      exit 0\n      ;;\n    *)\n      echo \"Unknown option $1\"\n      exit 1\n      ;;\n  esac\ndone\n\necho \"Building for:\"\necho \"  Environment: $ENVIRONMENT\"\necho \"  Platform: $PLATFORM\"\necho \"  Build Type: $BUILD_TYPE\"\necho \"  Output: $OUTPUT_DIR\"\n\n# Load environment variables\nif [ -f \".env.$ENVIRONMENT\" ]; then\n  export $(cat .env.$ENVIRONMENT | xargs)\nfi\n\n# Create output directory\nmkdir -p \"$OUTPUT_DIR\"\n\n# Build based on platform\ncase $PLATFORM in\n  android)\n    if [ \"$BUILD_TYPE\" = \"release\" ]; then\n      flutter build appbundle --release \\\n        --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n        --dart-define-from-file=.env.$ENVIRONMENT\n\n      flutter build apk --release \\\n        --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n        --dart-define-from-file=.env.$ENVIRONMENT\n\n      # Copy outputs\n      cp build/app/outputs/bundle/release/app-release.aab \"$OUTPUT_DIR/\"\n      cp build/app/outputs/flutter-apk/app-release.apk \"$OUTPUT_DIR/\"\n    else\n      flutter build apk --debug \\\n        --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n        --dart-define-from-file=.env.$ENVIRONMENT\n\n      cp build/app/outputs/flutter-apk/app-debug.apk \"$OUTPUT_DIR/\"\n    fi\n    ;;\n\n  ios)\n    cd ios &amp;&amp; pod install &amp;&amp; cd ..\n\n    if [ \"$BUILD_TYPE\" = \"release\" ]; then\n      flutter build ios --release \\\n        --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n        --dart-define-from-file=.env.$ENVIRONMENT\n    else\n      flutter build ios --debug \\\n        --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n        --dart-define-from-file=.env.$ENVIRONMENT\n    fi\n    ;;\n\n  web)\n    flutter build web --release \\\n      --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n      --dart-define-from-file=.env.$ENVIRONMENT\n\n    # Copy web build\n    cp -r build/web \"$OUTPUT_DIR/\"\n    ;;\n\n  linux)\n    flutter build linux --release \\\n      --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n      --dart-define-from-file=.env.$ENVIRONMENT\n\n    # Package Linux app\n    tar -czf \"$OUTPUT_DIR/linux-app.tar.gz\" -C build/linux/x64/release/bundle .\n    ;;\n\n  macos)\n    flutter build macos --release \\\n      --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n      --dart-define-from-file=.env.$ENVIRONMENT\n\n    # Create DMG (requires create-dmg)\n    if command -v create-dmg &amp;&gt; /dev/null; then\n      create-dmg \\\n        --volname \"YourApp\" \\\n        --window-pos 200 120 \\\n        --window-size 600 300 \\\n        --icon-size 100 \\\n        --icon \"YourApp.app\" 175 120 \\\n        --hide-extension \"YourApp.app\" \\\n        --app-drop-link 425 120 \\\n        \"$OUTPUT_DIR/YourApp.dmg\" \\\n        \"build/macos/Build/Products/Release/\"\n    fi\n    ;;\n\n  windows)\n    flutter build windows --release \\\n      --dart-define=ENVIRONMENT=$ENVIRONMENT \\\n      --dart-define-from-file=.env.$ENVIRONMENT\n\n    # Create ZIP archive\n    cd build/windows/runner/Release &amp;&amp; zip -r \"../../../../$OUTPUT_DIR/windows-app.zip\" . &amp;&amp; cd ../../../..\n    ;;\n\n  *)\n    echo \"Unsupported platform: $PLATFORM\"\n    exit 1\n    ;;\nesac\n\necho \"Build completed successfully!\"\necho \"Output directory: $OUTPUT_DIR\"\n</code></pre>"},{"location":"deployment/build-config/#2-version-management-script","title":"2. Version Management Script","text":"<pre><code>#!/bin/bash\n# scripts/version.sh\n\nset -e\n\nVERSION_FILE=\"pubspec.yaml\"\nCURRENT_VERSION=$(grep \"version:\" $VERSION_FILE | sed 's/version: //' | tr -d ' ')\n\ncase $1 in\n  major)\n    NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print ($1+1)\".0.0\"}')\n    ;;\n  minor)\n    NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1\".\".($2+1)\".0\"}')\n    ;;\n  patch)\n    NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1\".\"$2\".\".($3+1)}')\n    ;;\n  *)\n    if [ -n \"$1\" ]; then\n      NEW_VERSION=$1\n    else\n      echo \"Usage: $0 {major|minor|patch|x.y.z}\"\n      echo \"Current version: $CURRENT_VERSION\"\n      exit 1\n    fi\n    ;;\nesac\n\necho \"Updating version from $CURRENT_VERSION to $NEW_VERSION\"\n\n# Update pubspec.yaml\nsed -i.bak \"s/version: $CURRENT_VERSION/version: $NEW_VERSION/\" $VERSION_FILE\nrm $VERSION_FILE.bak\n\n# Update iOS version\nif [ -f \"ios/Runner/Info.plist\" ]; then\n  /usr/libexec/PlistBuddy -c \"Set :CFBundleShortVersionString $NEW_VERSION\" ios/Runner/Info.plist\n  BUILD_NUMBER=$(echo $NEW_VERSION | tr -d '.')\n  /usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $BUILD_NUMBER\" ios/Runner/Info.plist\nfi\n\n# Update Android version\nif [ -f \"android/app/build.gradle\" ]; then\n  VERSION_CODE=$(echo $NEW_VERSION | tr -d '.' | sed 's/^0*//')\n  sed -i.bak \"s/versionCode [0-9]*/versionCode $VERSION_CODE/\" android/app/build.gradle\n  sed -i.bak \"s/versionName \\\".*\\\"/versionName \\\"$NEW_VERSION\\\"/\" android/app/build.gradle\n  rm android/app/build.gradle.bak\nfi\n\necho \"Version updated to $NEW_VERSION\"\n</code></pre>"},{"location":"deployment/build-config/#code-signing","title":"Code Signing","text":""},{"location":"deployment/build-config/#1-android-signing-configuration","title":"1. Android Signing Configuration","text":"<pre><code># android/key.properties\nstorePassword=your_keystore_password\nkeyPassword=your_key_password\nkeyAlias=your_key_alias\nstoreFile=../keystore.jks\n</code></pre> <pre><code>// android/app/build.gradle\ndef keystoreProperties = new Properties()\ndef keystorePropertiesFile = rootProject.file('key.properties')\nif (keystorePropertiesFile.exists()) {\n    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))\n}\n\nandroid {\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n        }\n    }\n}\n</code></pre>"},{"location":"deployment/build-config/#2-ios-signing-configuration","title":"2. iOS Signing Configuration","text":"<pre><code>#!/bin/bash\n# scripts/ios-signing.sh\n\n# Setup code signing for iOS\nsecurity create-keychain -p \"$KEYCHAIN_PASSWORD\" build.keychain\nsecurity default-keychain -s build.keychain\nsecurity unlock-keychain -p \"$KEYCHAIN_PASSWORD\" build.keychain\n\n# Import certificates\nsecurity import \"$CERTIFICATE_PATH\" -k build.keychain -P \"$CERTIFICATE_PASSWORD\" -T /usr/bin/codesign\nsecurity import \"$PROVISIONING_PROFILE_PATH\" -k build.keychain\n\n# Set key partition list\nsecurity set-key-partition-list -S apple-tool:,apple: -s -k \"$KEYCHAIN_PASSWORD\" build.keychain\n</code></pre>"},{"location":"deployment/build-config/#build-optimization","title":"Build Optimization","text":""},{"location":"deployment/build-config/#1-android-optimization","title":"1. Android Optimization","text":"<pre><code>// android/app/build.gradle\nandroid {\n    buildTypes {\n        release {\n            // Enable code shrinking\n            minifyEnabled true\n            shrinkResources true\n\n            // Enable ProGuard\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n\n            // Enable R8 full mode\n            android.enableR8.fullMode = true\n        }\n    }\n\n    // Enable multidex for large apps\n    defaultConfig {\n        multiDexEnabled true\n    }\n\n    // Split APKs by ABI\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'x86', 'x86_64', 'arm64-v8a', 'armeabi-v7a'\n            universalApk false\n        }\n    }\n}\n</code></pre>"},{"location":"deployment/build-config/#2-flutter-build-optimization","title":"2. Flutter Build Optimization","text":"<pre><code># Build with optimizations\nflutter build apk --release \\\n  --obfuscate \\\n  --split-debug-info=build/debug-info \\\n  --tree-shake-icons \\\n  --dart-define=flutter.inspector.structuredErrors=false\n\n# Web optimization\nflutter build web --release \\\n  --web-renderer canvaskit \\\n  --dart-define=flutter.web.canvaskit.url=https://unpkg.com/canvaskit-wasm@0.33.0/bin/ \\\n  --tree-shake-icons\n</code></pre>"},{"location":"deployment/build-config/#3-asset-optimization","title":"3. Asset Optimization","text":"<pre><code># pubspec.yaml\nflutter:\n  assets:\n    - assets/images/\n    - assets/icons/\n\n  # Generate different resolutions\n  generate: true\n\n# Asset optimization script\nfind assets/images -name \"*.png\" -exec pngquant --force --ext .png {} \\;\nfind assets/images -name \"*.jpg\" -exec jpegoptim --max=85 {} \\;\n</code></pre>"},{"location":"deployment/build-config/#build-monitoring","title":"Build Monitoring","text":""},{"location":"deployment/build-config/#1-build-metrics-collection","title":"1. Build Metrics Collection","text":"<pre><code>// lib/utils/build_metrics.dart\nclass BuildMetrics {\n  static void recordBuildInfo() {\n    final buildInfo = {\n      'environment': BuildConfig.environment,\n      'version': BuildConfig.versionName,\n      'buildNumber': BuildConfig.buildNumber,\n      'buildTime': DateTime.now().toIso8601String(),\n      'platform': Platform.operatingSystem,\n      'isDebug': kDebugMode,\n    };\n\n    // Send to analytics\n    if (BuildConfig.enableAnalytics) {\n      AnalyticsService.track('app_build_info', buildInfo);\n    }\n  }\n}\n</code></pre>"},{"location":"deployment/build-config/#2-build-validation","title":"2. Build Validation","text":"<pre><code>#!/bin/bash\n# scripts/validate-build.sh\n\nset -e\n\necho \"Validating build...\"\n\n# Check if required files exist\nif [ ! -f \"build/app/outputs/bundle/release/app-release.aab\" ]; then\n  echo \"Error: AAB file not found\"\n  exit 1\nfi\n\n# Validate APK\nif [ -f \"build/app/outputs/flutter-apk/app-release.apk\" ]; then\n  aapt dump badging build/app/outputs/flutter-apk/app-release.apk | grep \"package:\"\n  echo \"APK validation passed\"\nfi\n\n# Check file sizes\nAAB_SIZE=$(stat -f%z build/app/outputs/bundle/release/app-release.aab 2&gt;/dev/null || stat -c%s build/app/outputs/bundle/release/app-release.aab)\nMAX_SIZE=$((50 * 1024 * 1024)) # 50MB\n\nif [ $AAB_SIZE -gt $MAX_SIZE ]; then\n  echo \"Warning: AAB size ($AAB_SIZE bytes) exceeds recommended limit\"\nfi\n\necho \"Build validation completed\"\n</code></pre> <p>Build configuration is crucial for managing different environments, optimizing performance, and ensuring consistent deployments. Implement proper environment management, signing, and optimization strategies for production-ready builds.</p>"},{"location":"deployment/cicd/","title":"CI/CD Pipeline","text":"<p>Comprehensive guide to setting up Continuous Integration and Continuous Deployment pipelines for Flutter applications.</p>"},{"location":"deployment/cicd/#overview","title":"Overview","text":"<p>CI/CD pipelines automate the build, test, and deployment process, ensuring consistent and reliable releases. This guide covers GitHub Actions, GitLab CI, and other popular CI/CD platforms.</p>"},{"location":"deployment/cicd/#github-actions","title":"GitHub Actions","text":""},{"location":"deployment/cicd/#1-basic-flutter-workflow","title":"1. Basic Flutter Workflow","text":"<pre><code># .github/workflows/flutter.yml\nname: Flutter CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n        channel: 'stable'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Verify formatting\n      run: dart format --output=none --set-exit-if-changed .\n\n    - name: Analyze project source\n      run: flutter analyze\n\n    - name: Run tests\n      run: flutter test --coverage\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: coverage/lcov.info\n\n  build-android:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n        channel: 'stable'\n\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'zulu'\n        java-version: '17'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Decode keystore\n      run: |\n        echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 -d &gt; android/app/keystore.jks\n\n    - name: Create key.properties\n      run: |\n        echo \"storePassword=${{ secrets.KEYSTORE_PASSWORD }}\" &gt; android/key.properties\n        echo \"keyPassword=${{ secrets.KEY_PASSWORD }}\" &gt;&gt; android/key.properties\n        echo \"keyAlias=${{ secrets.KEY_ALIAS }}\" &gt;&gt; android/key.properties\n        echo \"storeFile=keystore.jks\" &gt;&gt; android/key.properties\n\n    - name: Build APK\n      run: flutter build apk --release\n\n    - name: Build App Bundle\n      run: flutter build appbundle --release\n\n    - name: Upload APK\n      uses: actions/upload-artifact@v3\n      with:\n        name: release-apk\n        path: build/app/outputs/flutter-apk/app-release.apk\n\n    - name: Upload App Bundle\n      uses: actions/upload-artifact@v3\n      with:\n        name: release-aab\n        path: build/app/outputs/bundle/release/app-release.aab\n\n  build-ios:\n    needs: test\n    runs-on: macos-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n        channel: 'stable'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Install CocoaPods\n      run: |\n        cd ios\n        pod install\n\n    - name: Build iOS\n      run: |\n        flutter build ios --release --no-codesign\n\n    - name: Upload iOS build\n      uses: actions/upload-artifact@v3\n      with:\n        name: ios-build\n        path: build/ios/iphoneos/Runner.app\n\n  deploy-android:\n    needs: build-android\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Download App Bundle\n      uses: actions/download-artifact@v3\n      with:\n        name: release-aab\n\n    - name: Deploy to Play Store\n      uses: r0adkll/upload-google-play@v1\n      with:\n        serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT }}\n        packageName: com.yourapp.flutter\n        releaseFiles: app-release.aab\n        track: internal\n        status: completed\n</code></pre>"},{"location":"deployment/cicd/#2-advanced-workflow-with-matrix-strategy","title":"2. Advanced Workflow with Matrix Strategy","text":"<pre><code># .github/workflows/flutter-matrix.yml\nname: Flutter Matrix Build\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n        flutter-version: ['3.35.0', '3.34.0']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: ${{ matrix.flutter-version }}\n        channel: 'stable'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Run tests\n      run: flutter test\n\n    - name: Build (Linux)\n      if: matrix.os == 'ubuntu-latest'\n      run: |\n        sudo apt-get update -y\n        sudo apt-get install -y ninja-build libgtk-3-dev\n        flutter config --enable-linux-desktop\n        flutter build linux\n\n    - name: Build (macOS)\n      if: matrix.os == 'macos-latest'\n      run: |\n        flutter config --enable-macos-desktop\n        flutter build macos\n\n    - name: Build (Windows)\n      if: matrix.os == 'windows-latest'\n      run: |\n        flutter config --enable-windows-desktop\n        flutter build windows\n\n  integration-test:\n    runs-on: macos-latest\n    strategy:\n      matrix:\n        device:\n          - \"iPhone 15 Pro (17.0)\"\n          - \"iPad Pro (12.9-inch) (6th generation) (17.0)\"\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n        channel: 'stable'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Start iOS Simulator\n      run: |\n        xcrun simctl boot \"${{ matrix.device }}\" || true\n\n    - name: Run integration tests\n      run: flutter test integration_test/\n</code></pre>"},{"location":"deployment/cicd/#gitlab-ci","title":"GitLab CI","text":""},{"location":"deployment/cicd/#1-gitlab-ci-configuration","title":"1. GitLab CI Configuration","text":"<pre><code># .gitlab-ci.yml\nstages:\n  - test\n  - build\n  - deploy\n\nvariables:\n  FLUTTER_VERSION: \"3.35.0\"\n\nbefore_script:\n  - apt-get update -qq &amp;&amp; apt-get install -y -qq git curl unzip\n  - git clone https://github.com/flutter/flutter.git -b stable --depth 1\n  - export PATH=\"$PATH:`pwd`/flutter/bin\"\n  - flutter doctor -v\n  - flutter pub get\n\ntest:\n  stage: test\n  script:\n    - flutter analyze\n    - flutter test --coverage\n  coverage: '/lines......: \\d+\\.\\d+\\%/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage/cobertura.xml\n\nbuild_android:\n  stage: build\n  script:\n    - echo \"$KEYSTORE_BASE64\" | base64 -d &gt; android/app/keystore.jks\n    - echo \"storePassword=$KEYSTORE_PASSWORD\" &gt; android/key.properties\n    - echo \"keyPassword=$KEY_PASSWORD\" &gt;&gt; android/key.properties\n    - echo \"keyAlias=$KEY_ALIAS\" &gt;&gt; android/key.properties\n    - echo \"storeFile=keystore.jks\" &gt;&gt; android/key.properties\n    - flutter build apk --release\n    - flutter build appbundle --release\n  artifacts:\n    paths:\n      - build/app/outputs/flutter-apk/app-release.apk\n      - build/app/outputs/bundle/release/app-release.aab\n    expire_in: 1 week\n  only:\n    - main\n\nbuild_ios:\n  stage: build\n  tags:\n    - macos\n  script:\n    - cd ios &amp;&amp; pod install\n    - flutter build ios --release --no-codesign\n  artifacts:\n    paths:\n      - build/ios/iphoneos/Runner.app\n    expire_in: 1 week\n  only:\n    - main\n\ndeploy_android:\n  stage: deploy\n  script:\n    - echo \"Deploying to Google Play Store\"\n    # Add your deployment script here\n  dependencies:\n    - build_android\n  only:\n    - main\n  when: manual\n</code></pre>"},{"location":"deployment/cicd/#fastlane-integration","title":"Fastlane Integration","text":""},{"location":"deployment/cicd/#1-android-fastlane","title":"1. Android Fastlane","text":"<pre><code># android/fastlane/Fastfile\ndefault_platform(:android)\n\nplatform :android do\n  desc \"Build and deploy to Google Play Store\"\n  lane :deploy do\n    # Build the app\n    sh(\"cd .. &amp;&amp; flutter build appbundle --release\")\n\n    # Upload to Play Store\n    upload_to_play_store(\n      track: 'internal',\n      aab: '../build/app/outputs/bundle/release/app-release.aab',\n      skip_upload_apk: true,\n      skip_upload_metadata: false,\n      skip_upload_images: false,\n      skip_upload_screenshots: false\n    )\n  end\n\n  desc \"Build and deploy to Firebase App Distribution\"\n  lane :distribute do\n    # Build APK\n    sh(\"cd .. &amp;&amp; flutter build apk --release\")\n\n    # Upload to Firebase App Distribution\n    firebase_app_distribution(\n      app: ENV[\"FIREBASE_APP_ID\"],\n      apk_path: \"../build/app/outputs/flutter-apk/app-release.apk\",\n      groups: \"testers\",\n      release_notes: \"New build from CI/CD pipeline\"\n    )\n  end\n\n  desc \"Run tests\"\n  lane :test do\n    sh(\"cd .. &amp;&amp; flutter test\")\n  end\nend\n</code></pre>"},{"location":"deployment/cicd/#2-ios-fastlane","title":"2. iOS Fastlane","text":"<pre><code># ios/fastlane/Fastfile\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Build and deploy to App Store\"\n  lane :deploy do\n    # Setup certificates and provisioning profiles\n    setup_ci if ENV['CI']\n\n    match(\n      type: \"appstore\",\n      readonly: true\n    )\n\n    # Build the app\n    sh(\"cd .. &amp;&amp; flutter build ios --release\")\n\n    # Build and upload to App Store\n    build_app(\n      workspace: \"Runner.xcworkspace\",\n      scheme: \"Runner\",\n      export_method: \"app-store\",\n      export_options: {\n        provisioningProfiles: {\n          \"com.yourapp.flutter\" =&gt; \"match AppStore com.yourapp.flutter\"\n        }\n      }\n    )\n\n    upload_to_app_store(\n      skip_metadata: false,\n      skip_screenshots: false,\n      submit_for_review: false\n    )\n  end\n\n  desc \"Build and deploy to TestFlight\"\n  lane :beta do\n    setup_ci if ENV['CI']\n\n    match(\n      type: \"appstore\",\n      readonly: true\n    )\n\n    sh(\"cd .. &amp;&amp; flutter build ios --release\")\n\n    build_app(\n      workspace: \"Runner.xcworkspace\",\n      scheme: \"Runner\",\n      export_method: \"app-store\"\n    )\n\n    upload_to_testflight(\n      skip_waiting_for_build_processing: true\n    )\n  end\nend\n</code></pre>"},{"location":"deployment/cicd/#docker-integration","title":"Docker Integration","text":""},{"location":"deployment/cicd/#1-dockerfile-for-flutter","title":"1. Dockerfile for Flutter","text":"<pre><code># Dockerfile\nFROM cirrusci/flutter:stable\n\nWORKDIR /app\n\n# Copy pubspec files\nCOPY pubspec.* ./\n\n# Get dependencies\nRUN flutter pub get\n\n# Copy source code\nCOPY . .\n\n# Build the app\nRUN flutter build web --release\n\n# Use nginx to serve the web app\nFROM nginx:alpine\nCOPY --from=0 /app/build/web /usr/share/nginx/html\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre>"},{"location":"deployment/cicd/#2-docker-compose-for-development","title":"2. Docker Compose for Development","text":"<pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  flutter-app:\n    build: .\n    ports:\n      - \"8080:80\"\n    environment:\n      - NODE_ENV=production\n\n  flutter-dev:\n    image: cirrusci/flutter:stable\n    volumes:\n      - .:/app\n    working_dir: /app\n    ports:\n      - \"3000:3000\"\n    command: flutter run -d web-server --web-port 3000 --web-hostname 0.0.0.0\n</code></pre>"},{"location":"deployment/cicd/#environment-management","title":"Environment Management","text":""},{"location":"deployment/cicd/#1-environment-configuration","title":"1. Environment Configuration","text":"<pre><code>// lib/config/environment.dart\nenum Environment {\n  development,\n  staging,\n  production,\n}\n\nclass EnvironmentConfig {\n  static const Environment _environment = Environment.values.firstWhere(\n    (env) =&gt; env.name == String.fromEnvironment('ENVIRONMENT', defaultValue: 'development'),\n    orElse: () =&gt; Environment.development,\n  );\n\n  static Environment get environment =&gt; _environment;\n\n  static String get apiBaseUrl {\n    switch (_environment) {\n      case Environment.development:\n        return 'https://dev-api.yourapp.com';\n      case Environment.staging:\n        return 'https://staging-api.yourapp.com';\n      case Environment.production:\n        return 'https://api.yourapp.com';\n    }\n  }\n\n  static String get supabaseUrl {\n    switch (_environment) {\n      case Environment.development:\n        return 'https://dev-project.supabase.co';\n      case Environment.staging:\n        return 'https://staging-project.supabase.co';\n      case Environment.production:\n        return 'https://prod-project.supabase.co';\n    }\n  }\n\n  static String get supabaseAnonKey {\n    switch (_environment) {\n      case Environment.development:\n        return const String.fromEnvironment('SUPABASE_ANON_KEY_DEV');\n      case Environment.staging:\n        return const String.fromEnvironment('SUPABASE_ANON_KEY_STAGING');\n      case Environment.production:\n        return const String.fromEnvironment('SUPABASE_ANON_KEY_PROD');\n    }\n  }\n\n  static bool get isProduction =&gt; _environment == Environment.production;\n  static bool get isDevelopment =&gt; _environment == Environment.development;\n  static bool get isStaging =&gt; _environment == Environment.staging;\n}\n</code></pre>"},{"location":"deployment/cicd/#2-build-scripts","title":"2. Build Scripts","text":"<pre><code>#!/bin/bash\n# scripts/build.sh\n\nset -e\n\nENVIRONMENT=${1:-development}\nPLATFORM=${2:-android}\n\necho \"Building for environment: $ENVIRONMENT, platform: $PLATFORM\"\n\n# Set environment variables\nexport ENVIRONMENT=$ENVIRONMENT\n\ncase $PLATFORM in\n  android)\n    if [ \"$ENVIRONMENT\" = \"production\" ]; then\n      flutter build appbundle --release --dart-define=ENVIRONMENT=$ENVIRONMENT\n    else\n      flutter build apk --debug --dart-define=ENVIRONMENT=$ENVIRONMENT\n    fi\n    ;;\n  ios)\n    if [ \"$ENVIRONMENT\" = \"production\" ]; then\n      flutter build ios --release --dart-define=ENVIRONMENT=$ENVIRONMENT\n    else\n      flutter build ios --debug --dart-define=ENVIRONMENT=$ENVIRONMENT\n    fi\n    ;;\n  web)\n    flutter build web --release --dart-define=ENVIRONMENT=$ENVIRONMENT\n    ;;\n  *)\n    echo \"Unknown platform: $PLATFORM\"\n    exit 1\n    ;;\nesac\n\necho \"Build completed successfully!\"\n</code></pre>"},{"location":"deployment/cicd/#automated-testing-in-cicd","title":"Automated Testing in CI/CD","text":""},{"location":"deployment/cicd/#1-test-configuration","title":"1. Test Configuration","text":"<pre><code># .github/workflows/test.yml\nname: Automated Testing\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Run unit tests\n      run: flutter test --coverage\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: coverage/lcov.info\n\n  widget-tests:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Run widget tests\n      run: flutter test test/widget_test/\n\n    - name: Generate golden files\n      run: flutter test --update-goldens test/golden_test/\n\n  integration-tests:\n    runs-on: macos-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Start iOS Simulator\n      run: |\n        xcrun simctl boot \"iPhone 15 Pro\" || true\n\n    - name: Run integration tests\n      run: flutter test integration_test/\n</code></pre>"},{"location":"deployment/cicd/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"deployment/cicd/#1-blue-green-deployment","title":"1. Blue-Green Deployment","text":"<pre><code># .github/workflows/blue-green-deploy.yml\nname: Blue-Green Deployment\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n\n    - name: Build web app\n      run: flutter build web --release\n\n    - name: Deploy to staging (Green)\n      run: |\n        # Deploy to green environment\n        aws s3 sync build/web/ s3://your-app-green/\n        aws cloudfront create-invalidation --distribution-id $GREEN_DISTRIBUTION_ID --paths \"/*\"\n\n    - name: Run smoke tests\n      run: |\n        # Run smoke tests against green environment\n        curl -f https://green.yourapp.com/health || exit 1\n\n    - name: Switch traffic to green\n      run: |\n        # Switch traffic from blue to green\n        aws route53 change-resource-record-sets --hosted-zone-id $HOSTED_ZONE_ID --change-batch file://switch-to-green.json\n\n    - name: Update blue environment\n      run: |\n        # Update blue environment for next deployment\n        aws s3 sync build/web/ s3://your-app-blue/\n        aws cloudfront create-invalidation --distribution-id $BLUE_DISTRIBUTION_ID --paths \"/*\"\n</code></pre>"},{"location":"deployment/cicd/#2-canary-deployment","title":"2. Canary Deployment","text":"<pre><code># .github/workflows/canary-deploy.yml\nname: Canary Deployment\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  canary-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Build and deploy canary\n      run: |\n        flutter build web --release\n        # Deploy to canary environment (5% traffic)\n        aws s3 sync build/web/ s3://your-app-canary/\n\n    - name: Monitor canary metrics\n      run: |\n        # Monitor error rates, response times, etc.\n        python scripts/monitor_canary.py\n\n    - name: Promote to production\n      if: success()\n      run: |\n        # If canary is healthy, promote to production\n        aws s3 sync build/web/ s3://your-app-prod/\n        # Gradually increase traffic: 5% -&gt; 25% -&gt; 50% -&gt; 100%\n</code></pre> <p>CI/CD pipelines ensure consistent, reliable, and automated deployments. Implement comprehensive testing, environment management, and deployment strategies to maintain high-quality releases.</p>"},{"location":"deployment/deployment-guide/","title":"Flutter Deployment Guide","text":"<p>Comprehensive guide for deploying Flutter applications to various platforms including iOS, Android, and Web.</p>"},{"location":"deployment/deployment-guide/#pre-deployment-checklist","title":"Pre-deployment Checklist","text":""},{"location":"deployment/deployment-guide/#1-code-quality","title":"1. Code Quality","text":"<ul> <li>[ ] All tests passing</li> <li>[ ] Code coverage &gt; 80%</li> <li>[ ] No linting errors</li> <li>[ ] Performance optimized</li> <li>[ ] Security review completed</li> </ul>"},{"location":"deployment/deployment-guide/#2-configuration","title":"2. Configuration","text":"<ul> <li>[ ] Environment variables configured</li> <li>[ ] API endpoints updated for production</li> <li>[ ] Analytics and crash reporting enabled</li> <li>[ ] App icons and splash screens added</li> <li>[ ] App metadata updated</li> </ul>"},{"location":"deployment/deployment-guide/#3-platform-specific","title":"3. Platform-Specific","text":"<ul> <li>[ ] iOS: Certificates and provisioning profiles</li> <li>[ ] Android: Signing keys and Play Console setup</li> <li>[ ] Web: Hosting platform configured</li> </ul>"},{"location":"deployment/deployment-guide/#android-deployment","title":"Android Deployment","text":""},{"location":"deployment/deployment-guide/#1-app-signing","title":"1. App Signing","text":"<p>Create a keystore for release builds:</p> <pre><code>keytool -genkey -v -keystore ~/upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload\n</code></pre> <p>Configure signing in <code>android/app/build.gradle</code>:</p> <pre><code>android {\n    ...\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n            minifyEnabled true\n            useProguard true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n</code></pre> <p>Create <code>android/key.properties</code>:</p> <pre><code>storePassword=&lt;password&gt;\nkeyPassword=&lt;password&gt;\nkeyAlias=upload\nstoreFile=&lt;location of the key store file&gt;\n</code></pre>"},{"location":"deployment/deployment-guide/#2-build-release-apkaab","title":"2. Build Release APK/AAB","text":"<pre><code># Build APK\nflutter build apk --release\n\n# Build App Bundle (recommended for Play Store)\nflutter build appbundle --release\n\n# Build with specific flavor\nflutter build appbundle --release --flavor production\n</code></pre>"},{"location":"deployment/deployment-guide/#3-google-play-store-deployment","title":"3. Google Play Store Deployment","text":"<ol> <li>Create Play Console Account</li> <li>Upload App Bundle</li> <li>Configure Store Listing</li> <li>Set up Release Management</li> <li>Submit for Review</li> </ol>"},{"location":"deployment/deployment-guide/#4-automated-deployment-with-github-actions","title":"4. Automated Deployment with GitHub Actions","text":"<pre><code># .github/workflows/android-deploy.yml\nname: Android Deploy\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '11'\n\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.35.0'\n\n      - name: Get dependencies\n        run: flutter pub get\n\n      - name: Run tests\n        run: flutter test\n\n      - name: Build AAB\n        run: flutter build appbundle --release\n\n      - name: Upload to Play Store\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJsonPlainText: ${{ secrets.SERVICE_ACCOUNT_JSON }}\n          packageName: com.instagramapp.flutter\n          releaseFiles: build/app/outputs/bundle/release/app-release.aab\n          track: production\n</code></pre>"},{"location":"deployment/deployment-guide/#ios-deployment","title":"iOS Deployment","text":""},{"location":"deployment/deployment-guide/#1-xcode-configuration","title":"1. Xcode Configuration","text":"<p>Open <code>ios/Runner.xcworkspace</code> in Xcode and configure:</p> <ul> <li>Bundle Identifier: Unique identifier for your app</li> <li>Team: Your Apple Developer Team</li> <li>Deployment Target: Minimum iOS version</li> <li>App Icons: Add all required icon sizes</li> <li>Launch Screen: Configure launch screen</li> </ul>"},{"location":"deployment/deployment-guide/#2-code-signing","title":"2. Code Signing","text":"<p>Configure automatic signing in Xcode or manual signing:</p> <pre><code># For manual signing, update ios/Runner.xcodeproj/project.pbxproj\nDEVELOPMENT_TEAM = YOUR_TEAM_ID;\nCODE_SIGN_STYLE = Manual;\nPROVISIONING_PROFILE_SPECIFIER = \"Your Provisioning Profile\";\n</code></pre>"},{"location":"deployment/deployment-guide/#3-build-and-archive","title":"3. Build and Archive","text":"<pre><code># Build for iOS\nflutter build ios --release\n\n# Create archive in Xcode\n# Product &gt; Archive\n\n# Or use command line\nxcodebuild -workspace ios/Runner.xcworkspace \\\n           -scheme Runner \\\n           -configuration Release \\\n           -destination generic/platform=iOS \\\n           -archivePath build/Runner.xcarchive \\\n           archive\n</code></pre>"},{"location":"deployment/deployment-guide/#4-app-store-deployment","title":"4. App Store Deployment","text":"<ol> <li>Upload to App Store Connect</li> <li>Configure App Information</li> <li>Add Screenshots and Metadata</li> <li>Submit for Review</li> </ol>"},{"location":"deployment/deployment-guide/#5-automated-ios-deployment","title":"5. Automated iOS Deployment","text":"<pre><code># .github/workflows/ios-deploy.yml\nname: iOS Deploy\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  deploy:\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.35.0'\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Run tests\n        run: flutter test\n\n      - name: Build iOS\n        run: flutter build ios --release --no-codesign\n\n      - name: Build and upload to App Store\n        uses: yukiarrr/ios-build-action@v1.4.0\n        with:\n          project-path: ios/Runner.xcodeproj\n          p12-base64: ${{ secrets.P12_BASE64 }}\n          mobileprovision-base64: ${{ secrets.MOBILEPROVISION_BASE64 }}\n          code-signing-identity: 'iPhone Distribution'\n          team-id: ${{ secrets.TEAM_ID }}\n          workspace-path: ios/Runner.xcworkspace\n</code></pre>"},{"location":"deployment/deployment-guide/#web-deployment","title":"Web Deployment","text":""},{"location":"deployment/deployment-guide/#1-build-for-web","title":"1. Build for Web","text":"<pre><code># Build web app\nflutter build web --release\n\n# Build with specific base href\nflutter build web --base-href \"/my-app/\"\n\n# Build with web renderer\nflutter build web --web-renderer canvaskit\n</code></pre>"},{"location":"deployment/deployment-guide/#2-firebase-hosting","title":"2. Firebase Hosting","text":"<pre><code># Install Firebase CLI\nnpm install -g firebase-tools\n\n# Initialize Firebase\nfirebase init hosting\n\n# Deploy\nfirebase deploy\n</code></pre> <p>Firebase configuration (<code>firebase.json</code>):</p> <pre><code>{\n  \"hosting\": {\n    \"public\": \"build/web\",\n    \"ignore\": [\n      \"firebase.json\",\n      \"**/.*\",\n      \"**/node_modules/**\"\n    ],\n    \"rewrites\": [\n      {\n        \"source\": \"**\",\n        \"destination\": \"/index.html\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#3-github-pages","title":"3. GitHub Pages","text":"<pre><code># .github/workflows/web-deploy.yml\nname: Web Deploy\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.35.0'\n\n      - name: Get dependencies\n        run: flutter pub get\n\n      - name: Build web\n        run: flutter build web --base-href \"/flutter_instagram_app/\"\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./build/web\n</code></pre>"},{"location":"deployment/deployment-guide/#environment-configuration","title":"Environment Configuration","text":""},{"location":"deployment/deployment-guide/#1-build-flavors","title":"1. Build Flavors","text":"<p>Configure different environments:</p> <pre><code>// lib/core/config/environment.dart\nenum Environment { development, staging, production }\n\nclass EnvironmentConfig {\n  static Environment get environment {\n    const env = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');\n    switch (env) {\n      case 'staging':\n        return Environment.staging;\n      case 'production':\n        return Environment.production;\n      default:\n        return Environment.development;\n    }\n  }\n\n  static String get apiBaseUrl {\n    switch (environment) {\n      case Environment.development:\n        return 'https://dev-api.example.com';\n      case Environment.staging:\n        return 'https://staging-api.example.com';\n      case Environment.production:\n        return 'https://api.example.com';\n    }\n  }\n}\n</code></pre> <p>Build with environment:</p> <pre><code>flutter build apk --release --dart-define=ENVIRONMENT=production\n</code></pre>"},{"location":"deployment/deployment-guide/#2-secrets-management","title":"2. Secrets Management","text":"<p>Use environment variables for sensitive data:</p> <pre><code>// lib/core/config/secrets.dart\nclass Secrets {\n  static const supabaseUrl = String.fromEnvironment('SUPABASE_URL');\n  static const supabaseAnonKey = String.fromEnvironment('SUPABASE_ANON_KEY');\n  static const firebaseApiKey = String.fromEnvironment('FIREBASE_API_KEY');\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#performance-optimization","title":"Performance Optimization","text":""},{"location":"deployment/deployment-guide/#1-code-splitting","title":"1. Code Splitting","text":"<pre><code>// Use deferred imports for large features\nimport 'package:flutter/material.dart';\nimport 'heavy_feature.dart' deferred as heavy;\n\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      onPressed: () async {\n        await heavy.loadLibrary();\n        Navigator.push(\n          context,\n          MaterialPageRoute(builder: (_) =&gt; heavy.HeavyFeatureScreen()),\n        );\n      },\n      child: Text('Load Heavy Feature'),\n    );\n  }\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#2-asset-optimization","title":"2. Asset Optimization","text":"<pre><code># pubspec.yaml\nflutter:\n  assets:\n    - assets/images/\n\n  # Use different resolutions\n  assets:\n    - assets/images/logo.png\n    - assets/images/2.0x/logo.png\n    - assets/images/3.0x/logo.png\n</code></pre>"},{"location":"deployment/deployment-guide/#3-build-optimization","title":"3. Build Optimization","text":"<pre><code># Enable tree shaking\nflutter build apk --release --tree-shake-icons\n\n# Optimize bundle size\nflutter build appbundle --release --obfuscate --split-debug-info=debug-info/\n\n# Analyze bundle size\nflutter build apk --analyze-size\n</code></pre>"},{"location":"deployment/deployment-guide/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"deployment/deployment-guide/#1-crash-reporting","title":"1. Crash Reporting","text":"<pre><code>// lib/core/services/crash_service.dart\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nclass CrashService {\n  static void initialize() {\n    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;\n\n    PlatformDispatcher.instance.onError = (error, stack) {\n      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n      return true;\n    };\n  }\n\n  static void recordError(dynamic error, StackTrace? stack) {\n    FirebaseCrashlytics.instance.recordError(error, stack);\n  }\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#2-performance-monitoring","title":"2. Performance Monitoring","text":"<pre><code>// lib/core/services/performance_service.dart\nimport 'package:firebase_performance/firebase_performance.dart';\n\nclass PerformanceService {\n  static Future&lt;T&gt; trace&lt;T&gt;(String name, Future&lt;T&gt; Function() operation) async {\n    final trace = FirebasePerformance.instance.newTrace(name);\n    await trace.start();\n\n    try {\n      final result = await operation();\n      trace.setMetric('success', 1);\n      return result;\n    } catch (e) {\n      trace.setMetric('error', 1);\n      rethrow;\n    } finally {\n      await trace.stop();\n    }\n  }\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#security-considerations","title":"Security Considerations","text":""},{"location":"deployment/deployment-guide/#1-code-obfuscation","title":"1. Code Obfuscation","text":"<pre><code>flutter build apk --release --obfuscate --split-debug-info=debug-info/\n</code></pre>"},{"location":"deployment/deployment-guide/#2-certificate-pinning","title":"2. Certificate Pinning","text":"<pre><code>// lib/core/network/certificate_pinning.dart\nimport 'package:dio_certificate_pinning/dio_certificate_pinning.dart';\n\nclass NetworkService {\n  static Dio createDio() {\n    final dio = Dio();\n\n    dio.interceptors.add(\n      CertificatePinningInterceptor(\n        allowedSHAFingerprints: ['SHA256:XXXXXX'],\n      ),\n    );\n\n    return dio;\n  }\n}\n</code></pre>"},{"location":"deployment/deployment-guide/#post-deployment","title":"Post-Deployment","text":""},{"location":"deployment/deployment-guide/#1-monitoring","title":"1. Monitoring","text":"<ul> <li>Set up crash reporting alerts</li> <li>Monitor app performance metrics</li> <li>Track user analytics</li> <li>Monitor API usage and errors</li> </ul>"},{"location":"deployment/deployment-guide/#2-updates","title":"2. Updates","text":"<ul> <li>Plan regular updates</li> <li>Use staged rollouts</li> <li>Monitor update adoption</li> <li>Maintain backward compatibility</li> </ul>"},{"location":"deployment/deployment-guide/#3-maintenance","title":"3. Maintenance","text":"<ul> <li>Regular security updates</li> <li>Performance optimizations</li> <li>Bug fixes and improvements</li> <li>Feature updates based on user feedback</li> </ul>"},{"location":"deployment/deployment-guide/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Configure your deployment pipelines</li> <li>\u2705 Set up monitoring and analytics</li> <li>\u2705 Plan your release strategy</li> <li>\u2705 Monitor post-deployment metrics</li> <li>\u2705 Your Flutter app is ready for production!</li> </ol> <p>Your Flutter deployment strategy is now ready for reliable, automated releases!</p>"},{"location":"deployment/google-play/","title":"Google Play Store Deployment","text":"<p>Comprehensive guide to deploying Flutter applications to Google Play Store, including preparation, submission, and post-launch management.</p>"},{"location":"deployment/google-play/#overview","title":"Overview","text":"<p>Google Play deployment involves preparing your Android app, configuring store listing, submitting for review, and managing releases. This guide covers the complete process from build preparation to Play Store optimization.</p>"},{"location":"deployment/google-play/#prerequisites","title":"Prerequisites","text":""},{"location":"deployment/google-play/#1-google-play-console-setup","title":"1. Google Play Console Setup","text":"<pre><code># Required accounts and setup\n- Google Play Developer account ($25 one-time fee)\n- Google Play Console access\n- Android Studio or command line tools\n- Valid signing key and keystore\n- Google Play App Signing enabled\n</code></pre>"},{"location":"deployment/google-play/#2-app-signing-configuration","title":"2. App Signing Configuration","text":"<pre><code># Generate upload keystore\nkeytool -genkey -v -keystore upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload\n\n# Key information to save securely\nKeystore password: [SECURE_PASSWORD]\nKey alias: upload\nKey password: [SECURE_PASSWORD]\n</code></pre>"},{"location":"deployment/google-play/#build-preparation","title":"Build Preparation","text":""},{"location":"deployment/google-play/#1-android-build-configuration","title":"1. Android Build Configuration","text":"<pre><code>// android/app/build.gradle\nandroid {\n    compileSdkVersion 34\n\n    defaultConfig {\n        applicationId \"com.yourcompany.yourapp\"\n        minSdkVersion 21\n        targetSdkVersion 34\n        versionCode 1\n        versionName \"1.0.0\"\n        multiDexEnabled true\n    }\n\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    // Split APKs by ABI for smaller downloads\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'x86', 'x86_64', 'arm64-v8a', 'armeabi-v7a'\n            universalApk false\n        }\n    }\n}\n\ndependencies {\n    implementation 'androidx.multidex:multidex:2.0.1'\n}\n</code></pre>"},{"location":"deployment/google-play/#2-android-manifest-configuration","title":"2. Android Manifest Configuration","text":"<pre><code>&lt;!-- android/app/src/main/AndroidManifest.xml --&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.yourcompany.yourapp\"&gt;\n\n    &lt;!-- Permissions --&gt;\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" /&gt;\n\n    &lt;!-- Hardware features --&gt;\n    &lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" /&gt;\n    &lt;uses-feature android:name=\"android.hardware.location\" android:required=\"false\" /&gt;\n    &lt;uses-feature android:name=\"android.hardware.microphone\" android:required=\"false\" /&gt;\n\n    &lt;application\n        android:label=\"YourApp\"\n        android:name=\"${applicationName}\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:theme=\"@style/LaunchTheme\"\n        android:exported=\"true\"\n        android:usesCleartextTraffic=\"false\"\n        android:allowBackup=\"false\"\n        android:fullBackupContent=\"false\"&gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:launchMode=\"singleTop\"\n            android:theme=\"@style/LaunchTheme\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\"\n            android:hardwareAccelerated=\"true\"\n            android:windowSoftInputMode=\"adjustResize\"&gt;\n\n            &lt;meta-data\n                android:name=\"io.flutter.embedding.android.NormalTheme\"\n                android:resource=\"@style/NormalTheme\" /&gt;\n\n            &lt;intent-filter android:autoVerify=\"true\"&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n            &lt;/intent-filter&gt;\n\n            &lt;!-- Deep linking --&gt;\n            &lt;intent-filter android:autoVerify=\"true\"&gt;\n                &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n                &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n                &lt;data android:scheme=\"https\"\n                      android:host=\"yourapp.com\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;!-- Firebase Messaging --&gt;\n        &lt;service\n            android:name=\".MyFirebaseMessagingService\"\n            android:exported=\"false\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"com.google.firebase.MESSAGING_EVENT\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/service&gt;\n\n        &lt;meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_icon\"\n            android:resource=\"@drawable/ic_notification\" /&gt;\n\n        &lt;meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_color\"\n            android:resource=\"@color/notification_color\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"deployment/google-play/#3-proguard-configuration","title":"3. ProGuard Configuration","text":"<pre><code># android/app/proguard-rules.pro\n\n# Flutter specific rules\n-keep class io.flutter.app.** { *; }\n-keep class io.flutter.plugin.**  { *; }\n-keep class io.flutter.util.**  { *; }\n-keep class io.flutter.view.**  { *; }\n-keep class io.flutter.**  { *; }\n-keep class io.flutter.plugins.**  { *; }\n\n# Firebase\n-keep class com.google.firebase.** { *; }\n-keep class com.google.android.gms.** { *; }\n\n# Supabase\n-keep class io.supabase.** { *; }\n\n# Remove debug logs\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n# Keep native methods\n-keepclasseswithmembernames class * {\n    native &lt;methods&gt;;\n}\n\n# Keep serializable classes\n-keepclassmembers class * implements java.io.Serializable {\n    static final long serialVersionUID;\n    private static final java.io.ObjectStreamField[] serialPersistentFields;\n    private void writeObject(java.io.ObjectOutputStream);\n    private void readObject(java.io.ObjectInputStream);\n    java.lang.Object writeReplace();\n    java.lang.Object readResolve();\n}\n</code></pre>"},{"location":"deployment/google-play/#build-scripts","title":"Build Scripts","text":""},{"location":"deployment/google-play/#1-google-play-build-script","title":"1. Google Play Build Script","text":"<pre><code>#!/bin/bash\n# scripts/build-android-playstore.sh\n\nset -e\n\necho \"Building Android app for Google Play Store...\"\n\n# Clean previous builds\nflutter clean\n\n# Get dependencies\nflutter pub get\n\n# Build App Bundle (recommended for Play Store)\nflutter build appbundle --release \\\n  --dart-define=ENVIRONMENT=production \\\n  --dart-define-from-file=.env.production \\\n  --obfuscate \\\n  --split-debug-info=build/debug-info\n\n# Also build APK for testing\nflutter build apk --release \\\n  --dart-define=ENVIRONMENT=production \\\n  --dart-define-from-file=.env.production \\\n  --obfuscate \\\n  --split-debug-info=build/debug-info\n\necho \"Android build completed successfully!\"\necho \"App Bundle: build/app/outputs/bundle/release/app-release.aab\"\necho \"APK: build/app/outputs/flutter-apk/app-release.apk\"\n\n# Validate the build\necho \"Validating build...\"\nif [ -f \"build/app/outputs/bundle/release/app-release.aab\" ]; then\n    echo \"\u2713 App Bundle created successfully\"\n\n    # Check bundle size\n    BUNDLE_SIZE=$(stat -f%z build/app/outputs/bundle/release/app-release.aab 2&gt;/dev/null || stat -c%s build/app/outputs/bundle/release/app-release.aab)\n    echo \"Bundle size: $((BUNDLE_SIZE / 1024 / 1024)) MB\"\n\n    if [ $BUNDLE_SIZE -gt $((150 * 1024 * 1024)) ]; then\n        echo \"\u26a0\ufe0f  Warning: Bundle size exceeds 150MB limit\"\n    fi\nelse\n    echo \"\u274c App Bundle creation failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"deployment/google-play/#2-fastlane-configuration","title":"2. Fastlane Configuration","text":"<pre><code># android/fastlane/Fastfile\ndefault_platform(:android)\n\nplatform :android do\n  desc \"Deploy to Google Play Store\"\n  lane :deploy do\n    # Ensure we're on the right branch\n    ensure_git_branch(branch: 'main')\n    ensure_git_status_clean\n\n    # Build the app bundle\n    sh(\"cd .. &amp;&amp; flutter build appbundle --release --dart-define=ENVIRONMENT=production\")\n\n    # Upload to Google Play\n    upload_to_play_store(\n      track: 'production',\n      aab: '../build/app/outputs/bundle/release/app-release.aab',\n      skip_upload_apk: true,\n      skip_upload_metadata: false,\n      skip_upload_images: false,\n      skip_upload_screenshots: false,\n      release_status: 'draft'\n    )\n\n    # Create git tag\n    add_git_tag(\n      tag: \"android-v#{get_version_name}\"\n    )\n\n    # Push changes\n    push_to_git_remote\n  end\n\n  desc \"Deploy to Internal Testing\"\n  lane :internal do\n    sh(\"cd .. &amp;&amp; flutter build appbundle --release --dart-define=ENVIRONMENT=staging\")\n\n    upload_to_play_store(\n      track: 'internal',\n      aab: '../build/app/outputs/bundle/release/app-release.aab',\n      skip_upload_apk: true,\n      skip_upload_metadata: true,\n      skip_upload_images: true,\n      skip_upload_screenshots: true\n    )\n  end\n\n  desc \"Deploy to Closed Testing\"\n  lane :beta do\n    sh(\"cd .. &amp;&amp; flutter build appbundle --release --dart-define=ENVIRONMENT=staging\")\n\n    upload_to_play_store(\n      track: 'beta',\n      aab: '../build/app/outputs/bundle/release/app-release.aab',\n      skip_upload_apk: true,\n      skip_upload_metadata: false,\n      skip_upload_images: false,\n      skip_upload_screenshots: false\n    )\n  end\n\n  desc \"Upload metadata only\"\n  lane :metadata do\n    upload_to_play_store(\n      skip_upload_aab: true,\n      skip_upload_apk: true,\n      skip_upload_metadata: false,\n      skip_upload_images: false,\n      skip_upload_screenshots: false\n    )\n  end\nend\n</code></pre>"},{"location":"deployment/google-play/#store-listing-assets","title":"Store Listing Assets","text":""},{"location":"deployment/google-play/#1-app-icons","title":"1. App Icons","text":"<pre><code># Required icon sizes for Android\nres/mipmap-mdpi/ic_launcher.png (48x48)\nres/mipmap-hdpi/ic_launcher.png (72x72)\nres/mipmap-xhdpi/ic_launcher.png (96x96)\nres/mipmap-xxhdpi/ic_launcher.png (144x144)\nres/mipmap-xxxhdpi/ic_launcher.png (192x192)\n\n# Adaptive icons (Android 8.0+)\nres/mipmap-mdpi/ic_launcher_foreground.png (108x108)\nres/mipmap-hdpi/ic_launcher_foreground.png (162x162)\nres/mipmap-xhdpi/ic_launcher_foreground.png (216x216)\nres/mipmap-xxhdpi/ic_launcher_foreground.png (324x324)\nres/mipmap-xxxhdpi/ic_launcher_foreground.png (432x432)\n\n# Play Store icon\nplay_store_icon.png (512x512)\n</code></pre>"},{"location":"deployment/google-play/#2-screenshots","title":"2. Screenshots","text":"<pre><code># Required screenshot sizes\nPhone: 320dp to 3840dp (minimum 320dp)\n7-inch tablet: 600dp to 3840dp (minimum 600dp)\n10-inch tablet: 768dp to 3840dp (minimum 768dp)\n\n# Recommended sizes\nPhone: 1080x1920, 1080x2340, 1440x2560\nTablet: 1200x1920, 1600x2560\n</code></pre>"},{"location":"deployment/google-play/#3-feature-graphic","title":"3. Feature Graphic","text":"<pre><code># Feature graphic for Play Store\nfeature_graphic.png (1024x500)\n</code></pre>"},{"location":"deployment/google-play/#store-listing-metadata","title":"Store Listing Metadata","text":""},{"location":"deployment/google-play/#1-fastlane-metadata-structure","title":"1. Fastlane Metadata Structure","text":"<pre><code># android/fastlane/metadata/android/en-US/\ntitle.txt\nshort_description.txt\nfull_description.txt\nvideo.txt\nchangelogs/\n  1.txt\n  2.txt\nimages/\n  featureGraphic.png\n  icon.png\n  phoneScreenshots/\n    1_screenshot.png\n    2_screenshot.png\n  sevenInchScreenshots/\n  tenInchScreenshots/\n</code></pre>"},{"location":"deployment/google-play/#2-store-listing-content","title":"2. Store Listing Content","text":"<pre><code># android/fastlane/metadata/android/en-US/title.txt\nYourApp - Social Media Platform\n</code></pre> <pre><code># android/fastlane/metadata/android/en-US/short_description.txt\nConnect, share, and discover with YourApp - the social platform for everyone.\n</code></pre> <pre><code># android/fastlane/metadata/android/en-US/full_description.txt\nYourApp is a revolutionary social media platform that brings people together through shared interests and meaningful connections.\n\n&lt;b&gt;Key Features:&lt;/b&gt;\n\u2022 Share photos and videos with your network\n\u2022 Discover content tailored to your interests\n\u2022 Connect with friends and like-minded individuals\n\u2022 Real-time messaging and notifications\n\u2022 Privacy-focused design with granular controls\n\u2022 Dark mode and accessibility features\n\n&lt;b&gt;Why Choose YourApp?&lt;/b&gt;\n\u2713 User privacy is our top priority\n\u2713 Ad-free experience with optional premium features\n\u2713 Advanced content filtering and moderation\n\u2713 Cross-platform synchronization\n\u2713 Regular updates with new features\n\n&lt;b&gt;Community Guidelines:&lt;/b&gt;\nWe're committed to creating a safe and inclusive environment for all users. Our community guidelines ensure respectful interactions and content sharing.\n\n&lt;b&gt;Support:&lt;/b&gt;\nNeed help? Visit our support center at https://yourapp.com/support or contact us directly through the app.\n\nJoin millions of users who are already connecting and sharing on YourApp!\n</code></pre>"},{"location":"deployment/google-play/#release-management","title":"Release Management","text":""},{"location":"deployment/google-play/#1-staged-rollout-strategy","title":"1. Staged Rollout Strategy","text":"<pre><code># android/fastlane/Fastfile - Staged rollout\nlane :staged_rollout do\n  # Start with 5% rollout\n  upload_to_play_store(\n    track: 'production',\n    rollout: '0.05',\n    aab: '../build/app/outputs/bundle/release/app-release.aab'\n  )\n\n  # Monitor for 24 hours, then increase to 20%\n  # This would typically be done manually or with monitoring automation\nend\n\nlane :increase_rollout do |options|\n  percentage = options[:percentage] || '0.2'\n\n  upload_to_play_store(\n    track: 'production',\n    rollout: percentage,\n    skip_upload_aab: true,\n    skip_upload_metadata: true\n  )\nend\n</code></pre>"},{"location":"deployment/google-play/#2-release-notes-management","title":"2. Release Notes Management","text":"<pre><code># android/fastlane/metadata/android/en-US/changelogs/1.txt\n\ud83c\udf89 Welcome to YourApp v1.0!\n\n\u2728 New Features:\n\u2022 Photo and video sharing\n\u2022 Real-time messaging\n\u2022 Interest-based discovery\n\u2022 Privacy controls\n\n\ud83d\udc1b Bug Fixes:\n\u2022 Improved app stability\n\u2022 Enhanced performance\n\u2022 Fixed login issues\n\n\ud83d\udcf1 Improvements:\n\u2022 Better user interface\n\u2022 Faster loading times\n\u2022 Accessibility enhancements\n\nThank you for using YourApp! We're excited to have you join our community.\n</code></pre>"},{"location":"deployment/google-play/#google-play-policies-compliance","title":"Google Play Policies Compliance","text":""},{"location":"deployment/google-play/#1-pre-submission-checklist","title":"1. Pre-Submission Checklist","text":"<pre><code>## Technical Requirements\n- [ ] App targets Android API level 33 or higher\n- [ ] App Bundle format used for upload\n- [ ] 64-bit architecture support included\n- [ ] App signing by Google Play enabled\n- [ ] Proper permission declarations\n- [ ] Network security configuration implemented\n\n## Content Policy\n- [ ] No prohibited content (violence, hate speech, etc.)\n- [ ] Age-appropriate content rating\n- [ ] Accurate app description and screenshots\n- [ ] No misleading claims or functionality\n- [ ] Proper content moderation if user-generated content\n\n## Privacy Policy\n- [ ] Privacy policy URL provided and accessible\n- [ ] Data collection practices disclosed\n- [ ] User consent mechanisms implemented\n- [ ] COPPA compliance if targeting children\n- [ ] GDPR compliance for EU users\n\n## Monetization\n- [ ] In-app purchases properly implemented\n- [ ] Subscription terms clearly stated\n- [ ] No deceptive billing practices\n- [ ] Proper refund policy\n</code></pre>"},{"location":"deployment/google-play/#2-common-rejection-reasons","title":"2. Common Rejection Reasons","text":"<pre><code>## Policy Violations\n- Inappropriate content or age rating\n- Misleading app description or screenshots\n- Privacy policy issues\n- Intellectual property violations\n- Spam or low-quality content\n\n## Technical Issues\n- App crashes or doesn't function properly\n- Missing required permissions\n- Security vulnerabilities\n- Poor user experience\n- API level compliance issues\n\n## Metadata Issues\n- Incorrect categorization\n- Keyword stuffing\n- Inappropriate screenshots\n- Missing required information\n</code></pre>"},{"location":"deployment/google-play/#post-launch-optimization","title":"Post-Launch Optimization","text":""},{"location":"deployment/google-play/#1-play-console-analytics","title":"1. Play Console Analytics","text":"<pre><code>// lib/services/play_console_analytics.dart\nclass PlayConsoleAnalytics {\n  // Track Play Store metrics\n  static void trackPlayStoreMetrics() {\n    final metrics = {\n      'installs': getInstallCount(),\n      'uninstalls': getUninstallCount(),\n      'rating': getCurrentRating(),\n      'reviews': getReviewCount(),\n      'crashes': getCrashRate(),\n    };\n\n    AnalyticsService.track('play_store_metrics', metrics);\n  }\n\n  // Monitor acquisition performance\n  static void trackAcquisitionMetrics() {\n    final acquisitionMetrics = {\n      'organic_installs': getOrganicInstalls(),\n      'paid_installs': getPaidInstalls(),\n      'conversion_rate': getStoreListingConversionRate(),\n      'search_installs': getSearchInstalls(),\n    };\n\n    AnalyticsService.track('play_store_acquisition', acquisitionMetrics);\n  }\n}\n</code></pre>"},{"location":"deployment/google-play/#2-ab-testing-store-listing","title":"2. A/B Testing Store Listing","text":"<pre><code>// lib/services/store_listing_experiments.dart\nclass StoreListingExperiments {\n  // Track store listing experiment performance\n  static void trackExperimentMetrics(String experimentId, String variant) {\n    final metrics = {\n      'experiment_id': experimentId,\n      'variant': variant,\n      'install_rate': getInstallRate(),\n      'conversion_rate': getConversionRate(),\n    };\n\n    AnalyticsService.track('store_listing_experiment', metrics);\n  }\n}\n</code></pre>"},{"location":"deployment/google-play/#3-review-management","title":"3. Review Management","text":"<pre><code>// lib/services/review_management.dart\nclass ReviewManagement {\n  // Monitor and respond to reviews\n  static Future&lt;void&gt; checkNewReviews() async {\n    final newReviews = await getNewReviews();\n\n    for (final review in newReviews) {\n      if (review.rating &lt;= 3) {\n        // Flag for manual response\n        await flagForResponse(review);\n      }\n\n      // Auto-categorize feedback\n      final category = categorizeReview(review.text);\n      await updateReviewCategory(review.id, category);\n    }\n  }\n\n  static String categorizeReview(String reviewText) {\n    // Simple categorization logic\n    if (reviewText.toLowerCase().contains('crash') || \n        reviewText.toLowerCase().contains('bug')) {\n      return 'technical_issue';\n    } else if (reviewText.toLowerCase().contains('feature') ||\n               reviewText.toLowerCase().contains('request')) {\n      return 'feature_request';\n    } else if (reviewText.toLowerCase().contains('slow') ||\n               reviewText.toLowerCase().contains('performance')) {\n      return 'performance';\n    }\n    return 'general_feedback';\n  }\n}\n</code></pre>"},{"location":"deployment/google-play/#continuous-deployment","title":"Continuous Deployment","text":""},{"location":"deployment/google-play/#1-github-actions-for-play-store","title":"1. GitHub Actions for Play Store","text":"<pre><code># .github/workflows/android-deploy.yml\nname: Deploy to Google Play\n\non:\n  push:\n    branches: [ main ]\n    tags: [ 'v*' ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Java\n      uses: actions/setup-java@v3\n      with:\n        distribution: 'zulu'\n        java-version: '17'\n\n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.35.0'\n\n    - name: Get dependencies\n      run: flutter pub get\n\n    - name: Run tests\n      run: flutter test\n\n    - name: Decode keystore\n      run: |\n        echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 -d &gt; android/app/keystore.jks\n\n    - name: Create key.properties\n      run: |\n        echo \"storePassword=${{ secrets.KEYSTORE_PASSWORD }}\" &gt; android/key.properties\n        echo \"keyPassword=${{ secrets.KEY_PASSWORD }}\" &gt;&gt; android/key.properties\n        echo \"keyAlias=${{ secrets.KEY_ALIAS }}\" &gt;&gt; android/key.properties\n        echo \"storeFile=keystore.jks\" &gt;&gt; android/key.properties\n\n    - name: Build App Bundle\n      run: flutter build appbundle --release --dart-define=ENVIRONMENT=production\n\n    - name: Setup Ruby\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: '3.0'\n        bundler-cache: true\n        working-directory: android\n\n    - name: Deploy to Play Store\n      env:\n        GOOGLE_PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}\n      run: |\n        cd android\n        bundle exec fastlane deploy\n</code></pre> <p>Google Play deployment requires careful attention to policies, technical requirements, and user experience. Focus on quality, compliance, and continuous optimization to achieve success on the platform.</p>"},{"location":"maintenance/hot-reload/","title":"Hot Reload &amp; Hot Restart","text":"<p>Comprehensive guide to Flutter's development features for rapid iteration and debugging.</p>"},{"location":"maintenance/hot-reload/#overview","title":"Overview","text":"<p>Flutter's hot reload and hot restart capabilities are among its most powerful features for development productivity. This guide covers how to use them effectively and troubleshoot common issues.</p>"},{"location":"maintenance/hot-reload/#hot-reload","title":"Hot Reload","text":""},{"location":"maintenance/hot-reload/#what-is-hot-reload","title":"What is Hot Reload?","text":"<p>Hot reload allows you to see changes in your code almost instantly without losing the current state of your app.</p> <p>Key Features: - Preserves app state - Updates UI changes instantly - Maintains navigation stack - Keeps form data and scroll positions</p>"},{"location":"maintenance/hot-reload/#how-to-use-hot-reload","title":"How to Use Hot Reload","text":"<pre><code># In terminal\nr  # Press 'r' to hot reload\n\n# In IDE\nCtrl+S (VS Code with auto-save)\nCmd+S (macOS)\n\n# Flutter command\nflutter run --hot\n</code></pre>"},{"location":"maintenance/hot-reload/#what-hot-reload-can-update","title":"What Hot Reload Can Update","text":"<p>\u2705 Supported Changes: - Widget modifications - UI layout changes - Color and styling updates - Text content changes - Adding/removing widgets - Method implementations</p> <pre><code>// Before hot reload\nContainer(\n  color: Colors.blue,\n  child: Text('Hello'),\n)\n\n// After hot reload - state preserved\nContainer(\n  color: Colors.red,  // \u2705 Updates instantly\n  child: Text('Hello World'),  // \u2705 Updates instantly\n)\n</code></pre>"},{"location":"maintenance/hot-reload/#what-hot-reload-cannot-update","title":"What Hot Reload Cannot Update","text":"<p>\u274c Unsupported Changes: - Global variables and static fields - Main method changes - initState() modifications - App lifecycle changes - Native code changes</p> <pre><code>// These require hot restart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'New Title',  // \u274c Requires hot restart\n      home: MyHomePage(),\n    );\n  }\n}\n\n// Global variables\nString globalVar = 'new value';  // \u274c Requires hot restart\n\n// Static fields\nclass Constants {\n  static const String apiUrl = 'new-url';  // \u274c Requires hot restart\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#hot-restart","title":"Hot Restart","text":""},{"location":"maintenance/hot-reload/#what-is-hot-restart","title":"What is Hot Restart?","text":"<p>Hot restart recompiles the app and restarts it, losing all state but applying all changes.</p> <p>Key Features: - Resets app state - Applies all code changes - Restarts from main() - Clears navigation stack</p>"},{"location":"maintenance/hot-reload/#how-to-use-hot-restart","title":"How to Use Hot Restart","text":"<pre><code># In terminal\nR  # Press 'R' to hot restart\n\n# In IDE\nCtrl+Shift+F5 (VS Code)\nCmd+Shift+F5 (macOS)\n\n# Flutter command\nflutter run --hot --hot-restart\n</code></pre>"},{"location":"maintenance/hot-reload/#when-to-use-hot-restart","title":"When to Use Hot Restart","text":"<p>Use hot restart when: - Hot reload doesn't work - Changing app initialization - Modifying main() method - Updating global variables - Adding new dependencies - Changing app configuration</p> <pre><code>// Changes that require hot restart\nvoid main() {\n  runApp(MyApp());  // \u2705 Hot restart needed\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,  // \u2705 Hot restart needed\n      theme: ThemeData(\n        primarySwatch: Colors.blue,  // \u2705 Hot restart needed\n      ),\n      home: MyHomePage(),\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#advanced-hot-reload-techniques","title":"Advanced Hot Reload Techniques","text":""},{"location":"maintenance/hot-reload/#1-preserving-state-during-development","title":"1. Preserving State During Development","text":"<pre><code>class CounterWidget extends StatefulWidget {\n  @override\n  _CounterWidgetState createState() =&gt; _CounterWidgetState();\n}\n\nclass _CounterWidgetState extends State&lt;CounterWidget&gt; {\n  int _counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Counter: $_counter'),\n        ElevatedButton(\n          onPressed: () =&gt; setState(() =&gt; _counter++),\n          child: Text('Increment'),\n        ),\n        // Add new widgets here - counter state preserved! \u2705\n        ElevatedButton(\n          onPressed: () =&gt; setState(() =&gt; _counter--),\n          child: Text('Decrement'),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#2-using-debugger-with-hot-reload","title":"2. Using Debugger with Hot Reload","text":"<pre><code>class DebugWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Add breakpoints here\n    debugger();  // \u2705 Works with hot reload\n\n    return Container(\n      child: Text('Debug me!'),\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#3-hot-reload-with-state-management","title":"3. Hot Reload with State Management","text":"<pre><code>// Riverpod - state preserved during hot reload\nfinal counterProvider = StateProvider&lt;int&gt;((ref) =&gt; 0);\n\nclass CounterScreen extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = ref.watch(counterProvider);\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          children: [\n            Text('Count: $counter'),  // \u2705 State preserved\n            ElevatedButton(\n              onPressed: () =&gt; ref.read(counterProvider.notifier).state++,\n              child: Text('Increment'),\n            ),\n            // Add new UI here - state preserved! \u2705\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#troubleshooting-hot-reload","title":"Troubleshooting Hot Reload","text":""},{"location":"maintenance/hot-reload/#1-hot-reload-not-working","title":"1. Hot Reload Not Working","text":"<p>Common Causes: - Syntax errors in code - Compilation errors - IDE not connected to Flutter process</p> <p>Solutions: <pre><code># Check for errors\nflutter analyze\n\n# Restart Flutter process\nflutter run\n\n# Clear cache\nflutter clean\nflutter pub get\n</code></pre></p>"},{"location":"maintenance/hot-reload/#2-state-not-preserving","title":"2. State Not Preserving","text":"<p>Problem: App state resets during hot reload</p> <p>Solutions: <pre><code>// Use StatefulWidget for local state\nclass MyWidget extends StatefulWidget {\n  @override\n  _MyWidgetState createState() =&gt; _MyWidgetState();\n}\n\nclass _MyWidgetState extends State&lt;MyWidget&gt; {\n  String _data = 'preserved';  // \u2705 Preserved during hot reload\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(_data);\n  }\n}\n\n// Avoid global variables\nString globalData = 'reset';  // \u274c Reset during hot reload\n</code></pre></p>"},{"location":"maintenance/hot-reload/#3-hot-reload-slow","title":"3. Hot Reload Slow","text":"<p>Optimization Tips: <pre><code>// Avoid expensive operations in build()\nclass OptimizedWidget extends StatelessWidget {\n  // \u2705 Compute expensive data outside build\n  static final expensiveData = _computeExpensiveData();\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(expensiveData);\n  }\n\n  static String _computeExpensiveData() {\n    // Expensive computation here\n    return 'result';\n  }\n}\n\n// Use const constructors\nclass ConstWidget extends StatelessWidget {\n  const ConstWidget({Key? key}) : super(key: key);  // \u2705 const constructor\n\n  @override\n  Widget build(BuildContext context) {\n    return const Text('Constant widget');  // \u2705 const widget\n  }\n}\n</code></pre></p>"},{"location":"maintenance/hot-reload/#ide-integration","title":"IDE Integration","text":""},{"location":"maintenance/hot-reload/#vs-code","title":"VS Code","text":"<pre><code>// .vscode/settings.json\n{\n  \"dart.flutterHotReloadOnSave\": \"always\",\n  \"dart.hotReloadOnSave\": \"always\",\n  \"files.autoSave\": \"afterDelay\",\n  \"files.autoSaveDelay\": 1000\n}\n</code></pre> <p>Useful Shortcuts: - <code>Ctrl+F5</code>: Start without debugging - <code>F5</code>: Start with debugging - <code>Ctrl+Shift+F5</code>: Hot restart - <code>Ctrl+F10</code>: Hot reload</p>"},{"location":"maintenance/hot-reload/#android-studio","title":"Android Studio","text":"<p>Settings: - Enable \"Perform hot reload on save\" - Enable \"Format code on save\" - Set auto-save delay</p> <p>Shortcuts: - <code>Ctrl+\\</code>: Hot reload - <code>Ctrl+Shift+\\</code>: Hot restart - <code>Shift+F10</code>: Run - <code>Shift+F9</code>: Debug</p>"},{"location":"maintenance/hot-reload/#best-practices","title":"Best Practices","text":""},{"location":"maintenance/hot-reload/#1-structure-code-for-hot-reload","title":"1. Structure Code for Hot Reload","text":"<pre><code>// \u2705 Good: Separate widgets for better hot reload\nclass UserProfile extends StatelessWidget {\n  final User user;\n\n  const UserProfile({Key? key, required this.user}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        UserAvatar(user: user),      // \u2705 Separate widget\n        UserDetails(user: user),     // \u2705 Separate widget\n        UserActions(user: user),     // \u2705 Separate widget\n      ],\n    );\n  }\n}\n\n// \u274c Avoid: Large monolithic widgets\nclass MonolithicWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // 100+ lines of widget code\n        // Hot reload becomes slow\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#2-use-development-only-code","title":"2. Use Development-Only Code","text":"<pre><code>class DebugHelper {\n  static void logBuildTime(String widgetName) {\n    if (kDebugMode) {  // \u2705 Only in debug mode\n      print('Building $widgetName at ${DateTime.now()}');\n    }\n  }\n}\n\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    DebugHelper.logBuildTime('MyWidget');  // \u2705 Debug info\n\n    return Container(\n      // Widget implementation\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#3-handle-hot-reload-in-state","title":"3. Handle Hot Reload in State","text":"<pre><code>class SmartWidget extends StatefulWidget {\n  @override\n  _SmartWidgetState createState() =&gt; _SmartWidgetState();\n}\n\nclass _SmartWidgetState extends State&lt;SmartWidget&gt; {\n  String _data = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _loadData();\n  }\n\n  @override\n  void reassemble() {\n    super.reassemble();\n    // Called during hot reload\n    if (kDebugMode) {\n      print('Hot reload detected');\n      // Optionally refresh data\n      _loadData();\n    }\n  }\n\n  void _loadData() {\n    // Load data logic\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(_data);\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"maintenance/hot-reload/#1-hot-reload-metrics","title":"1. Hot Reload Metrics","text":"<pre><code>class HotReloadMetrics {\n  static final Stopwatch _stopwatch = Stopwatch();\n\n  static void startBuildTimer() {\n    if (kDebugMode) {\n      _stopwatch.reset();\n      _stopwatch.start();\n    }\n  }\n\n  static void endBuildTimer(String widgetName) {\n    if (kDebugMode) {\n      _stopwatch.stop();\n      print('$widgetName build time: ${_stopwatch.elapsedMilliseconds}ms');\n    }\n  }\n}\n\nclass MonitoredWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    HotReloadMetrics.startBuildTimer();\n\n    final widget = Container(\n      // Widget implementation\n    );\n\n    HotReloadMetrics.endBuildTimer('MonitoredWidget');\n    return widget;\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#2-memory-usage-during-development","title":"2. Memory Usage During Development","text":"<pre><code>import 'dart:developer' as developer;\n\nclass MemoryMonitor {\n  static void logMemoryUsage() {\n    if (kDebugMode) {\n      developer.log('Memory usage: ${_getMemoryUsage()}');\n    }\n  }\n\n  static String _getMemoryUsage() {\n    // Implementation depends on platform\n    return 'Memory info';\n  }\n}\n</code></pre>"},{"location":"maintenance/hot-reload/#conclusion","title":"Conclusion","text":"<p>Hot reload and hot restart are powerful tools that significantly speed up Flutter development. Understanding when and how to use each feature effectively can dramatically improve your development workflow.</p> <p>Key Takeaways: - Use hot reload for UI changes and state preservation - Use hot restart for structural and configuration changes - Structure your code to maximize hot reload effectiveness - Monitor performance during development - Leverage IDE integrations for the best experience</p> <p>Master these tools to become a more productive Flutter developer!</p>"},{"location":"maintenance/legacy-support/","title":"Legacy Support &amp; Backward Compatibility","text":"<p>Comprehensive guide to maintaining backward compatibility and supporting legacy versions in Flutter applications.</p>"},{"location":"maintenance/legacy-support/#overview","title":"Overview","text":"<p>Legacy support ensures that older app versions continue to function while new features are developed. This guide covers API versioning, feature deprecation, and migration strategies for maintaining compatibility.</p>"},{"location":"maintenance/legacy-support/#api-versioning-strategy","title":"API Versioning Strategy","text":""},{"location":"maintenance/legacy-support/#1-api-version-management","title":"1. API Version Management","text":"<pre><code>// lib/services/api_version_service.dart\nclass ApiVersionService {\n  static const String currentApiVersion = '2.1';\n  static const String minSupportedApiVersion = '1.5';\n  static const String deprecatedApiVersion = '1.0';\n\n  // API version headers\n  static Map&lt;String, String&gt; getVersionHeaders() {\n    return {\n      'API-Version': currentApiVersion,\n      'Client-Version': VersionConfig.appVersion,\n      'Min-Supported-Version': minSupportedApiVersion,\n    };\n  }\n\n  // Check if API version is supported\n  static bool isApiVersionSupported(String version) {\n    return VersionConfig.compareVersions(version, minSupportedApiVersion) &gt;= 0;\n  }\n\n  // Check if API version is deprecated\n  static bool isApiVersionDeprecated(String version) {\n    return VersionConfig.compareVersions(version, deprecatedApiVersion) &lt;= 0;\n  }\n\n  // Get appropriate API endpoint for version\n  static String getApiEndpoint(String baseUrl, String version) {\n    if (VersionConfig.compareVersions(version, '2.0') &gt;= 0) {\n      return '$baseUrl/v2';\n    } else if (VersionConfig.compareVersions(version, '1.5') &gt;= 0) {\n      return '$baseUrl/v1.5';\n    } else {\n      return '$baseUrl/v1';\n    }\n  }\n\n  // Handle version-specific request formatting\n  static Map&lt;String, dynamic&gt; formatRequestForVersion(\n    Map&lt;String, dynamic&gt; data,\n    String apiVersion,\n  ) {\n    if (VersionConfig.compareVersions(apiVersion, '2.0') &gt;= 0) {\n      return _formatV2Request(data);\n    } else if (VersionConfig.compareVersions(apiVersion, '1.5') &gt;= 0) {\n      return _formatV15Request(data);\n    } else {\n      return _formatV1Request(data);\n    }\n  }\n\n  // Handle version-specific response parsing\n  static Map&lt;String, dynamic&gt; parseResponseForVersion(\n    Map&lt;String, dynamic&gt; response,\n    String apiVersion,\n  ) {\n    if (VersionConfig.compareVersions(apiVersion, '2.0') &gt;= 0) {\n      return _parseV2Response(response);\n    } else if (VersionConfig.compareVersions(apiVersion, '1.5') &gt;= 0) {\n      return _parseV15Response(response);\n    } else {\n      return _parseV1Response(response);\n    }\n  }\n\n  // V2 API format (current)\n  static Map&lt;String, dynamic&gt; _formatV2Request(Map&lt;String, dynamic&gt; data) {\n    return {\n      'data': data,\n      'metadata': {\n        'timestamp': DateTime.now().toIso8601String(),\n        'client_version': VersionConfig.appVersion,\n      },\n    };\n  }\n\n  static Map&lt;String, dynamic&gt; _parseV2Response(Map&lt;String, dynamic&gt; response) {\n    return response['data'] ?? response;\n  }\n\n  // V1.5 API format (legacy)\n  static Map&lt;String, dynamic&gt; _formatV15Request(Map&lt;String, dynamic&gt; data) {\n    return {\n      'payload': data,\n      'timestamp': DateTime.now().millisecondsSinceEpoch,\n    };\n  }\n\n  static Map&lt;String, dynamic&gt; _parseV15Response(Map&lt;String, dynamic&gt; response) {\n    return response['payload'] ?? response;\n  }\n\n  // V1 API format (deprecated)\n  static Map&lt;String, dynamic&gt; _formatV1Request(Map&lt;String, dynamic&gt; data) {\n    return data; // Direct format\n  }\n\n  static Map&lt;String, dynamic&gt; _parseV1Response(Map&lt;String, dynamic&gt; response) {\n    return response;\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#2-backward-compatible-http-client","title":"2. Backward Compatible HTTP Client","text":"<pre><code>// lib/services/legacy_http_client.dart\nclass LegacyHttpClient {\n  final String baseUrl;\n  final String apiVersion;\n  final http.Client _client;\n\n  LegacyHttpClient({\n    required this.baseUrl,\n    required this.apiVersion,\n  }) : _client = http.Client();\n\n  // GET request with version compatibility\n  Future&lt;Map&lt;String, dynamic&gt;&gt; get(String endpoint) async {\n    final url = _buildUrl(endpoint);\n    final headers = _buildHeaders();\n\n    try {\n      final response = await _client.get(url, headers: headers);\n      return _handleResponse(response);\n    } catch (e) {\n      return _handleLegacyFallback(endpoint, 'GET');\n    }\n  }\n\n  // POST request with version compatibility\n  Future&lt;Map&lt;String, dynamic&gt;&gt; post(\n    String endpoint,\n    Map&lt;String, dynamic&gt; data,\n  ) async {\n    final url = _buildUrl(endpoint);\n    final headers = _buildHeaders();\n    final formattedData = ApiVersionService.formatRequestForVersion(data, apiVersion);\n\n    try {\n      final response = await _client.post(\n        url,\n        headers: headers,\n        body: jsonEncode(formattedData),\n      );\n      return _handleResponse(response);\n    } catch (e) {\n      return _handleLegacyFallback(endpoint, 'POST', data);\n    }\n  }\n\n  // Build URL with version-specific endpoint\n  Uri _buildUrl(String endpoint) {\n    final versionedBaseUrl = ApiVersionService.getApiEndpoint(baseUrl, apiVersion);\n    return Uri.parse('$versionedBaseUrl$endpoint');\n  }\n\n  // Build headers with version information\n  Map&lt;String, String&gt; _buildHeaders() {\n    return {\n      'Content-Type': 'application/json',\n      ...ApiVersionService.getVersionHeaders(),\n    };\n  }\n\n  // Handle response with version-specific parsing\n  Map&lt;String, dynamic&gt; _handleResponse(http.Response response) {\n    if (response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300) {\n      final data = jsonDecode(response.body) as Map&lt;String, dynamic&gt;;\n      return ApiVersionService.parseResponseForVersion(data, apiVersion);\n    } else {\n      throw HttpException('Request failed: ${response.statusCode}');\n    }\n  }\n\n  // Fallback to legacy API version\n  Future&lt;Map&lt;String, dynamic&gt;&gt; _handleLegacyFallback(\n    String endpoint,\n    String method, [\n    Map&lt;String, dynamic&gt;? data,\n  ]) async {\n    if (apiVersion == ApiVersionService.minSupportedApiVersion) {\n      throw Exception('All API versions failed');\n    }\n\n    // Try with older API version\n    final legacyClient = LegacyHttpClient(\n      baseUrl: baseUrl,\n      apiVersion: ApiVersionService.minSupportedApiVersion,\n    );\n\n    switch (method) {\n      case 'GET':\n        return await legacyClient.get(endpoint);\n      case 'POST':\n        return await legacyClient.post(endpoint, data!);\n      default:\n        throw Exception('Unsupported method: $method');\n    }\n  }\n\n  void dispose() {\n    _client.close();\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#feature-deprecation-management","title":"Feature Deprecation Management","text":""},{"location":"maintenance/legacy-support/#1-feature-flag-with-deprecation","title":"1. Feature Flag with Deprecation","text":"<pre><code>// lib/services/feature_deprecation_service.dart\nclass FeatureDeprecationService {\n  static const Map&lt;String, DeprecationInfo&gt; _deprecatedFeatures = {\n    'old_camera_ui': DeprecationInfo(\n      deprecatedInVersion: '1.5.0',\n      removedInVersion: '2.0.0',\n      replacementFeature: 'new_camera_ui',\n      migrationGuide: 'Use the new camera interface in settings',\n    ),\n    'legacy_filters': DeprecationInfo(\n      deprecatedInVersion: '1.8.0',\n      removedInVersion: '2.2.0',\n      replacementFeature: 'advanced_filters',\n      migrationGuide: 'Upgrade to advanced filters for better quality',\n    ),\n    'old_sharing_api': DeprecationInfo(\n      deprecatedInVersion: '1.9.0',\n      removedInVersion: '2.1.0',\n      replacementFeature: 'unified_sharing',\n      migrationGuide: 'Use the new unified sharing system',\n    ),\n  };\n\n  // Check if feature is deprecated\n  static bool isFeatureDeprecated(String featureName) {\n    final deprecationInfo = _deprecatedFeatures[featureName];\n    if (deprecationInfo == null) return false;\n\n    return VersionConfig.isVersionGreater(\n      VersionConfig.appVersion,\n      deprecationInfo.deprecatedInVersion,\n    );\n  }\n\n  // Check if feature is removed\n  static bool isFeatureRemoved(String featureName) {\n    final deprecationInfo = _deprecatedFeatures[featureName];\n    if (deprecationInfo == null) return false;\n\n    return VersionConfig.isVersionGreater(\n      VersionConfig.appVersion,\n      deprecationInfo.removedInVersion,\n    );\n  }\n\n  // Get deprecation info\n  static DeprecationInfo? getDeprecationInfo(String featureName) {\n    return _deprecatedFeatures[featureName];\n  }\n\n  // Show deprecation warning\n  static void showDeprecationWarning(\n    BuildContext context,\n    String featureName,\n  ) {\n    final deprecationInfo = _deprecatedFeatures[featureName];\n    if (deprecationInfo == null) return;\n\n    if (isFeatureDeprecated(featureName) &amp;&amp; !isFeatureRemoved(featureName)) {\n      showDialog(\n        context: context,\n        builder: (context) =&gt; DeprecationWarningDialog(\n          featureName: featureName,\n          deprecationInfo: deprecationInfo,\n        ),\n      );\n    }\n  }\n\n  // Track deprecated feature usage\n  static void trackDeprecatedFeatureUsage(String featureName) {\n    final deprecationInfo = _deprecatedFeatures[featureName];\n    if (deprecationInfo == null) return;\n\n    FirebaseAnalytics.instance.logEvent(\n      name: 'deprecated_feature_used',\n      parameters: {\n        'feature_name': featureName,\n        'deprecated_in_version': deprecationInfo.deprecatedInVersion,\n        'removal_version': deprecationInfo.removedInVersion,\n        'current_version': VersionConfig.appVersion,\n      },\n    );\n  }\n}\n\nclass DeprecationInfo {\n  final String deprecatedInVersion;\n  final String removedInVersion;\n  final String replacementFeature;\n  final String migrationGuide;\n\n  const DeprecationInfo({\n    required this.deprecatedInVersion,\n    required this.removedInVersion,\n    required this.replacementFeature,\n    required this.migrationGuide,\n  });\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#2-deprecation-warning-dialog","title":"2. Deprecation Warning Dialog","text":"<pre><code>// lib/widgets/deprecation_warning_dialog.dart\nclass DeprecationWarningDialog extends StatelessWidget {\n  final String featureName;\n  final DeprecationInfo deprecationInfo;\n\n  const DeprecationWarningDialog({\n    Key? key,\n    required this.featureName,\n    required this.deprecationInfo,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return AlertDialog(\n      title: Row(\n        children: [\n          const Icon(Icons.warning, color: Colors.orange),\n          const SizedBox(width: 8),\n          const Expanded(child: Text('Feature Deprecated')),\n        ],\n      ),\n      content: Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            'The feature \"$featureName\" has been deprecated and will be removed in version ${deprecationInfo.removedInVersion}.',\n            style: const TextStyle(fontWeight: FontWeight.bold),\n          ),\n          const SizedBox(height: 12),\n          Text('Replacement: ${deprecationInfo.replacementFeature}'),\n          const SizedBox(height: 8),\n          Text('Migration: ${deprecationInfo.migrationGuide}'),\n          const SizedBox(height: 12),\n          Text(\n            'Please update to the new feature to ensure continued functionality.',\n            style: TextStyle(\n              fontSize: 12,\n              color: Colors.grey[600],\n            ),\n          ),\n        ],\n      ),\n      actions: [\n        TextButton(\n          onPressed: () =&gt; Navigator.of(context).pop(),\n          child: const Text('Continue Anyway'),\n        ),\n        ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).pop();\n            _navigateToReplacement(context);\n          },\n          child: const Text('Use New Feature'),\n        ),\n      ],\n    );\n  }\n\n  void _navigateToReplacement(BuildContext context) {\n    // Navigate to replacement feature\n    switch (deprecationInfo.replacementFeature) {\n      case 'new_camera_ui':\n        Navigator.pushNamed(context, '/camera');\n        break;\n      case 'advanced_filters':\n        Navigator.pushNamed(context, '/filters');\n        break;\n      case 'unified_sharing':\n        Navigator.pushNamed(context, '/share');\n        break;\n    }\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#legacy-data-support","title":"Legacy Data Support","text":""},{"location":"maintenance/legacy-support/#1-legacy-data-adapter","title":"1. Legacy Data Adapter","text":"<pre><code>// lib/adapters/legacy_data_adapter.dart\nclass LegacyDataAdapter {\n  // Convert legacy user data to current format\n  static User adaptLegacyUser(Map&lt;String, dynamic&gt; legacyData) {\n    // Handle different legacy formats\n    if (legacyData.containsKey('user_name')) {\n      // Very old format\n      return User(\n        id: legacyData['user_id']?.toString() ?? '',\n        username: legacyData['user_name'] ?? '',\n        email: legacyData['email_address'] ?? '',\n        displayName: legacyData['display_name'] ?? legacyData['user_name'] ?? '',\n        bio: '', // Not available in legacy format\n        avatarUrl: legacyData['profile_pic'] ?? '',\n        isVerified: false,\n        followerCount: legacyData['followers'] ?? 0,\n        followingCount: legacyData['following'] ?? 0,\n        createdAt: _parseLegacyDate(legacyData['created']),\n      );\n    } else {\n      // Newer legacy format\n      return User(\n        id: legacyData['id']?.toString() ?? '',\n        username: legacyData['username'] ?? '',\n        email: legacyData['email'] ?? '',\n        displayName: legacyData['display_name'] ?? legacyData['username'] ?? '',\n        bio: legacyData['bio'] ?? '',\n        avatarUrl: legacyData['avatar_url'] ?? '',\n        isVerified: legacyData['verified'] == 1 || legacyData['verified'] == true,\n        followerCount: legacyData['follower_count'] ?? 0,\n        followingCount: legacyData['following_count'] ?? 0,\n        createdAt: _parseLegacyDate(legacyData['created_at']),\n      );\n    }\n  }\n\n  // Convert legacy post data to current format\n  static Post adaptLegacyPost(Map&lt;String, dynamic&gt; legacyData) {\n    return Post(\n      id: legacyData['id']?.toString() ?? '',\n      userId: legacyData['user_id']?.toString() ?? '',\n      caption: legacyData['caption'] ?? legacyData['description'] ?? '',\n      imageUrl: legacyData['image_url'] ?? legacyData['photo_url'] ?? '',\n      likeCount: legacyData['like_count'] ?? legacyData['likes'] ?? 0,\n      commentCount: legacyData['comment_count'] ?? legacyData['comments'] ?? 0,\n      createdAt: _parseLegacyDate(legacyData['created_at'] ?? legacyData['timestamp']),\n      updatedAt: _parseLegacyDate(legacyData['updated_at']) ?? DateTime.now(),\n      tags: _parseLegacyTags(legacyData['tags']),\n      location: legacyData['location'],\n    );\n  }\n\n  // Parse legacy date formats\n  static DateTime _parseLegacyDate(dynamic dateValue) {\n    if (dateValue == null) return DateTime.now();\n\n    if (dateValue is String) {\n      // Try different date formats\n      try {\n        return DateTime.parse(dateValue);\n      } catch (e) {\n        try {\n          // Try Unix timestamp as string\n          final timestamp = int.parse(dateValue);\n          return DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\n        } catch (e) {\n          return DateTime.now();\n        }\n      }\n    } else if (dateValue is int) {\n      // Unix timestamp\n      return DateTime.fromMillisecondsSinceEpoch(dateValue * 1000);\n    }\n\n    return DateTime.now();\n  }\n\n  // Parse legacy tags format\n  static List&lt;String&gt; _parseLegacyTags(dynamic tagsValue) {\n    if (tagsValue == null) return [];\n\n    if (tagsValue is String) {\n      // Comma-separated tags\n      return tagsValue.split(',').map((tag) =&gt; tag.trim()).where((tag) =&gt; tag.isNotEmpty).toList();\n    } else if (tagsValue is List) {\n      return tagsValue.map((tag) =&gt; tag.toString()).toList();\n    }\n\n    return [];\n  }\n\n  // Convert current data to legacy format for backward compatibility\n  static Map&lt;String, dynamic&gt; convertToLegacyFormat(\n    Map&lt;String, dynamic&gt; currentData,\n    String targetVersion,\n  ) {\n    if (VersionConfig.compareVersions(targetVersion, '1.5') &lt; 0) {\n      return _convertToV1Format(currentData);\n    } else if (VersionConfig.compareVersions(targetVersion, '2.0') &lt; 0) {\n      return _convertToV15Format(currentData);\n    }\n\n    return currentData;\n  }\n\n  static Map&lt;String, dynamic&gt; _convertToV1Format(Map&lt;String, dynamic&gt; data) {\n    // Convert to very old format\n    return {\n      'user_id': data['id'],\n      'user_name': data['username'],\n      'email_address': data['email'],\n      'display_name': data['display_name'],\n      'profile_pic': data['avatar_url'],\n      'followers': data['follower_count'],\n      'following': data['following_count'],\n      'created': data['created_at'],\n    };\n  }\n\n  static Map&lt;String, dynamic&gt; _convertToV15Format(Map&lt;String, dynamic&gt; data) {\n    // Convert to intermediate format\n    return {\n      'id': data['id'],\n      'username': data['username'],\n      'email': data['email'],\n      'display_name': data['display_name'],\n      'avatar_url': data['avatar_url'],\n      'verified': data['is_verified'] ? 1 : 0,\n      'follower_count': data['follower_count'],\n      'following_count': data['following_count'],\n      'created_at': data['created_at'],\n    };\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#2-legacy-database-support","title":"2. Legacy Database Support","text":"<pre><code>// lib/services/legacy_database_service.dart\nclass LegacyDatabaseService {\n  // Handle legacy database queries\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; queryLegacyData(\n    Database db,\n    String table,\n    String appVersion,\n  ) async {\n    if (VersionConfig.compareVersions(appVersion, '1.5') &lt; 0) {\n      return await _queryV1Format(db, table);\n    } else if (VersionConfig.compareVersions(appVersion, '2.0') &lt; 0) {\n      return await _queryV15Format(db, table);\n    }\n\n    return await db.query(table);\n  }\n\n  // Query data in V1 format\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; _queryV1Format(\n    Database db,\n    String table,\n  ) async {\n    switch (table) {\n      case 'users':\n        final results = await db.query('users');\n        return results.map((row) =&gt; LegacyDataAdapter.convertToLegacyFormat(row, '1.0')).toList();\n\n      case 'posts':\n        final results = await db.rawQuery('''\n          SELECT id, user_id, caption as description, image_url as photo_url,\n                 like_count as likes, comment_count as comments, created_at as timestamp\n          FROM posts\n        ''');\n        return results;\n\n      default:\n        return await db.query(table);\n    }\n  }\n\n  // Query data in V1.5 format\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; _queryV15Format(\n    Database db,\n    String table,\n  ) async {\n    switch (table) {\n      case 'users':\n        final results = await db.query('users');\n        return results.map((row) =&gt; LegacyDataAdapter.convertToLegacyFormat(row, '1.5')).toList();\n\n      default:\n        return await db.query(table);\n    }\n  }\n\n  // Insert data with legacy compatibility\n  static Future&lt;void&gt; insertLegacyData(\n    Database db,\n    String table,\n    Map&lt;String, dynamic&gt; data,\n    String appVersion,\n  ) async {\n    // Convert legacy data to current format before inserting\n    Map&lt;String, dynamic&gt; adaptedData;\n\n    switch (table) {\n      case 'users':\n        final user = LegacyDataAdapter.adaptLegacyUser(data);\n        adaptedData = user.toJson();\n        break;\n\n      case 'posts':\n        final post = LegacyDataAdapter.adaptLegacyPost(data);\n        adaptedData = post.toJson();\n        break;\n\n      default:\n        adaptedData = data;\n    }\n\n    await db.insert(table, adaptedData);\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#legacy-ui-support","title":"Legacy UI Support","text":""},{"location":"maintenance/legacy-support/#1-legacy-theme-support","title":"1. Legacy Theme Support","text":"<pre><code>// lib/themes/legacy_theme_adapter.dart\nclass LegacyThemeAdapter {\n  // Convert legacy theme data to current format\n  static ThemeData adaptLegacyTheme(Map&lt;String, dynamic&gt; legacyThemeData) {\n    final brightness = legacyThemeData['is_dark'] == true ? Brightness.dark : Brightness.light;\n\n    // Handle legacy color format\n    final primaryColor = _parseLegacyColor(legacyThemeData['primary_color']) ?? Colors.blue;\n    final accentColor = _parseLegacyColor(legacyThemeData['accent_color']) ?? Colors.blueAccent;\n\n    return ThemeData(\n      brightness: brightness,\n      primarySwatch: _createMaterialColor(primaryColor),\n      colorScheme: ColorScheme.fromSeed(\n        seedColor: primaryColor,\n        brightness: brightness,\n      ),\n      // Map legacy properties to current theme\n      appBarTheme: AppBarTheme(\n        backgroundColor: primaryColor,\n        foregroundColor: brightness == Brightness.dark ? Colors.white : Colors.black,\n      ),\n      elevatedButtonTheme: ElevatedButtonThemeData(\n        style: ElevatedButton.styleFrom(\n          backgroundColor: accentColor,\n        ),\n      ),\n    );\n  }\n\n  // Parse legacy color format\n  static Color? _parseLegacyColor(dynamic colorValue) {\n    if (colorValue == null) return null;\n\n    if (colorValue is String) {\n      // Handle hex color strings\n      if (colorValue.startsWith('#')) {\n        return Color(int.parse(colorValue.substring(1), radix: 16) + 0xFF000000);\n      }\n\n      // Handle named colors\n      switch (colorValue.toLowerCase()) {\n        case 'blue':\n          return Colors.blue;\n        case 'red':\n          return Colors.red;\n        case 'green':\n          return Colors.green;\n        case 'purple':\n          return Colors.purple;\n        default:\n          return null;\n      }\n    } else if (colorValue is int) {\n      return Color(colorValue);\n    }\n\n    return null;\n  }\n\n  // Create MaterialColor from Color\n  static MaterialColor _createMaterialColor(Color color) {\n    final swatch = &lt;int, Color&gt;{};\n    final int r = color.red;\n    final int g = color.green;\n    final int b = color.blue;\n\n    swatch[50] = Color.fromRGBO(r, g, b, .1);\n    swatch[100] = Color.fromRGBO(r, g, b, .2);\n    swatch[200] = Color.fromRGBO(r, g, b, .3);\n    swatch[300] = Color.fromRGBO(r, g, b, .4);\n    swatch[400] = Color.fromRGBO(r, g, b, .5);\n    swatch[500] = Color.fromRGBO(r, g, b, .6);\n    swatch[600] = Color.fromRGBO(r, g, b, .7);\n    swatch[700] = Color.fromRGBO(r, g, b, .8);\n    swatch[800] = Color.fromRGBO(r, g, b, .9);\n    swatch[900] = Color.fromRGBO(r, g, b, 1);\n\n    return MaterialColor(color.value, swatch);\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#2-legacy-widget-wrapper","title":"2. Legacy Widget Wrapper","text":"<pre><code>// lib/widgets/legacy_widget_wrapper.dart\nclass LegacyWidgetWrapper extends StatelessWidget {\n  final Widget child;\n  final String minSupportedVersion;\n  final Widget? fallbackWidget;\n\n  const LegacyWidgetWrapper({\n    Key? key,\n    required this.child,\n    required this.minSupportedVersion,\n    this.fallbackWidget,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Check if current version supports this widget\n    if (VersionConfig.isVersionCompatible(\n      VersionConfig.appVersion,\n      minSupportedVersion,\n    )) {\n      return child;\n    }\n\n    // Show fallback or empty widget for unsupported versions\n    return fallbackWidget ?? const SizedBox.shrink();\n  }\n}\n\n// Usage example\nclass ExampleLegacySupport extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Always available widget\n        const Text('This is always available'),\n\n        // Widget available from version 1.5+\n        LegacyWidgetWrapper(\n          minSupportedVersion: '1.5.0',\n          child: const NewFeatureWidget(),\n          fallbackWidget: const OldFeatureWidget(),\n        ),\n\n        // Widget available from version 2.0+\n        LegacyWidgetWrapper(\n          minSupportedVersion: '2.0.0',\n          child: const LatestFeatureWidget(),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/legacy-support/#legacy-support-testing","title":"Legacy Support Testing","text":""},{"location":"maintenance/legacy-support/#1-compatibility-test-suite","title":"1. Compatibility Test Suite","text":"<pre><code>// test/legacy_compatibility_test.dart\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('Legacy Compatibility Tests', () {\n    test('Legacy user data adaptation', () {\n      final legacyUserData = {\n        'user_id': '123',\n        'user_name': 'testuser',\n        'email_address': 'test@example.com',\n        'profile_pic': 'https://example.com/pic.jpg',\n        'followers': 100,\n        'following': 50,\n        'created': '2023-01-01T00:00:00Z',\n      };\n\n      final adaptedUser = LegacyDataAdapter.adaptLegacyUser(legacyUserData);\n\n      expect(adaptedUser.id, equals('123'));\n      expect(adaptedUser.username, equals('testuser'));\n      expect(adaptedUser.email, equals('test@example.com'));\n      expect(adaptedUser.avatarUrl, equals('https://example.com/pic.jpg'));\n      expect(adaptedUser.followerCount, equals(100));\n      expect(adaptedUser.followingCount, equals(50));\n    });\n\n    test('API version compatibility', () {\n      expect(ApiVersionService.isApiVersionSupported('2.0'), isTrue);\n      expect(ApiVersionService.isApiVersionSupported('1.5'), isTrue);\n      expect(ApiVersionService.isApiVersionSupported('1.0'), isFalse);\n\n      expect(ApiVersionService.isApiVersionDeprecated('1.0'), isTrue);\n      expect(ApiVersionService.isApiVersionDeprecated('2.0'), isFalse);\n    });\n\n    test('Feature deprecation status', () {\n      expect(FeatureDeprecationService.isFeatureDeprecated('old_camera_ui'), isTrue);\n      expect(FeatureDeprecationService.isFeatureRemoved('old_camera_ui'), isFalse);\n\n      final deprecationInfo = FeatureDeprecationService.getDeprecationInfo('old_camera_ui');\n      expect(deprecationInfo, isNotNull);\n      expect(deprecationInfo!.replacementFeature, equals('new_camera_ui'));\n    });\n  });\n}\n</code></pre> <p>Legacy support is essential for maintaining user experience during app evolution. Implement comprehensive compatibility layers, deprecation strategies, and migration paths to ensure smooth transitions between versions.</p>"},{"location":"maintenance/migrations/","title":"Data Migrations &amp; Schema Updates","text":"<p>Comprehensive guide to managing data migrations, database schema updates, and data transformations in Flutter applications.</p>"},{"location":"maintenance/migrations/#overview","title":"Overview","text":"<p>Data migrations are essential when updating app versions that require changes to local databases, user preferences, or data structures. This guide covers migration strategies, implementation patterns, and best practices.</p>"},{"location":"maintenance/migrations/#database-migrations","title":"Database Migrations","text":""},{"location":"maintenance/migrations/#1-sqlite-migration-framework","title":"1. SQLite Migration Framework","text":"<pre><code>// lib/database/migration_manager.dart\nimport 'package:sqflite/sqflite.dart';\n\nclass MigrationManager {\n  static const int currentVersion = 5;\n  static const String _migrationTableName = 'migrations';\n\n  // Initialize database with migrations\n  static Future&lt;Database&gt; initializeDatabase(String path) async {\n    return await openDatabase(\n      path,\n      version: currentVersion,\n      onCreate: _onCreate,\n      onUpgrade: _onUpgrade,\n      onDowngrade: _onDowngrade,\n    );\n  }\n\n  // Create initial database schema\n  static Future&lt;void&gt; _onCreate(Database db, int version) async {\n    print('Creating database version $version');\n\n    // Create migrations tracking table\n    await _createMigrationsTable(db);\n\n    // Run all migrations up to current version\n    for (int i = 1; i &lt;= version; i++) {\n      await _runMigration(db, i);\n    }\n  }\n\n  // Handle database upgrades\n  static Future&lt;void&gt; _onUpgrade(Database db, int oldVersion, int newVersion) async {\n    print('Upgrading database from version $oldVersion to $newVersion');\n\n    // Ensure migrations table exists\n    await _createMigrationsTable(db);\n\n    // Run migrations for each version increment\n    for (int i = oldVersion + 1; i &lt;= newVersion; i++) {\n      await _runMigration(db, i);\n    }\n  }\n\n  // Handle database downgrades (rarely used)\n  static Future&lt;void&gt; _onDowngrade(Database db, int oldVersion, int newVersion) async {\n    print('Downgrading database from version $oldVersion to $newVersion');\n\n    // Implement downgrade logic if needed\n    // Usually involves dropping tables and recreating\n    await _dropAllTables(db);\n    await _onCreate(db, newVersion);\n  }\n\n  // Create migrations tracking table\n  static Future&lt;void&gt; _createMigrationsTable(Database db) async {\n    await db.execute('''\n      CREATE TABLE IF NOT EXISTS $_migrationTableName (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        version INTEGER UNIQUE NOT NULL,\n        name TEXT NOT NULL,\n        executed_at TEXT NOT NULL\n      )\n    ''');\n  }\n\n  // Run specific migration\n  static Future&lt;void&gt; _runMigration(Database db, int version) async {\n    // Check if migration already executed\n    final result = await db.query(\n      _migrationTableName,\n      where: 'version = ?',\n      whereArgs: [version],\n    );\n\n    if (result.isNotEmpty) {\n      print('Migration $version already executed, skipping');\n      return;\n    }\n\n    final migration = _getMigration(version);\n    if (migration != null) {\n      try {\n        print('Executing migration $version: ${migration.name}');\n        await migration.up(db);\n\n        // Record migration execution\n        await db.insert(_migrationTableName, {\n          'version': version,\n          'name': migration.name,\n          'executed_at': DateTime.now().toIso8601String(),\n        });\n\n        print('Migration $version completed successfully');\n      } catch (e) {\n        print('Migration $version failed: $e');\n        rethrow;\n      }\n    }\n  }\n\n  // Get migration for specific version\n  static Migration? _getMigration(int version) {\n    switch (version) {\n      case 1:\n        return CreateInitialTables();\n      case 2:\n        return AddUserProfileFields();\n      case 3:\n        return CreatePostsTable();\n      case 4:\n        return AddIndexes();\n      case 5:\n        return AddNotificationsTable();\n      default:\n        return null;\n    }\n  }\n\n  // Drop all tables (for downgrade)\n  static Future&lt;void&gt; _dropAllTables(Database db) async {\n    final tables = await db.rawQuery(\n      \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'\"\n    );\n\n    for (final table in tables) {\n      final tableName = table['name'] as String;\n      await db.execute('DROP TABLE IF EXISTS $tableName');\n    }\n  }\n\n  // Get migration history\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getMigrationHistory(Database db) async {\n    try {\n      return await db.query(\n        _migrationTableName,\n        orderBy: 'version ASC',\n      );\n    } catch (e) {\n      return [];\n    }\n  }\n}\n\n// Base migration class\nabstract class Migration {\n  String get name;\n  Future&lt;void&gt; up(Database db);\n  Future&lt;void&gt; down(Database db) async {\n    // Default implementation - override if needed\n    throw UnimplementedError('Downgrade not implemented for $name');\n  }\n}\n</code></pre>"},{"location":"maintenance/migrations/#2-specific-migration-implementations","title":"2. Specific Migration Implementations","text":"<pre><code>// lib/database/migrations/001_create_initial_tables.dart\nclass CreateInitialTables extends Migration {\n  @override\n  String get name =&gt; 'Create initial tables';\n\n  @override\n  Future&lt;void&gt; up(Database db) async {\n    // Create users table\n    await db.execute('''\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        username TEXT UNIQUE NOT NULL,\n        email TEXT UNIQUE NOT NULL,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    ''');\n\n    // Create settings table\n    await db.execute('''\n      CREATE TABLE settings (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        key TEXT UNIQUE NOT NULL,\n        value TEXT,\n        type TEXT NOT NULL DEFAULT 'string'\n      )\n    ''');\n  }\n\n  @override\n  Future&lt;void&gt; down(Database db) async {\n    await db.execute('DROP TABLE IF EXISTS users');\n    await db.execute('DROP TABLE IF EXISTS settings');\n  }\n}\n\n// lib/database/migrations/002_add_user_profile_fields.dart\nclass AddUserProfileFields extends Migration {\n  @override\n  String get name =&gt; 'Add user profile fields';\n\n  @override\n  Future&lt;void&gt; up(Database db) async {\n    await db.execute('ALTER TABLE users ADD COLUMN bio TEXT');\n    await db.execute('ALTER TABLE users ADD COLUMN avatar_url TEXT');\n    await db.execute('ALTER TABLE users ADD COLUMN is_verified INTEGER DEFAULT 0');\n    await db.execute('ALTER TABLE users ADD COLUMN follower_count INTEGER DEFAULT 0');\n    await db.execute('ALTER TABLE users ADD COLUMN following_count INTEGER DEFAULT 0');\n  }\n\n  @override\n  Future&lt;void&gt; down(Database db) async {\n    // SQLite doesn't support DROP COLUMN, so we need to recreate the table\n    await db.execute('''\n      CREATE TABLE users_backup AS \n      SELECT id, username, email, created_at, updated_at \n      FROM users\n    ''');\n\n    await db.execute('DROP TABLE users');\n\n    await db.execute('''\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        username TEXT UNIQUE NOT NULL,\n        email TEXT UNIQUE NOT NULL,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    ''');\n\n    await db.execute('INSERT INTO users SELECT * FROM users_backup');\n    await db.execute('DROP TABLE users_backup');\n  }\n}\n\n// lib/database/migrations/003_create_posts_table.dart\nclass CreatePostsTable extends Migration {\n  @override\n  String get name =&gt; 'Create posts table';\n\n  @override\n  Future&lt;void&gt; up(Database db) async {\n    await db.execute('''\n      CREATE TABLE posts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER NOT NULL,\n        caption TEXT,\n        image_url TEXT NOT NULL,\n        like_count INTEGER DEFAULT 0,\n        comment_count INTEGER DEFAULT 0,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL,\n        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n      )\n    ''');\n\n    // Create comments table\n    await db.execute('''\n      CREATE TABLE comments (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        post_id INTEGER NOT NULL,\n        user_id INTEGER NOT NULL,\n        content TEXT NOT NULL,\n        created_at TEXT NOT NULL,\n        FOREIGN KEY (post_id) REFERENCES posts (id) ON DELETE CASCADE,\n        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n      )\n    ''');\n\n    // Create likes table\n    await db.execute('''\n      CREATE TABLE likes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        post_id INTEGER NOT NULL,\n        user_id INTEGER NOT NULL,\n        created_at TEXT NOT NULL,\n        UNIQUE(post_id, user_id),\n        FOREIGN KEY (post_id) REFERENCES posts (id) ON DELETE CASCADE,\n        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n      )\n    ''');\n  }\n\n  @override\n  Future&lt;void&gt; down(Database db) async {\n    await db.execute('DROP TABLE IF EXISTS likes');\n    await db.execute('DROP TABLE IF EXISTS comments');\n    await db.execute('DROP TABLE IF EXISTS posts');\n  }\n}\n\n// lib/database/migrations/004_add_indexes.dart\nclass AddIndexes extends Migration {\n  @override\n  String get name =&gt; 'Add database indexes for performance';\n\n  @override\n  Future&lt;void&gt; up(Database db) async {\n    // User indexes\n    await db.execute('CREATE INDEX idx_users_username ON users(username)');\n    await db.execute('CREATE INDEX idx_users_email ON users(email)');\n\n    // Post indexes\n    await db.execute('CREATE INDEX idx_posts_user_id ON posts(user_id)');\n    await db.execute('CREATE INDEX idx_posts_created_at ON posts(created_at)');\n\n    // Comment indexes\n    await db.execute('CREATE INDEX idx_comments_post_id ON comments(post_id)');\n    await db.execute('CREATE INDEX idx_comments_user_id ON comments(user_id)');\n\n    // Like indexes\n    await db.execute('CREATE INDEX idx_likes_post_id ON likes(post_id)');\n    await db.execute('CREATE INDEX idx_likes_user_id ON likes(user_id)');\n  }\n\n  @override\n  Future&lt;void&gt; down(Database db) async {\n    await db.execute('DROP INDEX IF EXISTS idx_users_username');\n    await db.execute('DROP INDEX IF EXISTS idx_users_email');\n    await db.execute('DROP INDEX IF EXISTS idx_posts_user_id');\n    await db.execute('DROP INDEX IF EXISTS idx_posts_created_at');\n    await db.execute('DROP INDEX IF EXISTS idx_comments_post_id');\n    await db.execute('DROP INDEX IF EXISTS idx_comments_user_id');\n    await db.execute('DROP INDEX IF EXISTS idx_likes_post_id');\n    await db.execute('DROP INDEX IF EXISTS idx_likes_user_id');\n  }\n}\n\n// lib/database/migrations/005_add_notifications_table.dart\nclass AddNotificationsTable extends Migration {\n  @override\n  String get name =&gt; 'Add notifications table';\n\n  @override\n  Future&lt;void&gt; up(Database db) async {\n    await db.execute('''\n      CREATE TABLE notifications (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER NOT NULL,\n        type TEXT NOT NULL,\n        title TEXT NOT NULL,\n        message TEXT NOT NULL,\n        data TEXT,\n        is_read INTEGER DEFAULT 0,\n        created_at TEXT NOT NULL,\n        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE\n      )\n    ''');\n\n    await db.execute('CREATE INDEX idx_notifications_user_id ON notifications(user_id)');\n    await db.execute('CREATE INDEX idx_notifications_is_read ON notifications(is_read)');\n    await db.execute('CREATE INDEX idx_notifications_created_at ON notifications(created_at)');\n  }\n\n  @override\n  Future&lt;void&gt; down(Database db) async {\n    await db.execute('DROP TABLE IF EXISTS notifications');\n  }\n}\n</code></pre>"},{"location":"maintenance/migrations/#data-transformation-migrations","title":"Data Transformation Migrations","text":""},{"location":"maintenance/migrations/#1-data-migration-service","title":"1. Data Migration Service","text":"<pre><code>// lib/services/data_migration_service.dart\nclass DataMigrationService {\n  static const String _dataMigrationKey = 'data_migration_version';\n  static const int currentDataVersion = 3;\n\n  // Run data migrations if needed\n  static Future&lt;void&gt; runDataMigrationsIfNeeded() async {\n    final prefs = await SharedPreferences.getInstance();\n    final lastDataVersion = prefs.getInt(_dataMigrationKey) ?? 0;\n\n    if (lastDataVersion &lt; currentDataVersion) {\n      await _runDataMigrations(lastDataVersion, currentDataVersion);\n      await prefs.setInt(_dataMigrationKey, currentDataVersion);\n    }\n  }\n\n  // Run specific data migrations\n  static Future&lt;void&gt; _runDataMigrations(int fromVersion, int toVersion) async {\n    print('Running data migrations from version $fromVersion to $toVersion');\n\n    for (int version = fromVersion + 1; version &lt;= toVersion; version++) {\n      await _runDataMigration(version);\n    }\n  }\n\n  // Run specific data migration\n  static Future&lt;void&gt; _runDataMigration(int version) async {\n    switch (version) {\n      case 1:\n        await _migrateUserPreferences();\n        break;\n      case 2:\n        await _migrateCachedImages();\n        break;\n      case 3:\n        await _migrateNotificationSettings();\n        break;\n    }\n  }\n\n  // Migrate user preferences format\n  static Future&lt;void&gt; _migrateUserPreferences() async {\n    print('Migrating user preferences to new format');\n\n    final prefs = await SharedPreferences.getInstance();\n\n    // Migrate theme setting\n    final oldTheme = prefs.getString('theme');\n    if (oldTheme != null) {\n      final newThemeMode = oldTheme == 'dark' ? 'dark' : 'light';\n      await prefs.setString('theme_mode', newThemeMode);\n      await prefs.remove('theme');\n    }\n\n    // Migrate notification settings\n    final oldNotifications = prefs.getBool('notifications');\n    if (oldNotifications != null) {\n      await prefs.setBool('notifications_enabled', oldNotifications);\n      await prefs.setBool('push_notifications_enabled', oldNotifications);\n      await prefs.remove('notifications');\n    }\n\n    // Set default values for new settings\n    if (!prefs.containsKey('auto_play_videos')) {\n      await prefs.setBool('auto_play_videos', true);\n    }\n  }\n\n  // Migrate cached images to new storage format\n  static Future&lt;void&gt; _migrateCachedImages() async {\n    print('Migrating cached images to new storage format');\n\n    try {\n      final appDir = await getApplicationDocumentsDirectory();\n      final oldCacheDir = Directory('${appDir.path}/cache');\n      final newCacheDir = Directory('${appDir.path}/image_cache');\n\n      if (await oldCacheDir.exists()) {\n        // Create new cache directory\n        await newCacheDir.create(recursive: true);\n\n        // Move files to new location with new naming convention\n        await for (final file in oldCacheDir.list()) {\n          if (file is File) {\n            final fileName = path.basename(file.path);\n            final newPath = '${newCacheDir.path}/${_generateNewFileName(fileName)}';\n            await file.copy(newPath);\n          }\n        }\n\n        // Delete old cache directory\n        await oldCacheDir.delete(recursive: true);\n      }\n    } catch (e) {\n      print('Error migrating cached images: $e');\n    }\n  }\n\n  // Migrate notification settings to new structure\n  static Future&lt;void&gt; _migrateNotificationSettings() async {\n    print('Migrating notification settings to new structure');\n\n    final prefs = await SharedPreferences.getInstance();\n\n    // Create new notification settings structure\n    final notificationSettings = {\n      'likes': prefs.getBool('notify_likes') ?? true,\n      'comments': prefs.getBool('notify_comments') ?? true,\n      'follows': prefs.getBool('notify_follows') ?? true,\n      'mentions': prefs.getBool('notify_mentions') ?? true,\n      'direct_messages': prefs.getBool('notify_messages') ?? true,\n    };\n\n    // Save new structure\n    for (final entry in notificationSettings.entries) {\n      await prefs.setBool('notification_${entry.key}', entry.value);\n    }\n\n    // Remove old keys\n    await prefs.remove('notify_likes');\n    await prefs.remove('notify_comments');\n    await prefs.remove('notify_follows');\n    await prefs.remove('notify_mentions');\n    await prefs.remove('notify_messages');\n  }\n\n  static String _generateNewFileName(String oldFileName) {\n    // Generate new file name with timestamp and hash\n    final timestamp = DateTime.now().millisecondsSinceEpoch;\n    final hash = oldFileName.hashCode.abs();\n    final extension = path.extension(oldFileName);\n    return '${timestamp}_$hash$extension';\n  }\n}\n</code></pre>"},{"location":"maintenance/migrations/#2-backup-and-recovery","title":"2. Backup and Recovery","text":"<pre><code>// lib/services/backup_service.dart\nclass BackupService {\n  // Create backup before migration\n  static Future&lt;String&gt; createBackup() async {\n    final appDir = await getApplicationDocumentsDirectory();\n    final backupDir = Directory('${appDir.path}/backups');\n    await backupDir.create(recursive: true);\n\n    final timestamp = DateTime.now().millisecondsSinceEpoch;\n    final backupPath = '${backupDir.path}/backup_$timestamp.json';\n\n    final backupData = await _collectBackupData();\n    final backupFile = File(backupPath);\n    await backupFile.writeAsString(jsonEncode(backupData));\n\n    print('Backup created at: $backupPath');\n    return backupPath;\n  }\n\n  // Collect all data for backup\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; _collectBackupData() async {\n    final prefs = await SharedPreferences.getInstance();\n    final db = await DatabaseService.database;\n\n    return {\n      'version': VersionConfig.appVersion,\n      'timestamp': DateTime.now().toIso8601String(),\n      'preferences': prefs.getKeys().fold&lt;Map&lt;String, dynamic&gt;&gt;({}, (map, key) {\n        final value = prefs.get(key);\n        if (value != null) {\n          map[key] = value;\n        }\n        return map;\n      }),\n      'database': await _exportDatabaseData(db),\n    };\n  }\n\n  // Export database data\n  static Future&lt;Map&lt;String, List&lt;Map&lt;String, dynamic&gt;&gt;&gt;&gt; _exportDatabaseData(Database db) async {\n    final tables = ['users', 'posts', 'comments', 'likes', 'notifications'];\n    final data = &lt;String, List&lt;Map&lt;String, dynamic&gt;&gt;&gt;{};\n\n    for (final table in tables) {\n      try {\n        data[table] = await db.query(table);\n      } catch (e) {\n        print('Error exporting table $table: $e');\n        data[table] = [];\n      }\n    }\n\n    return data;\n  }\n\n  // Restore from backup\n  static Future&lt;void&gt; restoreFromBackup(String backupPath) async {\n    try {\n      final backupFile = File(backupPath);\n      if (!await backupFile.exists()) {\n        throw Exception('Backup file not found: $backupPath');\n      }\n\n      final backupContent = await backupFile.readAsString();\n      final backupData = jsonDecode(backupContent) as Map&lt;String, dynamic&gt;;\n\n      await _restorePreferences(backupData['preferences']);\n      await _restoreDatabaseData(backupData['database']);\n\n      print('Backup restored successfully from: $backupPath');\n    } catch (e) {\n      print('Error restoring backup: $e');\n      rethrow;\n    }\n  }\n\n  // Restore preferences\n  static Future&lt;void&gt; _restorePreferences(Map&lt;String, dynamic&gt; preferences) async {\n    final prefs = await SharedPreferences.getInstance();\n\n    for (final entry in preferences.entries) {\n      final value = entry.value;\n      if (value is String) {\n        await prefs.setString(entry.key, value);\n      } else if (value is bool) {\n        await prefs.setBool(entry.key, value);\n      } else if (value is int) {\n        await prefs.setInt(entry.key, value);\n      } else if (value is double) {\n        await prefs.setDouble(entry.key, value);\n      } else if (value is List&lt;String&gt;) {\n        await prefs.setStringList(entry.key, value);\n      }\n    }\n  }\n\n  // Restore database data\n  static Future&lt;void&gt; _restoreDatabaseData(Map&lt;String, dynamic&gt; databaseData) async {\n    final db = await DatabaseService.database;\n\n    // Clear existing data\n    await db.transaction((txn) async {\n      for (final table in databaseData.keys) {\n        await txn.delete(table);\n      }\n    });\n\n    // Restore data\n    await db.transaction((txn) async {\n      for (final entry in databaseData.entries) {\n        final table = entry.key;\n        final rows = entry.value as List&lt;dynamic&gt;;\n\n        for (final row in rows) {\n          await txn.insert(table, row as Map&lt;String, dynamic&gt;);\n        }\n      }\n    });\n  }\n\n  // Clean old backups\n  static Future&lt;void&gt; cleanOldBackups({int keepCount = 5}) async {\n    try {\n      final appDir = await getApplicationDocumentsDirectory();\n      final backupDir = Directory('${appDir.path}/backups');\n\n      if (!await backupDir.exists()) return;\n\n      final backupFiles = await backupDir\n          .list()\n          .where((entity) =&gt; entity is File &amp;&amp; entity.path.endsWith('.json'))\n          .cast&lt;File&gt;()\n          .toList();\n\n      // Sort by modification time (newest first)\n      backupFiles.sort((a, b) =&gt; b.lastModifiedSync().compareTo(a.lastModifiedSync()));\n\n      // Delete old backups\n      if (backupFiles.length &gt; keepCount) {\n        for (int i = keepCount; i &lt; backupFiles.length; i++) {\n          await backupFiles[i].delete();\n          print('Deleted old backup: ${backupFiles[i].path}');\n        }\n      }\n    } catch (e) {\n      print('Error cleaning old backups: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"maintenance/migrations/#migration-testing","title":"Migration Testing","text":""},{"location":"maintenance/migrations/#1-migration-test-framework","title":"1. Migration Test Framework","text":"<pre><code>// test/migration_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:sqflite_common_ffi/sqflite_ffi.dart';\n\nclass MigrationTestHelper {\n  static Future&lt;Database&gt; createTestDatabase() async {\n    sqfliteFfiInit();\n    return await databaseFactoryFfi.openDatabase(\n      inMemoryDatabasePath,\n      options: OpenDatabaseOptions(\n        version: 1,\n        onCreate: (db, version) async {\n          // Create initial schema for testing\n        },\n      ),\n    );\n  }\n\n  static Future&lt;void&gt; testMigration({\n    required Migration migration,\n    required Future&lt;void&gt; Function(Database) setupData,\n    required Future&lt;void&gt; Function(Database) verifyResult,\n  }) async {\n    final db = await createTestDatabase();\n\n    try {\n      // Setup test data\n      await setupData(db);\n\n      // Run migration\n      await migration.up(db);\n\n      // Verify result\n      await verifyResult(db);\n    } finally {\n      await db.close();\n    }\n  }\n}\n\nvoid main() {\n  group('Database Migrations', () {\n    test('Migration 002: Add user profile fields', () async {\n      await MigrationTestHelper.testMigration(\n        migration: AddUserProfileFields(),\n        setupData: (db) async {\n          // Create users table with initial schema\n          await db.execute('''\n            CREATE TABLE users (\n              id INTEGER PRIMARY KEY AUTOINCREMENT,\n              username TEXT UNIQUE NOT NULL,\n              email TEXT UNIQUE NOT NULL,\n              created_at TEXT NOT NULL,\n              updated_at TEXT NOT NULL\n            )\n          ''');\n\n          // Insert test data\n          await db.insert('users', {\n            'username': 'testuser',\n            'email': 'test@example.com',\n            'created_at': DateTime.now().toIso8601String(),\n            'updated_at': DateTime.now().toIso8601String(),\n          });\n        },\n        verifyResult: (db) async {\n          // Verify new columns exist\n          final result = await db.rawQuery('PRAGMA table_info(users)');\n          final columnNames = result.map((row) =&gt; row['name']).toList();\n\n          expect(columnNames, contains('bio'));\n          expect(columnNames, contains('avatar_url'));\n          expect(columnNames, contains('is_verified'));\n          expect(columnNames, contains('follower_count'));\n          expect(columnNames, contains('following_count'));\n\n          // Verify existing data is preserved\n          final users = await db.query('users');\n          expect(users.length, equals(1));\n          expect(users.first['username'], equals('testuser'));\n        },\n      );\n    });\n\n    test('Migration rollback', () async {\n      final db = await MigrationTestHelper.createTestDatabase();\n\n      try {\n        // Setup initial state\n        await CreateInitialTables().up(db);\n        await AddUserProfileFields().up(db);\n\n        // Verify migration applied\n        var result = await db.rawQuery('PRAGMA table_info(users)');\n        var columnNames = result.map((row) =&gt; row['name']).toList();\n        expect(columnNames, contains('bio'));\n\n        // Rollback migration\n        await AddUserProfileFields().down(db);\n\n        // Verify rollback\n        result = await db.rawQuery('PRAGMA table_info(users)');\n        columnNames = result.map((row) =&gt; row['name']).toList();\n        expect(columnNames, isNot(contains('bio')));\n      } finally {\n        await db.close();\n      }\n    });\n  });\n}\n</code></pre>"},{"location":"maintenance/migrations/#2-migration-validation","title":"2. Migration Validation","text":"<pre><code>// lib/utils/migration_validator.dart\nclass MigrationValidator {\n  // Validate database schema\n  static Future&lt;bool&gt; validateSchema(Database db) async {\n    try {\n      // Check required tables exist\n      final requiredTables = ['users', 'posts', 'comments', 'likes', 'notifications'];\n\n      for (final table in requiredTables) {\n        final result = await db.rawQuery(\n          \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n          [table],\n        );\n\n        if (result.isEmpty) {\n          print('Missing required table: $table');\n          return false;\n        }\n      }\n\n      // Check required indexes exist\n      final requiredIndexes = [\n        'idx_users_username',\n        'idx_posts_user_id',\n        'idx_comments_post_id',\n      ];\n\n      for (final index in requiredIndexes) {\n        final result = await db.rawQuery(\n          \"SELECT name FROM sqlite_master WHERE type='index' AND name=?\",\n          [index],\n        );\n\n        if (result.isEmpty) {\n          print('Missing required index: $index');\n          return false;\n        }\n      }\n\n      return true;\n    } catch (e) {\n      print('Schema validation error: $e');\n      return false;\n    }\n  }\n\n  // Validate data integrity\n  static Future&lt;bool&gt; validateDataIntegrity(Database db) async {\n    try {\n      // Check foreign key constraints\n      final orphanedPosts = await db.rawQuery('''\n        SELECT COUNT(*) as count FROM posts \n        WHERE user_id NOT IN (SELECT id FROM users)\n      ''');\n\n      if ((orphanedPosts.first['count'] as int) &gt; 0) {\n        print('Found orphaned posts');\n        return false;\n      }\n\n      // Check data consistency\n      final postCounts = await db.rawQuery('''\n        SELECT p.id, p.like_count, COUNT(l.id) as actual_likes\n        FROM posts p\n        LEFT JOIN likes l ON p.id = l.post_id\n        GROUP BY p.id\n        HAVING p.like_count != actual_likes\n      ''');\n\n      if (postCounts.isNotEmpty) {\n        print('Found inconsistent like counts');\n        return false;\n      }\n\n      return true;\n    } catch (e) {\n      print('Data integrity validation error: $e');\n      return false;\n    }\n  }\n}\n</code></pre> <p>Data migrations are critical for maintaining app functionality across versions. Implement comprehensive migration strategies, backup mechanisms, and validation processes to ensure data integrity during updates.</p>"},{"location":"maintenance/version-management/","title":"Version Management","text":"<p>Comprehensive guide to managing versions, releases, and updates in Flutter applications.</p>"},{"location":"maintenance/version-management/#overview","title":"Overview","text":"<p>Version management involves tracking app versions, managing releases, handling updates, and maintaining backward compatibility. This guide covers semantic versioning, release strategies, and update mechanisms.</p>"},{"location":"maintenance/version-management/#semantic-versioning","title":"Semantic Versioning","text":""},{"location":"maintenance/version-management/#1-version-number-structure","title":"1. Version Number Structure","text":"<pre><code># pubspec.yaml\nname: yourapp\ndescription: A Flutter Instagram clone application\nversion: 1.2.3+45\n\n# Format: MAJOR.MINOR.PATCH+BUILD_NUMBER\n# 1 = Major version (breaking changes)\n# 2 = Minor version (new features, backward compatible)\n# 3 = Patch version (bug fixes, backward compatible)\n# 45 = Build number (incremental for each build)\n</code></pre>"},{"location":"maintenance/version-management/#2-version-configuration","title":"2. Version Configuration","text":"<pre><code>// lib/config/version_config.dart\nclass VersionConfig {\n  static const String appVersion = String.fromEnvironment(\n    'APP_VERSION',\n    defaultValue: '1.0.0',\n  );\n\n  static const int buildNumber = int.fromEnvironment(\n    'BUILD_NUMBER',\n    defaultValue: 1,\n  );\n\n  static const String buildDate = String.fromEnvironment(\n    'BUILD_DATE',\n    defaultValue: '',\n  );\n\n  static const String gitCommit = String.fromEnvironment(\n    'GIT_COMMIT',\n    defaultValue: '',\n  );\n\n  static const String buildEnvironment = String.fromEnvironment(\n    'BUILD_ENVIRONMENT',\n    defaultValue: 'development',\n  );\n\n  // Computed properties\n  static String get fullVersion =&gt; '$appVersion+$buildNumber';\n  static bool get isProduction =&gt; buildEnvironment == 'production';\n  static bool get isDevelopment =&gt; buildEnvironment == 'development';\n\n  // Version comparison\n  static int compareVersions(String version1, String version2) {\n    final v1Parts = version1.split('.').map(int.parse).toList();\n    final v2Parts = version2.split('.').map(int.parse).toList();\n\n    for (int i = 0; i &lt; 3; i++) {\n      final v1Part = i &lt; v1Parts.length ? v1Parts[i] : 0;\n      final v2Part = i &lt; v2Parts.length ? v2Parts[i] : 0;\n\n      if (v1Part &lt; v2Part) return -1;\n      if (v1Part &gt; v2Part) return 1;\n    }\n\n    return 0;\n  }\n\n  static bool isVersionGreater(String version1, String version2) {\n    return compareVersions(version1, version2) &gt; 0;\n  }\n\n  static bool isVersionCompatible(String currentVersion, String minVersion) {\n    return compareVersions(currentVersion, minVersion) &gt;= 0;\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#release-management","title":"Release Management","text":""},{"location":"maintenance/version-management/#1-release-strategy","title":"1. Release Strategy","text":"<pre><code>// lib/services/release_service.dart\nclass ReleaseService {\n  static const String _releaseNotesKey = 'release_notes';\n  static const String _lastVersionKey = 'last_version';\n\n  // Check if this is a new version\n  static Future&lt;bool&gt; isNewVersion() async {\n    final prefs = await SharedPreferences.getInstance();\n    final lastVersion = prefs.getString(_lastVersionKey);\n    final currentVersion = VersionConfig.appVersion;\n\n    if (lastVersion == null || lastVersion != currentVersion) {\n      await prefs.setString(_lastVersionKey, currentVersion);\n      return true;\n    }\n\n    return false;\n  }\n\n  // Get release notes for version\n  static Future&lt;ReleaseNotes?&gt; getReleaseNotes(String version) async {\n    try {\n      // This could fetch from API or local storage\n      final response = await http.get(\n        Uri.parse('https://api.yourapp.com/releases/$version'),\n      );\n\n      if (response.statusCode == 200) {\n        final data = jsonDecode(response.body);\n        return ReleaseNotes.fromJson(data);\n      }\n    } catch (e) {\n      print('Failed to fetch release notes: $e');\n    }\n\n    return null;\n  }\n\n  // Show release notes if new version\n  static Future&lt;void&gt; showReleaseNotesIfNeeded(BuildContext context) async {\n    if (await isNewVersion()) {\n      final releaseNotes = await getReleaseNotes(VersionConfig.appVersion);\n\n      if (releaseNotes != null &amp;&amp; context.mounted) {\n        await showDialog(\n          context: context,\n          builder: (context) =&gt; ReleaseNotesDialog(releaseNotes: releaseNotes),\n        );\n      }\n    }\n  }\n\n  // Track version usage\n  static void trackVersionUsage() {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'app_version_usage',\n      parameters: {\n        'app_version': VersionConfig.appVersion,\n        'build_number': VersionConfig.buildNumber,\n        'build_environment': VersionConfig.buildEnvironment,\n        'platform': Platform.operatingSystem,\n      },\n    );\n  }\n}\n\nclass ReleaseNotes {\n  final String version;\n  final String title;\n  final String description;\n  final List&lt;String&gt; features;\n  final List&lt;String&gt; bugFixes;\n  final List&lt;String&gt; improvements;\n  final DateTime releaseDate;\n  final bool isRequired;\n\n  ReleaseNotes({\n    required this.version,\n    required this.title,\n    required this.description,\n    required this.features,\n    required this.bugFixes,\n    required this.improvements,\n    required this.releaseDate,\n    required this.isRequired,\n  });\n\n  factory ReleaseNotes.fromJson(Map&lt;String, dynamic&gt; json) {\n    return ReleaseNotes(\n      version: json['version'],\n      title: json['title'],\n      description: json['description'],\n      features: List&lt;String&gt;.from(json['features'] ?? []),\n      bugFixes: List&lt;String&gt;.from(json['bug_fixes'] ?? []),\n      improvements: List&lt;String&gt;.from(json['improvements'] ?? []),\n      releaseDate: DateTime.parse(json['release_date']),\n      isRequired: json['is_required'] ?? false,\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#2-release-notes-dialog","title":"2. Release Notes Dialog","text":"<pre><code>// lib/widgets/release_notes_dialog.dart\nclass ReleaseNotesDialog extends StatelessWidget {\n  final ReleaseNotes releaseNotes;\n\n  const ReleaseNotesDialog({\n    Key? key,\n    required this.releaseNotes,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return AlertDialog(\n      title: Row(\n        children: [\n          const Icon(Icons.new_releases, color: Colors.blue),\n          const SizedBox(width: 8),\n          Expanded(\n            child: Text(\n              'What\\'s New in ${releaseNotes.version}',\n              style: const TextStyle(fontSize: 18),\n            ),\n          ),\n        ],\n      ),\n      content: SizedBox(\n        width: double.maxFinite,\n        child: SingleChildScrollView(\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              Text(\n                releaseNotes.title,\n                style: const TextStyle(\n                  fontSize: 16,\n                  fontWeight: FontWeight.bold,\n                ),\n              ),\n              const SizedBox(height: 8),\n              Text(releaseNotes.description),\n              const SizedBox(height: 16),\n\n              if (releaseNotes.features.isNotEmpty) ...[\n                _buildSection('\u2728 New Features', releaseNotes.features),\n                const SizedBox(height: 12),\n              ],\n\n              if (releaseNotes.improvements.isNotEmpty) ...[\n                _buildSection('\ud83d\ude80 Improvements', releaseNotes.improvements),\n                const SizedBox(height: 12),\n              ],\n\n              if (releaseNotes.bugFixes.isNotEmpty) ...[\n                _buildSection('\ud83d\udc1b Bug Fixes', releaseNotes.bugFixes),\n                const SizedBox(height: 12),\n              ],\n\n              Text(\n                'Released on ${DateFormat('MMM dd, yyyy').format(releaseNotes.releaseDate)}',\n                style: TextStyle(\n                  fontSize: 12,\n                  color: Colors.grey[600],\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n      actions: [\n        TextButton(\n          onPressed: () =&gt; Navigator.of(context).pop(),\n          child: const Text('Got it!'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildSection(String title, List&lt;String&gt; items) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          title,\n          style: const TextStyle(\n            fontSize: 14,\n            fontWeight: FontWeight.bold,\n          ),\n        ),\n        const SizedBox(height: 4),\n        ...items.map((item) =&gt; Padding(\n          padding: const EdgeInsets.only(left: 8, bottom: 2),\n          child: Row(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              const Text('\u2022 ', style: TextStyle(fontSize: 12)),\n              Expanded(\n                child: Text(\n                  item,\n                  style: const TextStyle(fontSize: 12),\n                ),\n              ),\n            ],\n          ),\n        )).toList(),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#app-update-management","title":"App Update Management","text":""},{"location":"maintenance/version-management/#1-update-checker-service","title":"1. Update Checker Service","text":"<pre><code>// lib/services/update_checker_service.dart\nclass UpdateCheckerService {\n  static const String _lastUpdateCheckKey = 'last_update_check';\n  static const Duration _checkInterval = Duration(hours: 24);\n\n  // Check for app updates\n  static Future&lt;UpdateInfo?&gt; checkForUpdates() async {\n    try {\n      final response = await http.get(\n        Uri.parse('https://api.yourapp.com/app/version-info'),\n      );\n\n      if (response.statusCode == 200) {\n        final data = jsonDecode(response.body);\n        final updateInfo = UpdateInfo.fromJson(data);\n\n        // Check if update is available\n        if (VersionConfig.isVersionGreater(\n          updateInfo.latestVersion,\n          VersionConfig.appVersion,\n        )) {\n          return updateInfo;\n        }\n      }\n    } catch (e) {\n      print('Failed to check for updates: $e');\n    }\n\n    return null;\n  }\n\n  // Check if should check for updates\n  static Future&lt;bool&gt; shouldCheckForUpdates() async {\n    final prefs = await SharedPreferences.getInstance();\n    final lastCheck = prefs.getInt(_lastUpdateCheckKey);\n\n    if (lastCheck == null) return true;\n\n    final lastCheckTime = DateTime.fromMillisecondsSinceEpoch(lastCheck);\n    final now = DateTime.now();\n\n    return now.difference(lastCheckTime) &gt; _checkInterval;\n  }\n\n  // Mark update check as done\n  static Future&lt;void&gt; markUpdateCheckDone() async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setInt(_lastUpdateCheckKey, DateTime.now().millisecondsSinceEpoch);\n  }\n\n  // Check and show update dialog if needed\n  static Future&lt;void&gt; checkAndShowUpdateDialog(BuildContext context) async {\n    if (!await shouldCheckForUpdates()) return;\n\n    final updateInfo = await checkForUpdates();\n    await markUpdateCheckDone();\n\n    if (updateInfo != null &amp;&amp; context.mounted) {\n      await showDialog(\n        context: context,\n        barrierDismissible: !updateInfo.isRequired,\n        builder: (context) =&gt; UpdateDialog(updateInfo: updateInfo),\n      );\n    }\n  }\n\n  // Force update check\n  static Future&lt;UpdateInfo?&gt; forceUpdateCheck() async {\n    return await checkForUpdates();\n  }\n}\n\nclass UpdateInfo {\n  final String latestVersion;\n  final String title;\n  final String description;\n  final List&lt;String&gt; features;\n  final bool isRequired;\n  final String downloadUrl;\n  final DateTime releaseDate;\n  final String minSupportedVersion;\n\n  UpdateInfo({\n    required this.latestVersion,\n    required this.title,\n    required this.description,\n    required this.features,\n    required this.isRequired,\n    required this.downloadUrl,\n    required this.releaseDate,\n    required this.minSupportedVersion,\n  });\n\n  factory UpdateInfo.fromJson(Map&lt;String, dynamic&gt; json) {\n    return UpdateInfo(\n      latestVersion: json['latest_version'],\n      title: json['title'],\n      description: json['description'],\n      features: List&lt;String&gt;.from(json['features'] ?? []),\n      isRequired: json['is_required'] ?? false,\n      downloadUrl: json['download_url'],\n      releaseDate: DateTime.parse(json['release_date']),\n      minSupportedVersion: json['min_supported_version'],\n    );\n  }\n\n  bool get isCurrentVersionSupported {\n    return VersionConfig.isVersionCompatible(\n      VersionConfig.appVersion,\n      minSupportedVersion,\n    );\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#2-update-dialog","title":"2. Update Dialog","text":"<pre><code>// lib/widgets/update_dialog.dart\nclass UpdateDialog extends StatelessWidget {\n  final UpdateInfo updateInfo;\n\n  const UpdateDialog({\n    Key? key,\n    required this.updateInfo,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return WillPopScope(\n      onWillPop: () async =&gt; !updateInfo.isRequired,\n      child: AlertDialog(\n        title: Row(\n          children: [\n            Icon(\n              updateInfo.isRequired ? Icons.warning : Icons.system_update,\n              color: updateInfo.isRequired ? Colors.orange : Colors.blue,\n            ),\n            const SizedBox(width: 8),\n            Expanded(\n              child: Text(\n                updateInfo.isRequired ? 'Update Required' : 'Update Available',\n              ),\n            ),\n          ],\n        ),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(\n              updateInfo.title,\n              style: const TextStyle(\n                fontSize: 16,\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n            const SizedBox(height: 8),\n            Text(updateInfo.description),\n            const SizedBox(height: 12),\n\n            if (updateInfo.features.isNotEmpty) ...[\n              const Text(\n                'What\\'s New:',\n                style: TextStyle(fontWeight: FontWeight.bold),\n              ),\n              const SizedBox(height: 4),\n              ...updateInfo.features.map((feature) =&gt; Padding(\n                padding: const EdgeInsets.only(left: 8, bottom: 2),\n                child: Row(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    const Text('\u2022 '),\n                    Expanded(child: Text(feature)),\n                  ],\n                ),\n              )).toList(),\n              const SizedBox(height: 12),\n            ],\n\n            Text(\n              'Version ${updateInfo.latestVersion}',\n              style: TextStyle(\n                fontSize: 12,\n                color: Colors.grey[600],\n              ),\n            ),\n          ],\n        ),\n        actions: [\n          if (!updateInfo.isRequired)\n            TextButton(\n              onPressed: () =&gt; Navigator.of(context).pop(),\n              child: const Text('Later'),\n            ),\n          ElevatedButton(\n            onPressed: () =&gt; _handleUpdate(context),\n            child: Text(updateInfo.isRequired ? 'Update Now' : 'Update'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _handleUpdate(BuildContext context) {\n    // Open app store or download page\n    if (Platform.isIOS) {\n      _openAppStore();\n    } else if (Platform.isAndroid) {\n      _openPlayStore();\n    } else {\n      _openDownloadPage();\n    }\n\n    Navigator.of(context).pop();\n  }\n\n  void _openAppStore() {\n    // Open iOS App Store\n    launch('https://apps.apple.com/app/id123456789');\n  }\n\n  void _openPlayStore() {\n    // Open Google Play Store\n    launch('https://play.google.com/store/apps/details?id=com.yourapp.flutter');\n  }\n\n  void _openDownloadPage() {\n    // Open download page for other platforms\n    launch(updateInfo.downloadUrl);\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#version-tracking","title":"Version Tracking","text":""},{"location":"maintenance/version-management/#1-version-analytics","title":"1. Version Analytics","text":"<pre><code>// lib/services/version_analytics.dart\nclass VersionAnalytics {\n  // Track version adoption\n  static void trackVersionAdoption() {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'version_adoption',\n      parameters: {\n        'app_version': VersionConfig.appVersion,\n        'build_number': VersionConfig.buildNumber,\n        'platform': Platform.operatingSystem,\n        'platform_version': Platform.operatingSystemVersion,\n        'first_launch': _isFirstLaunch(),\n      },\n    );\n  }\n\n  // Track version migration\n  static void trackVersionMigration(String fromVersion, String toVersion) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'version_migration',\n      parameters: {\n        'from_version': fromVersion,\n        'to_version': toVersion,\n        'migration_time': DateTime.now().millisecondsSinceEpoch,\n      },\n    );\n  }\n\n  // Track update prompts\n  static void trackUpdatePrompt({\n    required String availableVersion,\n    required String currentVersion,\n    required bool isRequired,\n    required String action, // 'shown', 'accepted', 'dismissed'\n  }) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'update_prompt',\n      parameters: {\n        'available_version': availableVersion,\n        'current_version': currentVersion,\n        'is_required': isRequired,\n        'action': action,\n      },\n    );\n  }\n\n  // Track version compatibility issues\n  static void trackCompatibilityIssue({\n    required String feature,\n    required String minRequiredVersion,\n    required String currentVersion,\n  }) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'version_compatibility_issue',\n      parameters: {\n        'feature': feature,\n        'min_required_version': minRequiredVersion,\n        'current_version': currentVersion,\n      },\n    );\n  }\n\n  static bool _isFirstLaunch() {\n    // Check if this is the first launch of this version\n    // Implementation depends on your app's state management\n    return false; // Placeholder\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#2-version-migration","title":"2. Version Migration","text":"<pre><code>// lib/services/version_migration_service.dart\nclass VersionMigrationService {\n  static const String _migrationVersionKey = 'migration_version';\n\n  // Run migrations if needed\n  static Future&lt;void&gt; runMigrationsIfNeeded() async {\n    final prefs = await SharedPreferences.getInstance();\n    final lastMigrationVersion = prefs.getString(_migrationVersionKey);\n    final currentVersion = VersionConfig.appVersion;\n\n    if (lastMigrationVersion == null || \n        VersionConfig.isVersionGreater(currentVersion, lastMigrationVersion)) {\n\n      await _runMigrations(lastMigrationVersion, currentVersion);\n      await prefs.setString(_migrationVersionKey, currentVersion);\n\n      // Track migration\n      if (lastMigrationVersion != null) {\n        VersionAnalytics.trackVersionMigration(lastMigrationVersion, currentVersion);\n      }\n    }\n  }\n\n  // Run specific migrations\n  static Future&lt;void&gt; _runMigrations(String? fromVersion, String toVersion) async {\n    print('Running migrations from $fromVersion to $toVersion');\n\n    // Example migrations\n    if (fromVersion == null) {\n      await _migrateFromFreshInstall();\n    }\n\n    if (fromVersion != null &amp;&amp; VersionConfig.isVersionGreater('1.1.0', fromVersion)) {\n      await _migrateTo110();\n    }\n\n    if (fromVersion != null &amp;&amp; VersionConfig.isVersionGreater('1.2.0', fromVersion)) {\n      await _migrateTo120();\n    }\n\n    if (fromVersion != null &amp;&amp; VersionConfig.isVersionGreater('2.0.0', fromVersion)) {\n      await _migrateTo200();\n    }\n  }\n\n  // Migration for fresh installs\n  static Future&lt;void&gt; _migrateFromFreshInstall() async {\n    print('Setting up fresh installation');\n\n    // Set default preferences\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setBool('first_launch', true);\n    await prefs.setString('install_date', DateTime.now().toIso8601String());\n  }\n\n  // Migration to version 1.1.0\n  static Future&lt;void&gt; _migrateTo110() async {\n    print('Migrating to version 1.1.0');\n\n    // Example: Update database schema\n    // await DatabaseService.updateSchema();\n\n    // Example: Migrate user preferences\n    final prefs = await SharedPreferences.getInstance();\n    final oldTheme = prefs.getString('theme');\n    if (oldTheme == 'dark') {\n      await prefs.setString('theme_mode', 'dark');\n      await prefs.remove('theme');\n    }\n  }\n\n  // Migration to version 1.2.0\n  static Future&lt;void&gt; _migrateTo120() async {\n    print('Migrating to version 1.2.0');\n\n    // Example: Clear old cache\n    // await CacheService.clearOldCache();\n\n    // Example: Update notification settings\n    final prefs = await SharedPreferences.getInstance();\n    if (!prefs.containsKey('notifications_enabled')) {\n      await prefs.setBool('notifications_enabled', true);\n    }\n  }\n\n  // Migration to version 2.0.0 (major version)\n  static Future&lt;void&gt; _migrateTo200() async {\n    print('Migrating to version 2.0.0 (major version)');\n\n    // Example: Major data structure changes\n    // await DatabaseService.migrateToV2();\n\n    // Example: Reset certain preferences due to breaking changes\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.remove('deprecated_setting');\n\n    // Show migration notice to user\n    await prefs.setBool('show_v2_welcome', true);\n  }\n}\n</code></pre>"},{"location":"maintenance/version-management/#version-information-widget","title":"Version Information Widget","text":""},{"location":"maintenance/version-management/#1-about-screen","title":"1. About Screen","text":"<pre><code>// lib/screens/about_screen.dart\nclass AboutScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('About')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Center(\n              child: Column(\n                children: [\n                  // App icon\n                  Container(\n                    width: 80,\n                    height: 80,\n                    decoration: BoxDecoration(\n                      borderRadius: BorderRadius.circular(16),\n                      color: Theme.of(context).primaryColor,\n                    ),\n                    child: const Icon(\n                      Icons.camera_alt,\n                      size: 40,\n                      color: Colors.white,\n                    ),\n                  ),\n                  const SizedBox(height: 16),\n\n                  // App name and version\n                  const Text(\n                    'YourApp',\n                    style: TextStyle(\n                      fontSize: 24,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                  const SizedBox(height: 4),\n                  Text(\n                    'Version ${VersionConfig.fullVersion}',\n                    style: TextStyle(\n                      fontSize: 16,\n                      color: Colors.grey[600],\n                    ),\n                  ),\n                ],\n              ),\n            ),\n\n            const SizedBox(height: 32),\n\n            // Version details\n            Card(\n              child: Padding(\n                padding: const EdgeInsets.all(16),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\n                      'Version Information',\n                      style: Theme.of(context).textTheme.titleMedium,\n                    ),\n                    const SizedBox(height: 12),\n                    _buildInfoRow('App Version', VersionConfig.appVersion),\n                    _buildInfoRow('Build Number', VersionConfig.buildNumber.toString()),\n                    _buildInfoRow('Environment', VersionConfig.buildEnvironment),\n                    if (VersionConfig.buildDate.isNotEmpty)\n                      _buildInfoRow('Build Date', VersionConfig.buildDate),\n                    if (VersionConfig.gitCommit.isNotEmpty)\n                      _buildInfoRow('Git Commit', VersionConfig.gitCommit.substring(0, 8)),\n                    _buildInfoRow('Platform', Platform.operatingSystem),\n                    _buildInfoRow('Platform Version', Platform.operatingSystemVersion),\n                  ],\n                ),\n              ),\n            ),\n\n            const SizedBox(height: 16),\n\n            // Actions\n            SizedBox(\n              width: double.infinity,\n              child: ElevatedButton(\n                onPressed: () =&gt; _checkForUpdates(context),\n                child: const Text('Check for Updates'),\n              ),\n            ),\n\n            const SizedBox(height: 8),\n\n            SizedBox(\n              width: double.infinity,\n              child: OutlinedButton(\n                onPressed: () =&gt; _showReleaseNotes(context),\n                child: const Text('View Release Notes'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildInfoRow(String label, String value) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          SizedBox(\n            width: 120,\n            child: Text(\n              label,\n              style: const TextStyle(fontWeight: FontWeight.w500),\n            ),\n          ),\n          Expanded(\n            child: Text(\n              value,\n              style: const TextStyle(color: Colors.grey),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _checkForUpdates(BuildContext context) async {\n    // Show loading\n    showDialog(\n      context: context,\n      barrierDismissible: false,\n      builder: (context) =&gt; const Center(\n        child: CircularProgressIndicator(),\n      ),\n    );\n\n    final updateInfo = await UpdateCheckerService.forceUpdateCheck();\n\n    Navigator.of(context).pop(); // Close loading\n\n    if (updateInfo != null) {\n      await showDialog(\n        context: context,\n        builder: (context) =&gt; UpdateDialog(updateInfo: updateInfo),\n      );\n    } else {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('You have the latest version!')),\n      );\n    }\n  }\n\n  void _showReleaseNotes(BuildContext context) async {\n    final releaseNotes = await ReleaseService.getReleaseNotes(VersionConfig.appVersion);\n\n    if (releaseNotes != null) {\n      await showDialog(\n        context: context,\n        builder: (context) =&gt; ReleaseNotesDialog(releaseNotes: releaseNotes),\n      );\n    } else {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Release notes not available')),\n      );\n    }\n  }\n}\n</code></pre> <p>Version management is crucial for maintaining app quality and user experience. Implement proper versioning strategies, update mechanisms, and migration processes to ensure smooth app evolution.</p>"},{"location":"monitoring/ab-testing/","title":"A/B Testing &amp; Feature Flags","text":"<p>Comprehensive guide to implementing A/B testing and feature flags in Flutter applications for data-driven decision making.</p>"},{"location":"monitoring/ab-testing/#overview","title":"Overview","text":"<p>A/B testing allows you to compare different versions of features to determine which performs better. Feature flags enable controlled rollouts and quick feature toggles. This guide covers implementation strategies and best practices.</p>"},{"location":"monitoring/ab-testing/#firebase-remote-config","title":"Firebase Remote Config","text":""},{"location":"monitoring/ab-testing/#1-setup-and-configuration","title":"1. Setup and Configuration","text":"<pre><code># pubspec.yaml\ndependencies:\n  firebase_core: ^2.24.2\n  firebase_remote_config: ^4.3.8\n  firebase_analytics: ^10.7.4\n\ndev_dependencies:\n  firebase_remote_config_platform_interface: ^1.4.8\n</code></pre> <pre><code>// lib/services/remote_config_service.dart\nimport 'package:firebase_remote_config/firebase_remote_config.dart';\nimport 'package:firebase_analytics/firebase_analytics.dart';\n\nclass RemoteConfigService {\n  static final FirebaseRemoteConfig _remoteConfig = FirebaseRemoteConfig.instance;\n  static final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n\n  // Initialize Remote Config\n  static Future&lt;void&gt; initialize() async {\n    try {\n      // Set config settings\n      await _remoteConfig.setConfigSettings(RemoteConfigSettings(\n        fetchTimeout: const Duration(minutes: 1),\n        minimumFetchInterval: const Duration(hours: 1),\n      ));\n\n      // Set default values\n      await _remoteConfig.setDefaults(_getDefaultValues());\n\n      // Fetch and activate\n      await _remoteConfig.fetchAndActivate();\n\n      print('Remote Config initialized successfully');\n    } catch (e) {\n      print('Failed to initialize Remote Config: $e');\n    }\n  }\n\n  // Default configuration values\n  static Map&lt;String, dynamic&gt; _getDefaultValues() {\n    return {\n      // Feature flags\n      'enable_new_ui': false,\n      'enable_dark_mode': true,\n      'enable_push_notifications': true,\n      'enable_social_login': false,\n\n      // A/B test variants\n      'button_color_variant': 'blue',\n      'onboarding_flow_variant': 'standard',\n      'pricing_display_variant': 'monthly',\n\n      // Configuration values\n      'max_upload_size_mb': 10,\n      'api_timeout_seconds': 30,\n      'cache_duration_hours': 24,\n      'min_app_version': '1.0.0',\n\n      // Content variations\n      'welcome_message': 'Welcome to our app!',\n      'cta_button_text': 'Get Started',\n      'feature_announcement': '',\n    };\n  }\n\n  // Get boolean feature flag\n  static bool getFeatureFlag(String key) {\n    return _remoteConfig.getBool(key);\n  }\n\n  // Get string configuration\n  static String getString(String key) {\n    return _remoteConfig.getString(key);\n  }\n\n  // Get integer configuration\n  static int getInt(String key) {\n    return _remoteConfig.getInt(key);\n  }\n\n  // Get double configuration\n  static double getDouble(String key) {\n    return _remoteConfig.getDouble(key);\n  }\n\n  // Force fetch latest config\n  static Future&lt;void&gt; forceFetch() async {\n    try {\n      await _remoteConfig.fetch();\n      await _remoteConfig.activate();\n    } catch (e) {\n      print('Failed to fetch remote config: $e');\n    }\n  }\n\n  // Track feature flag usage\n  static void trackFeatureFlagUsage(String flagName, bool value) {\n    _analytics.logEvent(\n      name: 'feature_flag_used',\n      parameters: {\n        'flag_name': flagName,\n        'flag_value': value,\n      },\n    );\n  }\n\n  // Track A/B test variant\n  static void trackABTestVariant(String testName, String variant) {\n    _analytics.logEvent(\n      name: 'ab_test_variant',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#2-feature-flag-implementation","title":"2. Feature Flag Implementation","text":"<pre><code>// lib/services/feature_flag_service.dart\nclass FeatureFlagService {\n  // Check if feature is enabled\n  static bool isFeatureEnabled(String featureName) {\n    final isEnabled = RemoteConfigService.getFeatureFlag('enable_$featureName');\n\n    // Track usage\n    RemoteConfigService.trackFeatureFlagUsage('enable_$featureName', isEnabled);\n\n    return isEnabled;\n  }\n\n  // Get A/B test variant\n  static String getABTestVariant(String testName) {\n    final variant = RemoteConfigService.getString('${testName}_variant');\n\n    // Track variant assignment\n    RemoteConfigService.trackABTestVariant(testName, variant);\n\n    return variant;\n  }\n\n  // Feature-specific flags\n  static bool get isNewUIEnabled =&gt; isFeatureEnabled('new_ui');\n  static bool get isDarkModeEnabled =&gt; isFeatureEnabled('dark_mode');\n  static bool get isPushNotificationsEnabled =&gt; isFeatureEnabled('push_notifications');\n  static bool get isSocialLoginEnabled =&gt; isFeatureEnabled('social_login');\n\n  // A/B test variants\n  static String get buttonColorVariant =&gt; getABTestVariant('button_color');\n  static String get onboardingFlowVariant =&gt; getABTestVariant('onboarding_flow');\n  static String get pricingDisplayVariant =&gt; getABTestVariant('pricing_display');\n\n  // Configuration values\n  static int get maxUploadSizeMB =&gt; RemoteConfigService.getInt('max_upload_size_mb');\n  static int get apiTimeoutSeconds =&gt; RemoteConfigService.getInt('api_timeout_seconds');\n  static int get cacheDurationHours =&gt; RemoteConfigService.getInt('cache_duration_hours');\n  static String get minAppVersion =&gt; RemoteConfigService.getString('min_app_version');\n\n  // Content variations\n  static String get welcomeMessage =&gt; RemoteConfigService.getString('welcome_message');\n  static String get ctaButtonText =&gt; RemoteConfigService.getString('cta_button_text');\n  static String get featureAnnouncement =&gt; RemoteConfigService.getString('feature_announcement');\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#ab-testing-framework","title":"A/B Testing Framework","text":""},{"location":"monitoring/ab-testing/#1-ab-test-manager","title":"1. A/B Test Manager","text":"<pre><code>// lib/services/ab_test_manager.dart\nclass ABTestManager {\n  static final Map&lt;String, ABTest&gt; _activeTests = {};\n  static final Map&lt;String, String&gt; _userVariants = {};\n\n  // Initialize A/B tests\n  static Future&lt;void&gt; initialize() async {\n    await _loadActiveTests();\n    await _assignUserToVariants();\n  }\n\n  // Load active tests from remote config\n  static Future&lt;void&gt; _loadActiveTests() async {\n    _activeTests.clear();\n\n    // Define active A/B tests\n    _activeTests['button_color_test'] = ABTest(\n      name: 'button_color_test',\n      variants: ['blue', 'green', 'red'],\n      weights: [0.33, 0.33, 0.34],\n      isActive: true,\n    );\n\n    _activeTests['onboarding_flow_test'] = ABTest(\n      name: 'onboarding_flow_test',\n      variants: ['standard', 'simplified', 'gamified'],\n      weights: [0.4, 0.3, 0.3],\n      isActive: FeatureFlagService.isFeatureEnabled('onboarding_ab_test'),\n    );\n\n    _activeTests['pricing_display_test'] = ABTest(\n      name: 'pricing_display_test',\n      variants: ['monthly', 'yearly', 'lifetime'],\n      weights: [0.5, 0.3, 0.2],\n      isActive: true,\n    );\n  }\n\n  // Assign user to variants\n  static Future&lt;void&gt; _assignUserToVariants() async {\n    final userId = await _getUserId();\n\n    for (final test in _activeTests.values) {\n      if (test.isActive) {\n        final variant = _assignVariant(test, userId);\n        _userVariants[test.name] = variant;\n\n        // Track assignment\n        RemoteConfigService.trackABTestVariant(test.name, variant);\n      }\n    }\n  }\n\n  // Get user variant for a test\n  static String getVariant(String testName) {\n    return _userVariants[testName] ?? 'control';\n  }\n\n  // Check if user is in specific variant\n  static bool isInVariant(String testName, String variant) {\n    return getVariant(testName) == variant;\n  }\n\n  // Assign variant based on user ID and test weights\n  static String _assignVariant(ABTest test, String userId) {\n    final hash = userId.hashCode.abs();\n    final bucket = (hash % 100) / 100.0;\n\n    double cumulativeWeight = 0.0;\n    for (int i = 0; i &lt; test.variants.length; i++) {\n      cumulativeWeight += test.weights[i];\n      if (bucket &lt;= cumulativeWeight) {\n        return test.variants[i];\n      }\n    }\n\n    return test.variants.last;\n  }\n\n  // Get user ID (from auth service or device ID)\n  static Future&lt;String&gt; _getUserId() async {\n    // This would typically come from your auth service\n    // For anonymous users, use device ID or generate stable ID\n    return 'user_123'; // Placeholder\n  }\n\n  // Track conversion event\n  static void trackConversion(String testName, String eventName, {Map&lt;String, dynamic&gt;? parameters}) {\n    final variant = getVariant(testName);\n\n    FirebaseAnalytics.instance.logEvent(\n      name: 'ab_test_conversion',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n        'event_name': eventName,\n        ...parameters ?? {},\n      },\n    );\n  }\n\n  // Get all active tests\n  static Map&lt;String, String&gt; getAllVariants() {\n    return Map.from(_userVariants);\n  }\n}\n\nclass ABTest {\n  final String name;\n  final List&lt;String&gt; variants;\n  final List&lt;double&gt; weights;\n  final bool isActive;\n\n  ABTest({\n    required this.name,\n    required this.variants,\n    required this.weights,\n    required this.isActive,\n  }) : assert(variants.length == weights.length);\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#2-ab-test-widgets","title":"2. A/B Test Widgets","text":"<pre><code>// lib/widgets/ab_test_widget.dart\nclass ABTestWidget extends StatelessWidget {\n  final String testName;\n  final Map&lt;String, Widget&gt; variants;\n  final Widget? fallback;\n\n  const ABTestWidget({\n    Key? key,\n    required this.testName,\n    required this.variants,\n    this.fallback,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final variant = ABTestManager.getVariant(testName);\n\n    return variants[variant] ?? fallback ?? const SizedBox.shrink();\n  }\n}\n\n// Usage example\nclass ExampleABTestUsage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ABTestWidget(\n      testName: 'button_color_test',\n      variants: {\n        'blue': ElevatedButton(\n          style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),\n          onPressed: () =&gt; _handleButtonPress('blue'),\n          child: const Text('Get Started'),\n        ),\n        'green': ElevatedButton(\n          style: ElevatedButton.styleFrom(backgroundColor: Colors.green),\n          onPressed: () =&gt; _handleButtonPress('green'),\n          child: const Text('Get Started'),\n        ),\n        'red': ElevatedButton(\n          style: ElevatedButton.styleFrom(backgroundColor: Colors.red),\n          onPressed: () =&gt; _handleButtonPress('red'),\n          child: const Text('Get Started'),\n        ),\n      },\n      fallback: ElevatedButton(\n        onPressed: () =&gt; _handleButtonPress('control'),\n        child: const Text('Get Started'),\n      ),\n    );\n  }\n\n  void _handleButtonPress(String variant) {\n    // Track conversion\n    ABTestManager.trackConversion(\n      'button_color_test',\n      'button_clicked',\n      parameters: {'variant': variant},\n    );\n\n    // Handle button press\n    print('Button pressed: $variant');\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#feature-toggle-implementation","title":"Feature Toggle Implementation","text":""},{"location":"monitoring/ab-testing/#1-feature-toggle-widget","title":"1. Feature Toggle Widget","text":"<pre><code>// lib/widgets/feature_toggle.dart\nclass FeatureToggle extends StatelessWidget {\n  final String featureName;\n  final Widget enabledChild;\n  final Widget? disabledChild;\n  final bool trackUsage;\n\n  const FeatureToggle({\n    Key? key,\n    required this.featureName,\n    required this.enabledChild,\n    this.disabledChild,\n    this.trackUsage = true,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final isEnabled = FeatureFlagService.isFeatureEnabled(featureName);\n\n    if (trackUsage) {\n      // Track feature visibility\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        FirebaseAnalytics.instance.logEvent(\n          name: 'feature_visibility',\n          parameters: {\n            'feature_name': featureName,\n            'is_enabled': isEnabled,\n          },\n        );\n      });\n    }\n\n    if (isEnabled) {\n      return enabledChild;\n    } else {\n      return disabledChild ?? const SizedBox.shrink();\n    }\n  }\n}\n\n// Usage example\nclass ExampleFeatureToggle extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Standard feature toggle\n        FeatureToggle(\n          featureName: 'new_ui',\n          enabledChild: const NewUIComponent(),\n          disabledChild: const OldUIComponent(),\n        ),\n\n        // Feature toggle without fallback\n        FeatureToggle(\n          featureName: 'social_login',\n          enabledChild: const SocialLoginButtons(),\n        ),\n\n        // Conditional feature with custom logic\n        if (FeatureFlagService.isPushNotificationsEnabled)\n          const NotificationSettings(),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#2-gradual-rollout","title":"2. Gradual Rollout","text":"<pre><code>// lib/services/gradual_rollout_service.dart\nclass GradualRolloutService {\n  // Check if user is in rollout percentage\n  static bool isUserInRollout(String featureName, double percentage) {\n    if (percentage &gt;= 1.0) return true;\n    if (percentage &lt;= 0.0) return false;\n\n    final userId = _getUserId();\n    final hash = '$featureName$userId'.hashCode.abs();\n    final bucket = (hash % 100) / 100.0;\n\n    return bucket &lt;= percentage;\n  }\n\n  // Get rollout percentage from remote config\n  static double getRolloutPercentage(String featureName) {\n    return RemoteConfigService.getDouble('${featureName}_rollout_percentage');\n  }\n\n  // Check if feature is enabled for user with gradual rollout\n  static bool isFeatureEnabledWithRollout(String featureName) {\n    final isGloballyEnabled = FeatureFlagService.isFeatureEnabled(featureName);\n    if (!isGloballyEnabled) return false;\n\n    final rolloutPercentage = getRolloutPercentage(featureName);\n    return isUserInRollout(featureName, rolloutPercentage);\n  }\n\n  static String _getUserId() {\n    // Get user ID from auth service or device ID\n    return 'user_123'; // Placeholder\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#analytics-and-reporting","title":"Analytics and Reporting","text":""},{"location":"monitoring/ab-testing/#1-ab-test-analytics","title":"1. A/B Test Analytics","text":"<pre><code>// lib/services/ab_test_analytics.dart\nclass ABTestAnalytics {\n  // Track test exposure\n  static void trackTestExposure(String testName, String variant) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'ab_test_exposure',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n      },\n    );\n  }\n\n  // Track conversion events\n  static void trackConversion({\n    required String testName,\n    required String variant,\n    required String conversionEvent,\n    double? value,\n    Map&lt;String, dynamic&gt;? additionalParameters,\n  }) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'ab_test_conversion',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n        'conversion_event': conversionEvent,\n        'conversion_value': value,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n        ...additionalParameters ?? {},\n      },\n    );\n  }\n\n  // Track user engagement\n  static void trackEngagement({\n    required String testName,\n    required String variant,\n    required String engagementType,\n    Duration? duration,\n    Map&lt;String, dynamic&gt;? metadata,\n  }) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'ab_test_engagement',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n        'engagement_type': engagementType,\n        'duration_seconds': duration?.inSeconds,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n        ...metadata ?? {},\n      },\n    );\n  }\n\n  // Track funnel steps\n  static void trackFunnelStep({\n    required String testName,\n    required String variant,\n    required String funnelStep,\n    required int stepNumber,\n    Map&lt;String, dynamic&gt;? stepData,\n  }) {\n    FirebaseAnalytics.instance.logEvent(\n      name: 'ab_test_funnel_step',\n      parameters: {\n        'test_name': testName,\n        'variant': variant,\n        'funnel_step': funnelStep,\n        'step_number': stepNumber,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n        ...stepData ?? {},\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#2-test-results-dashboard","title":"2. Test Results Dashboard","text":"<pre><code>// lib/widgets/ab_test_dashboard.dart\nclass ABTestDashboard extends StatefulWidget {\n  @override\n  _ABTestDashboardState createState() =&gt; _ABTestDashboardState();\n}\n\nclass _ABTestDashboardState extends State&lt;ABTestDashboard&gt; {\n  @override\n  Widget build(BuildContext context) {\n    if (!kDebugMode) return const SizedBox.shrink();\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('A/B Test Dashboard')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            _buildActiveTestsSection(),\n            const SizedBox(height: 16),\n            _buildFeatureFlagsSection(),\n            const SizedBox(height: 16),\n            _buildUserVariantsSection(),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildActiveTestsSection() {\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Active A/B Tests', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            ...ABTestManager.getAllVariants().entries.map((entry) {\n              return ListTile(\n                title: Text(entry.key),\n                trailing: Chip(label: Text(entry.value)),\n              );\n            }).toList(),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildFeatureFlagsSection() {\n    final flags = [\n      'new_ui',\n      'dark_mode',\n      'push_notifications',\n      'social_login',\n    ];\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Feature Flags', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            ...flags.map((flag) {\n              final isEnabled = FeatureFlagService.isFeatureEnabled(flag);\n              return ListTile(\n                title: Text(flag),\n                trailing: Switch(\n                  value: isEnabled,\n                  onChanged: null, // Read-only in this dashboard\n                ),\n              );\n            }).toList(),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildUserVariantsSection() {\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('User Variants', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            Text('Button Color: ${ABTestManager.getVariant('button_color_test')}'),\n            Text('Onboarding: ${ABTestManager.getVariant('onboarding_flow_test')}'),\n            Text('Pricing: ${ABTestManager.getVariant('pricing_display_test')}'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#best-practices","title":"Best Practices","text":""},{"location":"monitoring/ab-testing/#1-test-planning","title":"1. Test Planning","text":"<pre><code>// lib/models/ab_test_plan.dart\nclass ABTestPlan {\n  final String name;\n  final String hypothesis;\n  final String primaryMetric;\n  final List&lt;String&gt; secondaryMetrics;\n  final double minimumDetectableEffect;\n  final double statisticalPower;\n  final Duration plannedDuration;\n  final int minimumSampleSize;\n\n  ABTestPlan({\n    required this.name,\n    required this.hypothesis,\n    required this.primaryMetric,\n    required this.secondaryMetrics,\n    required this.minimumDetectableEffect,\n    required this.statisticalPower,\n    required this.plannedDuration,\n    required this.minimumSampleSize,\n  });\n}\n</code></pre>"},{"location":"monitoring/ab-testing/#2-statistical-significance","title":"2. Statistical Significance","text":"<pre><code>// lib/utils/statistical_utils.dart\nclass StatisticalUtils {\n  // Calculate statistical significance\n  static double calculatePValue(int controlConversions, int controlTotal, \n                                int treatmentConversions, int treatmentTotal) {\n    // Simplified z-test for proportions\n    final p1 = controlConversions / controlTotal;\n    final p2 = treatmentConversions / treatmentTotal;\n    final pooledP = (controlConversions + treatmentConversions) / (controlTotal + treatmentTotal);\n\n    final se = sqrt(pooledP * (1 - pooledP) * (1/controlTotal + 1/treatmentTotal));\n    final z = (p2 - p1) / se;\n\n    // This is a simplified calculation - use proper statistical libraries in production\n    return 2 * (1 - _normalCDF(z.abs()));\n  }\n\n  static double _normalCDF(double x) {\n    // Simplified normal CDF approximation\n    return 0.5 * (1 + _erf(x / sqrt(2)));\n  }\n\n  static double _erf(double x) {\n    // Simplified error function approximation\n    final a1 = 0.254829592;\n    final a2 = -0.284496736;\n    final a3 = 1.421413741;\n    final a4 = -1.453152027;\n    final a5 = 1.061405429;\n    final p = 0.3275911;\n\n    final sign = x &lt; 0 ? -1 : 1;\n    x = x.abs();\n\n    final t = 1.0 / (1.0 + p * x);\n    final y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x * x);\n\n    return sign * y;\n  }\n}\n</code></pre> <p>A/B testing and feature flags enable data-driven development and safe feature rollouts. Implement proper tracking, statistical analysis, and gradual rollout strategies to make informed product decisions.</p>"},{"location":"monitoring/analytics/","title":"Analytics Implementation","text":"<p>Comprehensive guide to implementing analytics in Flutter applications for user behavior tracking and business insights.</p>"},{"location":"monitoring/analytics/#overview","title":"Overview","text":"<p>Analytics help you understand user behavior, track app performance, and make data-driven decisions. This guide covers multiple analytics solutions and best practices.</p>"},{"location":"monitoring/analytics/#analytics-providers","title":"Analytics Providers","text":""},{"location":"monitoring/analytics/#1-firebase-analytics-recommended","title":"1. Firebase Analytics (Recommended)","text":"<p>Google's free analytics solution with deep integration.</p>"},{"location":"monitoring/analytics/#setup","title":"Setup","text":"<pre><code># pubspec.yaml\ndependencies:\n  firebase_analytics: ^10.7.4\n  firebase_core: ^2.24.2\n</code></pre> <pre><code>// lib/services/analytics_service.dart\nimport 'package:firebase_analytics/firebase_analytics.dart';\n\nclass AnalyticsService {\n  static final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n  static final FirebaseAnalyticsObserver observer = \n      FirebaseAnalyticsObserver(analytics: _analytics);\n\n  // Track screen views\n  static Future&lt;void&gt; setCurrentScreen(String screenName) async {\n    await _analytics.logScreenView(screenName: screenName);\n  }\n\n  // Track custom events\n  static Future&lt;void&gt; logEvent(String name, Map&lt;String, dynamic&gt; parameters) async {\n    await _analytics.logEvent(name: name, parameters: parameters);\n  }\n\n  // Track user properties\n  static Future&lt;void&gt; setUserProperty(String name, String value) async {\n    await _analytics.setUserProperty(name: name, value: value);\n  }\n\n  // Set user ID\n  static Future&lt;void&gt; setUserId(String userId) async {\n    await _analytics.setUserId(id: userId);\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#implementation","title":"Implementation","text":"<pre><code>// Track screen navigation\nclass AnalyticsNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt;? previousRoute) {\n    super.didPush(route, previousRoute);\n    if (route.settings.name != null) {\n      AnalyticsService.setCurrentScreen(route.settings.name!);\n    }\n  }\n}\n\n// In main.dart\nMaterialApp(\n  navigatorObservers: [\n    AnalyticsService.observer,\n    AnalyticsNavigatorObserver(),\n  ],\n  // ... rest of app\n)\n</code></pre>"},{"location":"monitoring/analytics/#2-mixpanel","title":"2. Mixpanel","text":"<p>Advanced analytics with real-time data and user segmentation.</p>"},{"location":"monitoring/analytics/#setup_1","title":"Setup","text":"<pre><code># pubspec.yaml\ndependencies:\n  mixpanel_flutter: ^2.1.1\n</code></pre> <pre><code>// lib/services/mixpanel_service.dart\nimport 'package:mixpanel_flutter/mixpanel_flutter.dart';\n\nclass MixpanelService {\n  static Mixpanel? _mixpanel;\n\n  static Future&lt;void&gt; initialize(String token) async {\n    _mixpanel = await Mixpanel.init(token, trackAutomaticEvents: true);\n  }\n\n  static void track(String eventName, [Map&lt;String, dynamic&gt;? properties]) {\n    _mixpanel?.track(eventName, properties: properties);\n  }\n\n  static void identify(String userId) {\n    _mixpanel?.identify(userId);\n  }\n\n  static void setUserProperties(Map&lt;String, dynamic&gt; properties) {\n    _mixpanel?.getPeople().set(properties);\n  }\n\n  static void flush() {\n    _mixpanel?.flush();\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#3-amplitude","title":"3. Amplitude","text":"<p>Product analytics focused on user journey and retention.</p>"},{"location":"monitoring/analytics/#setup_2","title":"Setup","text":"<pre><code># pubspec.yaml\ndependencies:\n  amplitude_flutter: ^3.16.2\n</code></pre> <pre><code>// lib/services/amplitude_service.dart\nimport 'package:amplitude_flutter/amplitude.dart';\n\nclass AmplitudeService {\n  static final Amplitude _amplitude = Amplitude.getInstance();\n\n  static Future&lt;void&gt; initialize(String apiKey) async {\n    await _amplitude.init(apiKey);\n  }\n\n  static void logEvent(String eventType, [Map&lt;String, dynamic&gt;? eventProperties]) {\n    _amplitude.logEvent(eventType, eventProperties: eventProperties);\n  }\n\n  static void setUserId(String userId) {\n    _amplitude.setUserId(userId);\n  }\n\n  static void setUserProperties(Map&lt;String, dynamic&gt; userProperties) {\n    _amplitude.setUserProperties(userProperties);\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#event-tracking-strategy","title":"Event Tracking Strategy","text":""},{"location":"monitoring/analytics/#1-core-events","title":"1. Core Events","text":"<pre><code>class AnalyticsEvents {\n  // User lifecycle\n  static const String userSignUp = 'user_sign_up';\n  static const String userLogin = 'user_login';\n  static const String userLogout = 'user_logout';\n\n  // Content interaction\n  static const String postCreated = 'post_created';\n  static const String postLiked = 'post_liked';\n  static const String postShared = 'post_shared';\n  static const String postCommented = 'post_commented';\n\n  // Navigation\n  static const String screenView = 'screen_view';\n  static const String buttonTap = 'button_tap';\n\n  // Business metrics\n  static const String purchaseCompleted = 'purchase_completed';\n  static const String subscriptionStarted = 'subscription_started';\n}\n\nclass AnalyticsParameters {\n  static const String userId = 'user_id';\n  static const String screenName = 'screen_name';\n  static const String postId = 'post_id';\n  static const String category = 'category';\n  static const String value = 'value';\n  static const String currency = 'currency';\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-event-implementation","title":"2. Event Implementation","text":"<pre><code>// lib/services/analytics_manager.dart\nclass AnalyticsManager {\n  static final List&lt;AnalyticsProvider&gt; _providers = [];\n\n  static void initialize() {\n    _providers.addAll([\n      FirebaseAnalyticsProvider(),\n      MixpanelProvider(),\n      AmplitudeProvider(),\n    ]);\n  }\n\n  static Future&lt;void&gt; track(String event, [Map&lt;String, dynamic&gt;? parameters]) async {\n    for (final provider in _providers) {\n      await provider.track(event, parameters);\n    }\n  }\n\n  static Future&lt;void&gt; setUserProperty(String name, String value) async {\n    for (final provider in _providers) {\n      await provider.setUserProperty(name, value);\n    }\n  }\n\n  static Future&lt;void&gt; setUserId(String userId) async {\n    for (final provider in _providers) {\n      await provider.setUserId(userId);\n    }\n  }\n}\n\nabstract class AnalyticsProvider {\n  Future&lt;void&gt; track(String event, Map&lt;String, dynamic&gt;? parameters);\n  Future&lt;void&gt; setUserProperty(String name, String value);\n  Future&lt;void&gt; setUserId(String userId);\n}\n</code></pre>"},{"location":"monitoring/analytics/#3-automatic-tracking","title":"3. Automatic Tracking","text":"<pre><code>// lib/widgets/analytics_wrapper.dart\nclass AnalyticsWrapper extends StatefulWidget {\n  final Widget child;\n  final String screenName;\n  final Map&lt;String, dynamic&gt;? screenParameters;\n\n  const AnalyticsWrapper({\n    Key? key,\n    required this.child,\n    required this.screenName,\n    this.screenParameters,\n  }) : super(key: key);\n\n  @override\n  _AnalyticsWrapperState createState() =&gt; _AnalyticsWrapperState();\n}\n\nclass _AnalyticsWrapperState extends State&lt;AnalyticsWrapper&gt; {\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      AnalyticsManager.track(AnalyticsEvents.screenView, {\n        AnalyticsParameters.screenName: widget.screenName,\n        ...?widget.screenParameters,\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget.child;\n  }\n}\n\n// Usage\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return AnalyticsWrapper(\n      screenName: 'home',\n      child: Scaffold(\n        // ... screen content\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#user-segmentation","title":"User Segmentation","text":""},{"location":"monitoring/analytics/#1-user-properties","title":"1. User Properties","text":"<pre><code>class UserAnalytics {\n  static Future&lt;void&gt; setUserSegment(User user) async {\n    await AnalyticsManager.setUserProperty('user_type', user.type);\n    await AnalyticsManager.setUserProperty('subscription_status', user.subscriptionStatus);\n    await AnalyticsManager.setUserProperty('registration_date', user.registrationDate.toIso8601String());\n    await AnalyticsManager.setUserProperty('country', user.country);\n    await AnalyticsManager.setUserProperty('app_version', await _getAppVersion());\n  }\n\n  static Future&lt;void&gt; updateEngagementLevel(int sessionCount, Duration totalTime) async {\n    String engagementLevel;\n    if (sessionCount &gt; 50 &amp;&amp; totalTime.inHours &gt; 20) {\n      engagementLevel = 'high';\n    } else if (sessionCount &gt; 10 &amp;&amp; totalTime.inHours &gt; 5) {\n      engagementLevel = 'medium';\n    } else {\n      engagementLevel = 'low';\n    }\n\n    await AnalyticsManager.setUserProperty('engagement_level', engagementLevel);\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-cohort-analysis","title":"2. Cohort Analysis","text":"<pre><code>class CohortAnalytics {\n  static Future&lt;void&gt; trackRetention(String userId, int daysSinceInstall) async {\n    await AnalyticsManager.track('retention_milestone', {\n      'user_id': userId,\n      'days_since_install': daysSinceInstall,\n      'cohort_week': _getCohortWeek(),\n    });\n  }\n\n  static String _getCohortWeek() {\n    final now = DateTime.now();\n    final startOfYear = DateTime(now.year, 1, 1);\n    final weekNumber = ((now.difference(startOfYear).inDays) / 7).floor() + 1;\n    return '${now.year}-W$weekNumber';\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#funnel-analysis","title":"Funnel Analysis","text":""},{"location":"monitoring/analytics/#1-conversion-tracking","title":"1. Conversion Tracking","text":"<pre><code>class FunnelAnalytics {\n  static Future&lt;void&gt; trackSignupFunnel(String step, {Map&lt;String, dynamic&gt;? additionalData}) async {\n    await AnalyticsManager.track('signup_funnel', {\n      'step': step,\n      'timestamp': DateTime.now().millisecondsSinceEpoch,\n      ...?additionalData,\n    });\n  }\n\n  static Future&lt;void&gt; trackPurchaseFunnel(String step, {required double value}) async {\n    await AnalyticsManager.track('purchase_funnel', {\n      'step': step,\n      'value': value,\n      'currency': 'USD',\n      'timestamp': DateTime.now().millisecondsSinceEpoch,\n    });\n  }\n}\n\n// Usage in signup flow\nclass SignupScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          ElevatedButton(\n            onPressed: () {\n              FunnelAnalytics.trackSignupFunnel('email_entered');\n              // Navigate to next step\n            },\n            child: Text('Continue with Email'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-ab-testing-integration","title":"2. A/B Testing Integration","text":"<pre><code>class ABTestAnalytics {\n  static Future&lt;void&gt; trackExperiment(String experimentName, String variant) async {\n    await AnalyticsManager.track('experiment_exposure', {\n      'experiment_name': experimentName,\n      'variant': variant,\n    });\n  }\n\n  static Future&lt;void&gt; trackConversion(String experimentName, String variant, String goal) async {\n    await AnalyticsManager.track('experiment_conversion', {\n      'experiment_name': experimentName,\n      'variant': variant,\n      'goal': goal,\n    });\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#performance-analytics","title":"Performance Analytics","text":""},{"location":"monitoring/analytics/#1-app-performance","title":"1. App Performance","text":"<pre><code>class PerformanceAnalytics {\n  static Future&lt;void&gt; trackAppLaunchTime(Duration launchTime) async {\n    await AnalyticsManager.track('app_launch_time', {\n      'duration_ms': launchTime.inMilliseconds,\n      'is_cold_start': await _isColdStart(),\n    });\n  }\n\n  static Future&lt;void&gt; trackScreenLoadTime(String screenName, Duration loadTime) async {\n    await AnalyticsManager.track('screen_load_time', {\n      'screen_name': screenName,\n      'duration_ms': loadTime.inMilliseconds,\n    });\n  }\n\n  static Future&lt;void&gt; trackNetworkRequest(String endpoint, Duration responseTime, bool success) async {\n    await AnalyticsManager.track('network_request', {\n      'endpoint': endpoint,\n      'response_time_ms': responseTime.inMilliseconds,\n      'success': success,\n    });\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-user-experience-metrics","title":"2. User Experience Metrics","text":"<pre><code>class UXAnalytics {\n  static Future&lt;void&gt; trackUserFlow(String fromScreen, String toScreen, String action) async {\n    await AnalyticsManager.track('user_flow', {\n      'from_screen': fromScreen,\n      'to_screen': toScreen,\n      'action': action,\n    });\n  }\n\n  static Future&lt;void&gt; trackErrorOccurrence(String errorType, String errorMessage, String screen) async {\n    await AnalyticsManager.track('error_occurred', {\n      'error_type': errorType,\n      'error_message': errorMessage,\n      'screen': screen,\n    });\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#privacy-and-compliance","title":"Privacy and Compliance","text":""},{"location":"monitoring/analytics/#1-gdpr-compliance","title":"1. GDPR Compliance","text":"<pre><code>class PrivacyAnalytics {\n  static bool _analyticsEnabled = true;\n\n  static void setAnalyticsEnabled(bool enabled) {\n    _analyticsEnabled = enabled;\n    if (!enabled) {\n      _clearUserData();\n    }\n  }\n\n  static bool get isAnalyticsEnabled =&gt; _analyticsEnabled;\n\n  static Future&lt;void&gt; _clearUserData() async {\n    // Clear user data from all analytics providers\n    for (final provider in _providers) {\n      await provider.clearUserData();\n    }\n  }\n\n  static Future&lt;void&gt; trackWithConsent(String event, [Map&lt;String, dynamic&gt;? parameters]) async {\n    if (_analyticsEnabled) {\n      await AnalyticsManager.track(event, parameters);\n    }\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-data-anonymization","title":"2. Data Anonymization","text":"<pre><code>class AnonymizedAnalytics {\n  static String _hashUserId(String userId) {\n    // Use a one-way hash for user ID\n    return sha256.convert(utf8.encode(userId)).toString();\n  }\n\n  static Map&lt;String, dynamic&gt; _sanitizeParameters(Map&lt;String, dynamic&gt; parameters) {\n    final sanitized = Map&lt;String, dynamic&gt;.from(parameters);\n\n    // Remove or hash sensitive data\n    if (sanitized.containsKey('email')) {\n      sanitized['email'] = _hashEmail(sanitized['email']);\n    }\n\n    if (sanitized.containsKey('phone')) {\n      sanitized.remove('phone'); // Remove entirely\n    }\n\n    return sanitized;\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#testing-analytics","title":"Testing Analytics","text":""},{"location":"monitoring/analytics/#1-debug-mode","title":"1. Debug Mode","text":"<pre><code>class DebugAnalytics {\n  static bool _debugMode = kDebugMode;\n\n  static Future&lt;void&gt; track(String event, [Map&lt;String, dynamic&gt;? parameters]) async {\n    if (_debugMode) {\n      print('Analytics Event: $event');\n      print('Parameters: $parameters');\n    }\n\n    if (!_debugMode) {\n      await AnalyticsManager.track(event, parameters);\n    }\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-analytics-testing","title":"2. Analytics Testing","text":"<pre><code>// test/analytics_test.dart\nclass MockAnalyticsProvider extends Mock implements AnalyticsProvider {}\n\nvoid main() {\n  group('Analytics Tests', () {\n    late MockAnalyticsProvider mockProvider;\n\n    setUp(() {\n      mockProvider = MockAnalyticsProvider();\n      AnalyticsManager.addProvider(mockProvider);\n    });\n\n    test('should track user signup event', () async {\n      await AnalyticsManager.track(AnalyticsEvents.userSignUp, {\n        'method': 'email',\n        'user_id': 'test_user_123',\n      });\n\n      verify(mockProvider.track(AnalyticsEvents.userSignUp, any)).called(1);\n    });\n  });\n}\n</code></pre>"},{"location":"monitoring/analytics/#best-practices","title":"Best Practices","text":""},{"location":"monitoring/analytics/#1-event-naming-convention","title":"1. Event Naming Convention","text":"<pre><code>// Use consistent naming patterns\nclass EventNaming {\n  // Format: object_action\n  static const String postCreated = 'post_created';\n  static const String postDeleted = 'post_deleted';\n  static const String userRegistered = 'user_registered';\n\n  // Use snake_case for consistency\n  static const String screenViewed = 'screen_viewed';\n  static const String buttonClicked = 'button_clicked';\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-parameter-standardization","title":"2. Parameter Standardization","text":"<pre><code>class StandardParameters {\n  // Always include these when relevant\n  static const String timestamp = 'timestamp';\n  static const String userId = 'user_id';\n  static const String sessionId = 'session_id';\n  static const String appVersion = 'app_version';\n  static const String platform = 'platform';\n}\n</code></pre>"},{"location":"monitoring/analytics/#3-batch-processing","title":"3. Batch Processing","text":"<pre><code>class BatchAnalytics {\n  static final List&lt;AnalyticsEvent&gt; _eventQueue = [];\n  static Timer? _batchTimer;\n\n  static void queueEvent(String name, Map&lt;String, dynamic&gt;? parameters) {\n    _eventQueue.add(AnalyticsEvent(name, parameters));\n\n    _batchTimer?.cancel();\n    _batchTimer = Timer(Duration(seconds: 5), _flushEvents);\n  }\n\n  static Future&lt;void&gt; _flushEvents() async {\n    if (_eventQueue.isNotEmpty) {\n      final events = List&lt;AnalyticsEvent&gt;.from(_eventQueue);\n      _eventQueue.clear();\n\n      for (final event in events) {\n        await AnalyticsManager.track(event.name, event.parameters);\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#reporting-and-dashboards","title":"Reporting and Dashboards","text":""},{"location":"monitoring/analytics/#1-custom-metrics","title":"1. Custom Metrics","text":"<pre><code>class CustomMetrics {\n  static Future&lt;void&gt; trackDAU(String userId) async {\n    await AnalyticsManager.track('daily_active_user', {\n      'user_id': userId,\n      'date': DateTime.now().toIso8601String().split('T')[0],\n    });\n  }\n\n  static Future&lt;void&gt; trackSessionDuration(Duration duration) async {\n    await AnalyticsManager.track('session_duration', {\n      'duration_seconds': duration.inSeconds,\n      'duration_category': _categorizeDuration(duration),\n    });\n  }\n\n  static String _categorizeDuration(Duration duration) {\n    if (duration.inMinutes &lt; 1) return 'very_short';\n    if (duration.inMinutes &lt; 5) return 'short';\n    if (duration.inMinutes &lt; 15) return 'medium';\n    if (duration.inMinutes &lt; 30) return 'long';\n    return 'very_long';\n  }\n}\n</code></pre>"},{"location":"monitoring/analytics/#2-real-time-monitoring","title":"2. Real-time Monitoring","text":"<pre><code>class RealTimeAnalytics {\n  static Future&lt;void&gt; trackCriticalEvent(String event, Map&lt;String, dynamic&gt; data) async {\n    // Send to real-time monitoring\n    await AnalyticsManager.track(event, {\n      ...data,\n      'priority': 'high',\n      'real_time': true,\n    });\n\n    // Also send to alerting system if needed\n    if (_isCriticalError(event)) {\n      await _sendAlert(event, data);\n    }\n  }\n}\n</code></pre> <p>Analytics implementation should be planned carefully to provide actionable insights while respecting user privacy. Start with core events and gradually expand based on your specific business needs.</p>"},{"location":"monitoring/crash-reporting/","title":"Crash Reporting &amp; Error Monitoring","text":"<p>Comprehensive guide to implementing crash reporting and error monitoring in Flutter applications.</p>"},{"location":"monitoring/crash-reporting/#overview","title":"Overview","text":"<p>Crash reporting is essential for maintaining app stability and user experience. This guide covers setting up crash reporting, error monitoring, and analytics to track and resolve issues in production.</p>"},{"location":"monitoring/crash-reporting/#firebase-crashlytics-integration","title":"Firebase Crashlytics Integration","text":""},{"location":"monitoring/crash-reporting/#1-setup-and-configuration","title":"1. Setup and Configuration","text":"<pre><code># pubspec.yaml\ndependencies:\n  firebase_core: ^2.24.2\n  firebase_crashlytics: ^3.4.8\n  firebase_analytics: ^10.7.4\n\ndev_dependencies:\n  firebase_crashlytics_platform_interface: ^3.6.8\n</code></pre> <pre><code>// lib/main.dart\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\nimport 'package:flutter/foundation.dart';\n\nFuture&lt;void&gt; main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Firebase\n  await Firebase.initializeApp();\n\n  // Enable crash reporting for release builds\n  if (!kDebugMode) {\n    // Pass all uncaught errors from the framework to Crashlytics\n    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;\n\n    // Pass all uncaught asynchronous errors to Crashlytics\n    PlatformDispatcher.instance.onError = (error, stack) {\n      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n      return true;\n    };\n  }\n\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-android-configuration","title":"2. Android Configuration","text":"<pre><code>&lt;!-- android/app/src/main/AndroidManifest.xml --&gt;\n&lt;application&gt;\n    &lt;!-- Crashlytics configuration --&gt;\n    &lt;meta-data\n        android:name=\"firebase_crashlytics_collection_enabled\"\n        android:value=\"true\" /&gt;\n\n    &lt;!-- Disable automatic collection in debug builds --&gt;\n    &lt;meta-data\n        android:name=\"firebase_crashlytics_collection_enabled\"\n        android:value=\"false\" /&gt;\n&lt;/application&gt;\n</code></pre> <pre><code>// android/app/build.gradle\napply plugin: 'com.google.firebase.crashlytics'\n\nandroid {\n    buildTypes {\n        debug {\n            manifestPlaceholders = [crashlyticsCollectionEnabled:\"false\"]\n        }\n        release {\n            manifestPlaceholders = [crashlyticsCollectionEnabled:\"true\"]\n        }\n    }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#3-ios-configuration","title":"3. iOS Configuration","text":"<pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;dict&gt;\n    &lt;!-- Crashlytics configuration --&gt;\n    &lt;key&gt;firebase_crashlytics_collection_enabled&lt;/key&gt;\n    &lt;false/&gt;\n&lt;/dict&gt;\n</code></pre>"},{"location":"monitoring/crash-reporting/#crash-reporting-service","title":"Crash Reporting Service","text":""},{"location":"monitoring/crash-reporting/#1-centralized-error-handling","title":"1. Centralized Error Handling","text":"<pre><code>// lib/services/crash_reporting_service.dart\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nclass CrashReportingService {\n  static FirebaseCrashlytics get _crashlytics =&gt; FirebaseCrashlytics.instance;\n\n  // Initialize crash reporting\n  static Future&lt;void&gt; initialize() async {\n    if (kDebugMode) {\n      // Disable crash reporting in debug mode\n      await _crashlytics.setCrashlyticsCollectionEnabled(false);\n    } else {\n      await _crashlytics.setCrashlyticsCollectionEnabled(true);\n    }\n  }\n\n  // Record non-fatal errors\n  static Future&lt;void&gt; recordError(\n    dynamic exception,\n    StackTrace? stackTrace, {\n    String? reason,\n    Map&lt;String, dynamic&gt;? context,\n    bool fatal = false,\n  }) async {\n    if (kDebugMode) {\n      print('Error: $exception');\n      print('Stack trace: $stackTrace');\n      return;\n    }\n\n    // Add context information\n    if (context != null) {\n      for (final entry in context.entries) {\n        await _crashlytics.setCustomKey(entry.key, entry.value);\n      }\n    }\n\n    await _crashlytics.recordError(\n      exception,\n      stackTrace,\n      reason: reason,\n      fatal: fatal,\n    );\n  }\n\n  // Record Flutter errors\n  static Future&lt;void&gt; recordFlutterError(FlutterErrorDetails details) async {\n    if (kDebugMode) {\n      FlutterError.presentError(details);\n      return;\n    }\n\n    await _crashlytics.recordFlutterFatalError(details);\n  }\n\n  // Set user information\n  static Future&lt;void&gt; setUserInfo({\n    required String userId,\n    String? email,\n    String? name,\n  }) async {\n    await _crashlytics.setUserIdentifier(userId);\n\n    if (email != null) {\n      await _crashlytics.setCustomKey('user_email', email);\n    }\n\n    if (name != null) {\n      await _crashlytics.setCustomKey('user_name', name);\n    }\n  }\n\n  // Set custom keys for debugging\n  static Future&lt;void&gt; setCustomKey(String key, dynamic value) async {\n    await _crashlytics.setCustomKey(key, value);\n  }\n\n  // Log custom events\n  static Future&lt;void&gt; log(String message) async {\n    await _crashlytics.log(message);\n  }\n\n  // Force a crash (for testing)\n  static void forceCrash() {\n    if (kDebugMode) {\n      throw Exception('Test crash from debug mode');\n    }\n    _crashlytics.crash();\n  }\n\n  // Check if crash reporting is enabled\n  static Future&lt;bool&gt; isCrashlyticsCollectionEnabled() async {\n    return await _crashlytics.isCrashlyticsCollectionEnabled();\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-error-boundary-widget","title":"2. Error Boundary Widget","text":"<pre><code>// lib/widgets/error_boundary.dart\nclass ErrorBoundary extends StatefulWidget {\n  final Widget child;\n  final Widget Function(FlutterErrorDetails)? errorBuilder;\n  final void Function(FlutterErrorDetails)? onError;\n\n  const ErrorBoundary({\n    Key? key,\n    required this.child,\n    this.errorBuilder,\n    this.onError,\n  }) : super(key: key);\n\n  @override\n  _ErrorBoundaryState createState() =&gt; _ErrorBoundaryState();\n}\n\nclass _ErrorBoundaryState extends State&lt;ErrorBoundary&gt; {\n  FlutterErrorDetails? _errorDetails;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Set up error handling for this widget tree\n    FlutterError.onError = (details) {\n      setState(() {\n        _errorDetails = details;\n      });\n\n      // Report to crash reporting service\n      CrashReportingService.recordFlutterError(details);\n\n      // Call custom error handler\n      widget.onError?.call(details);\n    };\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_errorDetails != null) {\n      return widget.errorBuilder?.call(_errorDetails!) ?? _buildDefaultErrorWidget();\n    }\n\n    return widget.child;\n  }\n\n  Widget _buildDefaultErrorWidget() {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Icon(\n              Icons.error_outline,\n              size: 64,\n              color: Colors.red,\n            ),\n            const SizedBox(height: 16),\n            const Text(\n              'Something went wrong',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 8),\n            const Text(\n              'We\\'re working to fix this issue.',\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () {\n                setState(() {\n                  _errorDetails = null;\n                });\n              },\n              child: const Text('Try Again'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#custom-error-tracking","title":"Custom Error Tracking","text":""},{"location":"monitoring/crash-reporting/#1-network-error-tracking","title":"1. Network Error Tracking","text":"<pre><code>// lib/services/network_error_tracker.dart\nclass NetworkErrorTracker {\n  static void trackApiError({\n    required String endpoint,\n    required int statusCode,\n    required String method,\n    String? errorMessage,\n    Map&lt;String, dynamic&gt;? requestData,\n  }) {\n    final context = {\n      'endpoint': endpoint,\n      'status_code': statusCode,\n      'method': method,\n      'timestamp': DateTime.now().toIso8601String(),\n    };\n\n    if (requestData != null) {\n      context['request_size'] = requestData.toString().length;\n    }\n\n    CrashReportingService.recordError(\n      'API Error: $statusCode',\n      StackTrace.current,\n      reason: 'Network request failed: $method $endpoint',\n      context: context,\n    );\n  }\n\n  static void trackTimeoutError({\n    required String endpoint,\n    required Duration timeout,\n    required String method,\n  }) {\n    CrashReportingService.recordError(\n      'Timeout Error',\n      StackTrace.current,\n      reason: 'Request timeout: $method $endpoint',\n      context: {\n        'endpoint': endpoint,\n        'timeout_seconds': timeout.inSeconds,\n        'method': method,\n        'timestamp': DateTime.now().toIso8601String(),\n      },\n    );\n  }\n\n  static void trackConnectivityError({\n    required String endpoint,\n    required String method,\n    required String errorType,\n  }) {\n    CrashReportingService.recordError(\n      'Connectivity Error',\n      StackTrace.current,\n      reason: 'Network connectivity issue: $errorType',\n      context: {\n        'endpoint': endpoint,\n        'method': method,\n        'error_type': errorType,\n        'timestamp': DateTime.now().toIso8601String(),\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-user-action-error-tracking","title":"2. User Action Error Tracking","text":"<pre><code>// lib/services/user_action_tracker.dart\nclass UserActionTracker {\n  static void trackUserError({\n    required String action,\n    required String screen,\n    String? errorMessage,\n    Map&lt;String, dynamic&gt;? additionalData,\n  }) {\n    final context = {\n      'user_action': action,\n      'screen': screen,\n      'timestamp': DateTime.now().toIso8601String(),\n    };\n\n    if (additionalData != null) {\n      context.addAll(additionalData);\n    }\n\n    CrashReportingService.recordError(\n      'User Action Error',\n      StackTrace.current,\n      reason: 'Error during user action: $action on $screen',\n      context: context,\n    );\n  }\n\n  static void trackFormError({\n    required String formName,\n    required String fieldName,\n    required String errorType,\n    String? errorMessage,\n  }) {\n    CrashReportingService.recordError(\n      'Form Validation Error',\n      StackTrace.current,\n      reason: 'Form error: $errorType in $fieldName',\n      context: {\n        'form_name': formName,\n        'field_name': fieldName,\n        'error_type': errorType,\n        'error_message': errorMessage,\n        'timestamp': DateTime.now().toIso8601String(),\n      },\n    );\n  }\n\n  static void trackNavigationError({\n    required String fromRoute,\n    required String toRoute,\n    String? errorMessage,\n  }) {\n    CrashReportingService.recordError(\n      'Navigation Error',\n      StackTrace.current,\n      reason: 'Navigation failed from $fromRoute to $toRoute',\n      context: {\n        'from_route': fromRoute,\n        'to_route': toRoute,\n        'error_message': errorMessage,\n        'timestamp': DateTime.now().toIso8601String(),\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"monitoring/crash-reporting/#1-performance-metrics-tracking","title":"1. Performance Metrics Tracking","text":"<pre><code>// lib/services/performance_monitor.dart\nclass PerformanceMonitor {\n  static final Map&lt;String, DateTime&gt; _startTimes = {};\n\n  static void startTrace(String traceName) {\n    _startTimes[traceName] = DateTime.now();\n    CrashReportingService.log('Started trace: $traceName');\n  }\n\n  static void stopTrace(String traceName) {\n    final startTime = _startTimes.remove(traceName);\n    if (startTime != null) {\n      final duration = DateTime.now().difference(startTime);\n\n      CrashReportingService.setCustomKey('${traceName}_duration_ms', duration.inMilliseconds);\n      CrashReportingService.log('Stopped trace: $traceName (${duration.inMilliseconds}ms)');\n\n      // Track slow operations\n      if (duration.inMilliseconds &gt; 5000) {\n        CrashReportingService.recordError(\n          'Slow Operation',\n          StackTrace.current,\n          reason: 'Operation took longer than expected: $traceName',\n          context: {\n            'trace_name': traceName,\n            'duration_ms': duration.inMilliseconds,\n            'timestamp': DateTime.now().toIso8601String(),\n          },\n        );\n      }\n    }\n  }\n\n  static void trackMemoryUsage() {\n    // This would require platform-specific implementation\n    // or use packages like process_info\n  }\n\n  static void trackAppLaunchTime(Duration launchTime) {\n    CrashReportingService.setCustomKey('app_launch_time_ms', launchTime.inMilliseconds);\n\n    if (launchTime.inSeconds &gt; 10) {\n      CrashReportingService.recordError(\n        'Slow App Launch',\n        StackTrace.current,\n        reason: 'App took too long to launch',\n        context: {\n          'launch_time_ms': launchTime.inMilliseconds,\n          'timestamp': DateTime.now().toIso8601String(),\n        },\n      );\n    }\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-widget-performance-tracking","title":"2. Widget Performance Tracking","text":"<pre><code>// lib/widgets/performance_tracked_widget.dart\nclass PerformanceTrackedWidget extends StatefulWidget {\n  final Widget child;\n  final String widgetName;\n\n  const PerformanceTrackedWidget({\n    Key? key,\n    required this.child,\n    required this.widgetName,\n  }) : super(key: key);\n\n  @override\n  _PerformanceTrackedWidgetState createState() =&gt; _PerformanceTrackedWidgetState();\n}\n\nclass _PerformanceTrackedWidgetState extends State&lt;PerformanceTrackedWidget&gt; {\n  late DateTime _buildStartTime;\n\n  @override\n  void initState() {\n    super.initState();\n    PerformanceMonitor.startTrace('${widget.widgetName}_init');\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    PerformanceMonitor.stopTrace('${widget.widgetName}_init');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    _buildStartTime = DateTime.now();\n\n    return widget.child;\n  }\n\n  @override\n  void didUpdateWidget(PerformanceTrackedWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n\n    final buildDuration = DateTime.now().difference(_buildStartTime);\n\n    if (buildDuration.inMilliseconds &gt; 100) {\n      CrashReportingService.recordError(\n        'Slow Widget Build',\n        StackTrace.current,\n        reason: 'Widget build took too long: ${widget.widgetName}',\n        context: {\n          'widget_name': widget.widgetName,\n          'build_duration_ms': buildDuration.inMilliseconds,\n          'timestamp': DateTime.now().toIso8601String(),\n        },\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    PerformanceMonitor.stopTrace('${widget.widgetName}_lifecycle');\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#error-analytics-dashboard","title":"Error Analytics Dashboard","text":""},{"location":"monitoring/crash-reporting/#1-error-metrics-collection","title":"1. Error Metrics Collection","text":"<pre><code>// lib/services/error_analytics.dart\nclass ErrorAnalytics {\n  static final Map&lt;String, int&gt; _errorCounts = {};\n  static final List&lt;ErrorEvent&gt; _recentErrors = [];\n\n  static void recordErrorEvent({\n    required String errorType,\n    required String errorMessage,\n    required String screen,\n    Map&lt;String, dynamic&gt;? metadata,\n  }) {\n    final event = ErrorEvent(\n      type: errorType,\n      message: errorMessage,\n      screen: screen,\n      timestamp: DateTime.now(),\n      metadata: metadata ?? {},\n    );\n\n    _recentErrors.add(event);\n    _errorCounts[errorType] = (_errorCounts[errorType] ?? 0) + 1;\n\n    // Keep only recent errors (last 100)\n    if (_recentErrors.length &gt; 100) {\n      _recentErrors.removeAt(0);\n    }\n\n    // Send to crash reporting\n    CrashReportingService.recordError(\n      errorType,\n      StackTrace.current,\n      reason: errorMessage,\n      context: {\n        'screen': screen,\n        'error_count': _errorCounts[errorType],\n        ...metadata ?? {},\n      },\n    );\n  }\n\n  static Map&lt;String, int&gt; getErrorCounts() =&gt; Map.from(_errorCounts);\n\n  static List&lt;ErrorEvent&gt; getRecentErrors() =&gt; List.from(_recentErrors);\n\n  static void clearErrorHistory() {\n    _errorCounts.clear();\n    _recentErrors.clear();\n  }\n}\n\nclass ErrorEvent {\n  final String type;\n  final String message;\n  final String screen;\n  final DateTime timestamp;\n  final Map&lt;String, dynamic&gt; metadata;\n\n  ErrorEvent({\n    required this.type,\n    required this.message,\n    required this.screen,\n    required this.timestamp,\n    required this.metadata,\n  });\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-error-reporting-widget","title":"2. Error Reporting Widget","text":"<pre><code>// lib/widgets/error_report_widget.dart\nclass ErrorReportWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    if (!kDebugMode) return const SizedBox.shrink();\n\n    return FloatingActionButton(\n      mini: true,\n      onPressed: () =&gt; _showErrorReport(context),\n      child: const Icon(Icons.bug_report),\n    );\n  }\n\n  void _showErrorReport(BuildContext context) {\n    showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Error Report'),\n        content: SizedBox(\n          width: double.maxFinite,\n          height: 400,\n          child: Column(\n            children: [\n              Text('Error Counts:', style: Theme.of(context).textTheme.titleMedium),\n              const SizedBox(height: 8),\n              Expanded(\n                child: ListView(\n                  children: ErrorAnalytics.getErrorCounts().entries.map((entry) {\n                    return ListTile(\n                      title: Text(entry.key),\n                      trailing: Text('${entry.value}'),\n                    );\n                  }).toList(),\n                ),\n              ),\n              const Divider(),\n              Text('Recent Errors:', style: Theme.of(context).textTheme.titleMedium),\n              const SizedBox(height: 8),\n              Expanded(\n                child: ListView(\n                  children: ErrorAnalytics.getRecentErrors().map((error) {\n                    return ListTile(\n                      title: Text(error.type),\n                      subtitle: Text(error.message),\n                      trailing: Text(error.screen),\n                    );\n                  }).toList(),\n                ),\n              ),\n            ],\n          ),\n        ),\n        actions: [\n          TextButton(\n            onPressed: () {\n              ErrorAnalytics.clearErrorHistory();\n              Navigator.of(context).pop();\n            },\n            child: const Text('Clear'),\n          ),\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('Close'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#testing-crash-reporting","title":"Testing Crash Reporting","text":""},{"location":"monitoring/crash-reporting/#1-crash-testing","title":"1. Crash Testing","text":"<pre><code>// lib/utils/crash_test_utils.dart\nclass CrashTestUtils {\n  static void testCrashReporting() {\n    if (kDebugMode) {\n      print('Testing crash reporting...');\n\n      // Test non-fatal error\n      CrashReportingService.recordError(\n        'Test Error',\n        StackTrace.current,\n        reason: 'Testing crash reporting system',\n        context: {'test': true},\n      );\n\n      // Test custom key\n      CrashReportingService.setCustomKey('test_key', 'test_value');\n\n      // Test log\n      CrashReportingService.log('Test log message');\n\n      print('Crash reporting test completed');\n    }\n  }\n\n  static void testFatalCrash() {\n    if (kDebugMode) {\n      throw Exception('Test fatal crash');\n    }\n    CrashReportingService.forceCrash();\n  }\n}\n</code></pre>"},{"location":"monitoring/crash-reporting/#2-error-simulation","title":"2. Error Simulation","text":"<pre><code>// lib/utils/error_simulator.dart\nclass ErrorSimulator {\n  static void simulateNetworkError() {\n    NetworkErrorTracker.trackApiError(\n      endpoint: '/api/test',\n      statusCode: 500,\n      method: 'GET',\n      errorMessage: 'Simulated server error',\n    );\n  }\n\n  static void simulateUserError() {\n    UserActionTracker.trackUserError(\n      action: 'button_tap',\n      screen: 'test_screen',\n      errorMessage: 'Simulated user action error',\n    );\n  }\n\n  static void simulatePerformanceIssue() {\n    PerformanceMonitor.startTrace('slow_operation');\n\n    // Simulate slow operation\n    Future.delayed(const Duration(seconds: 6), () {\n      PerformanceMonitor.stopTrace('slow_operation');\n    });\n  }\n}\n</code></pre> <p>Crash reporting and error monitoring are essential for maintaining app quality. Implement comprehensive error tracking, monitor performance metrics, and use the data to continuously improve your application's stability and user experience.</p>"},{"location":"monitoring/performance/","title":"Performance Monitoring","text":"<p>Comprehensive guide to monitoring and optimizing Flutter application performance in production.</p>"},{"location":"monitoring/performance/#overview","title":"Overview","text":"<p>Performance monitoring helps identify bottlenecks, track user experience metrics, and ensure optimal app performance. This guide covers tools, techniques, and best practices for monitoring Flutter app performance.</p>"},{"location":"monitoring/performance/#firebase-performance-monitoring","title":"Firebase Performance Monitoring","text":""},{"location":"monitoring/performance/#1-setup-and-configuration","title":"1. Setup and Configuration","text":"<pre><code># pubspec.yaml\ndependencies:\n  firebase_core: ^2.24.2\n  firebase_performance: ^0.9.3+8\n  firebase_analytics: ^10.7.4\n\ndev_dependencies:\n  firebase_performance_platform_interface: ^0.1.4+8\n</code></pre> <pre><code>// lib/main.dart\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_performance/firebase_performance.dart';\n\nFuture&lt;void&gt; main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize Firebase\n  await Firebase.initializeApp();\n\n  // Enable performance monitoring\n  FirebasePerformance performance = FirebasePerformance.instance;\n  await performance.setPerformanceCollectionEnabled(true);\n\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"monitoring/performance/#2-custom-performance-traces","title":"2. Custom Performance Traces","text":"<pre><code>// lib/services/performance_service.dart\nimport 'package:firebase_performance/firebase_performance.dart';\n\nclass PerformanceService {\n  static final FirebasePerformance _performance = FirebasePerformance.instance;\n  static final Map&lt;String, Trace&gt; _activeTraces = {};\n\n  // Start a custom trace\n  static Future&lt;void&gt; startTrace(String traceName) async {\n    final trace = _performance.newTrace(traceName);\n    await trace.start();\n    _activeTraces[traceName] = trace;\n  }\n\n  // Stop a custom trace\n  static Future&lt;void&gt; stopTrace(String traceName) async {\n    final trace = _activeTraces.remove(traceName);\n    if (trace != null) {\n      await trace.stop();\n    }\n  }\n\n  // Add custom attributes to trace\n  static Future&lt;void&gt; setTraceAttribute(\n    String traceName,\n    String attributeName,\n    String value,\n  ) async {\n    final trace = _activeTraces[traceName];\n    if (trace != null) {\n      trace.setMetric(attributeName, int.tryParse(value) ?? 0);\n    }\n  }\n\n  // Increment trace metric\n  static Future&lt;void&gt; incrementTraceMetric(\n    String traceName,\n    String metricName,\n    int value,\n  ) async {\n    final trace = _activeTraces[traceName];\n    if (trace != null) {\n      trace.incrementMetric(metricName, value);\n    }\n  }\n\n  // Track app start time\n  static Future&lt;void&gt; trackAppStartTime() async {\n    final trace = _performance.newTrace('app_start');\n    await trace.start();\n\n    // This would be called when app is fully loaded\n    WidgetsBinding.instance.addPostFrameCallback((_) async {\n      await trace.stop();\n    });\n  }\n\n  // Track screen load time\n  static Future&lt;void&gt; trackScreenLoad(String screenName) async {\n    final trace = _performance.newTrace('screen_load_$screenName');\n    await trace.start();\n\n    // Stop trace after a delay (or when screen is fully loaded)\n    Future.delayed(const Duration(milliseconds: 500), () async {\n      await trace.stop();\n    });\n  }\n\n  // Track network request performance\n  static Future&lt;void&gt; trackNetworkRequest({\n    required String url,\n    required String method,\n    required int statusCode,\n    required int requestSize,\n    required int responseSize,\n    required Duration duration,\n  }) async {\n    final httpMetric = _performance.newHttpMetric(url, HttpMethod.values.firstWhere(\n      (m) =&gt; m.toString().split('.').last.toUpperCase() == method.toUpperCase(),\n      orElse: () =&gt; HttpMethod.Get,\n    ));\n\n    httpMetric.requestPayloadSize = requestSize;\n    httpMetric.responsePayloadSize = responseSize;\n    httpMetric.httpResponseCode = statusCode;\n\n    await httpMetric.start();\n\n    // Simulate the request duration\n    await Future.delayed(duration);\n\n    await httpMetric.stop();\n  }\n}\n</code></pre>"},{"location":"monitoring/performance/#custom-performance-monitoring","title":"Custom Performance Monitoring","text":""},{"location":"monitoring/performance/#1-frame-rate-monitoring","title":"1. Frame Rate Monitoring","text":"<pre><code>// lib/services/frame_rate_monitor.dart\nclass FrameRateMonitor {\n  static final List&lt;Duration&gt; _frameTimes = [];\n  static DateTime? _lastFrameTime;\n  static int _frameCount = 0;\n  static double _averageFps = 60.0;\n\n  static void startMonitoring() {\n    WidgetsBinding.instance.addPersistentFrameCallback(_onFrame);\n  }\n\n  static void stopMonitoring() {\n    WidgetsBinding.instance.removePersistentFrameCallback(_onFrame);\n  }\n\n  static void _onFrame(Duration timestamp) {\n    final now = DateTime.now();\n\n    if (_lastFrameTime != null) {\n      final frameDuration = now.difference(_lastFrameTime!);\n      _frameTimes.add(frameDuration);\n\n      // Keep only recent frame times (last 60 frames)\n      if (_frameTimes.length &gt; 60) {\n        _frameTimes.removeAt(0);\n      }\n\n      // Calculate average FPS\n      if (_frameTimes.isNotEmpty) {\n        final averageFrameTime = _frameTimes.fold&lt;Duration&gt;(\n          Duration.zero,\n          (sum, duration) =&gt; sum + duration,\n        ) ~/ _frameTimes.length;\n\n        _averageFps = 1000.0 / averageFrameTime.inMilliseconds;\n      }\n\n      // Track poor performance\n      if (_averageFps &lt; 30) {\n        PerformanceService.setTraceAttribute(\n          'frame_rate_monitoring',\n          'low_fps_detected',\n          _averageFps.toString(),\n        );\n      }\n    }\n\n    _lastFrameTime = now;\n    _frameCount++;\n  }\n\n  static double get averageFps =&gt; _averageFps;\n  static int get frameCount =&gt; _frameCount;\n\n  static Map&lt;String, dynamic&gt; getFrameRateMetrics() {\n    return {\n      'average_fps': _averageFps,\n      'frame_count': _frameCount,\n      'recent_frame_times': _frameTimes.map((d) =&gt; d.inMilliseconds).toList(),\n    };\n  }\n}\n</code></pre>"},{"location":"monitoring/performance/#2-memory-usage-monitoring","title":"2. Memory Usage Monitoring","text":"<pre><code>// lib/services/memory_monitor.dart\nimport 'dart:developer' as developer;\nimport 'dart:io';\n\nclass MemoryMonitor {\n  static Timer? _monitoringTimer;\n  static final List&lt;MemorySnapshot&gt; _snapshots = [];\n\n  static void startMonitoring({Duration interval = const Duration(seconds: 30)}) {\n    _monitoringTimer = Timer.periodic(interval, (_) {\n      _takeMemorySnapshot();\n    });\n  }\n\n  static void stopMonitoring() {\n    _monitoringTimer?.cancel();\n    _monitoringTimer = null;\n  }\n\n  static void _takeMemorySnapshot() {\n    final info = developer.Service.getIsolateMemoryUsage(\n      developer.Service.getIsolateID(Isolate.current)!,\n    );\n\n    info.then((usage) {\n      final snapshot = MemorySnapshot(\n        timestamp: DateTime.now(),\n        heapUsage: usage['heapUsage'] ?? 0,\n        heapCapacity: usage['heapCapacity'] ?? 0,\n        externalUsage: usage['externalUsage'] ?? 0,\n      );\n\n      _snapshots.add(snapshot);\n\n      // Keep only recent snapshots (last 100)\n      if (_snapshots.length &gt; 100) {\n        _snapshots.removeAt(0);\n      }\n\n      // Check for memory leaks\n      _checkForMemoryLeaks();\n    });\n  }\n\n  static void _checkForMemoryLeaks() {\n    if (_snapshots.length &lt; 10) return;\n\n    final recent = _snapshots.takeLast(10).toList();\n    final trend = _calculateMemoryTrend(recent);\n\n    // If memory usage is consistently increasing\n    if (trend &gt; 0.1) {\n      PerformanceService.setTraceAttribute(\n        'memory_monitoring',\n        'potential_memory_leak',\n        trend.toString(),\n      );\n    }\n  }\n\n  static double _calculateMemoryTrend(List&lt;MemorySnapshot&gt; snapshots) {\n    if (snapshots.length &lt; 2) return 0.0;\n\n    final first = snapshots.first.heapUsage;\n    final last = snapshots.last.heapUsage;\n\n    return (last - first) / first;\n  }\n\n  static List&lt;MemorySnapshot&gt; getMemorySnapshots() =&gt; List.from(_snapshots);\n\n  static MemorySnapshot? getCurrentMemoryUsage() {\n    return _snapshots.isNotEmpty ? _snapshots.last : null;\n  }\n}\n\nclass MemorySnapshot {\n  final DateTime timestamp;\n  final int heapUsage;\n  final int heapCapacity;\n  final int externalUsage;\n\n  MemorySnapshot({\n    required this.timestamp,\n    required this.heapUsage,\n    required this.heapCapacity,\n    required this.externalUsage,\n  });\n\n  double get heapUtilization =&gt; heapCapacity &gt; 0 ? heapUsage / heapCapacity : 0.0;\n  int get totalUsage =&gt; heapUsage + externalUsage;\n}\n</code></pre>"},{"location":"monitoring/performance/#3-network-performance-monitoring","title":"3. Network Performance Monitoring","text":"<pre><code>// lib/services/network_performance_monitor.dart\nclass NetworkPerformanceMonitor {\n  static final List&lt;NetworkMetric&gt; _metrics = [];\n\n  static void trackRequest({\n    required String url,\n    required String method,\n    required DateTime startTime,\n    required DateTime endTime,\n    required int statusCode,\n    required int requestSize,\n    required int responseSize,\n    String? errorMessage,\n  }) {\n    final metric = NetworkMetric(\n      url: url,\n      method: method,\n      startTime: startTime,\n      endTime: endTime,\n      statusCode: statusCode,\n      requestSize: requestSize,\n      responseSize: responseSize,\n      errorMessage: errorMessage,\n    );\n\n    _metrics.add(metric);\n\n    // Keep only recent metrics (last 1000)\n    if (_metrics.length &gt; 1000) {\n      _metrics.removeAt(0);\n    }\n\n    // Track to Firebase Performance\n    PerformanceService.trackNetworkRequest(\n      url: url,\n      method: method,\n      statusCode: statusCode,\n      requestSize: requestSize,\n      responseSize: responseSize,\n      duration: endTime.difference(startTime),\n    );\n\n    // Check for slow requests\n    final duration = endTime.difference(startTime);\n    if (duration.inSeconds &gt; 10) {\n      PerformanceService.setTraceAttribute(\n        'slow_network_request',\n        'url',\n        url,\n      );\n    }\n  }\n\n  static List&lt;NetworkMetric&gt; getNetworkMetrics() =&gt; List.from(_metrics);\n\n  static Map&lt;String, dynamic&gt; getNetworkPerformanceStats() {\n    if (_metrics.isEmpty) return {};\n\n    final durations = _metrics.map((m) =&gt; m.duration.inMilliseconds).toList();\n    final successfulRequests = _metrics.where((m) =&gt; m.statusCode &lt; 400).length;\n    final failedRequests = _metrics.length - successfulRequests;\n\n    return {\n      'total_requests': _metrics.length,\n      'successful_requests': successfulRequests,\n      'failed_requests': failedRequests,\n      'success_rate': successfulRequests / _metrics.length,\n      'average_duration_ms': durations.fold(0, (sum, d) =&gt; sum + d) / durations.length,\n      'max_duration_ms': durations.fold(0, (max, d) =&gt; d &gt; max ? d : max),\n      'min_duration_ms': durations.fold(durations.first, (min, d) =&gt; d &lt; min ? d : min),\n    };\n  }\n}\n\nclass NetworkMetric {\n  final String url;\n  final String method;\n  final DateTime startTime;\n  final DateTime endTime;\n  final int statusCode;\n  final int requestSize;\n  final int responseSize;\n  final String? errorMessage;\n\n  NetworkMetric({\n    required this.url,\n    required this.method,\n    required this.startTime,\n    required this.endTime,\n    required this.statusCode,\n    required this.requestSize,\n    required this.responseSize,\n    this.errorMessage,\n  });\n\n  Duration get duration =&gt; endTime.difference(startTime);\n  bool get isSuccessful =&gt; statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400;\n  double get throughput =&gt; responseSize / duration.inMilliseconds; // bytes per ms\n}\n</code></pre>"},{"location":"monitoring/performance/#user-experience-monitoring","title":"User Experience Monitoring","text":""},{"location":"monitoring/performance/#1-app-launch-time-tracking","title":"1. App Launch Time Tracking","text":"<pre><code>// lib/services/app_launch_tracker.dart\nclass AppLaunchTracker {\n  static DateTime? _appStartTime;\n  static DateTime? _firstFrameTime;\n  static DateTime? _appReadyTime;\n\n  static void markAppStart() {\n    _appStartTime = DateTime.now();\n  }\n\n  static void markFirstFrame() {\n    _firstFrameTime = DateTime.now();\n\n    if (_appStartTime != null) {\n      final timeToFirstFrame = _firstFrameTime!.difference(_appStartTime!);\n\n      PerformanceService.setTraceAttribute(\n        'app_launch',\n        'time_to_first_frame_ms',\n        timeToFirstFrame.inMilliseconds.toString(),\n      );\n    }\n  }\n\n  static void markAppReady() {\n    _appReadyTime = DateTime.now();\n\n    if (_appStartTime != null) {\n      final totalLaunchTime = _appReadyTime!.difference(_appStartTime!);\n\n      PerformanceService.setTraceAttribute(\n        'app_launch',\n        'total_launch_time_ms',\n        totalLaunchTime.inMilliseconds.toString(),\n      );\n\n      // Track slow app launches\n      if (totalLaunchTime.inSeconds &gt; 5) {\n        PerformanceService.setTraceAttribute(\n          'slow_app_launch',\n          'launch_time_ms',\n          totalLaunchTime.inMilliseconds.toString(),\n        );\n      }\n    }\n  }\n\n  static Map&lt;String, int?&gt; getLaunchMetrics() {\n    return {\n      'time_to_first_frame_ms': _firstFrameTime != null &amp;&amp; _appStartTime != null\n          ? _firstFrameTime!.difference(_appStartTime!).inMilliseconds\n          : null,\n      'total_launch_time_ms': _appReadyTime != null &amp;&amp; _appStartTime != null\n          ? _appReadyTime!.difference(_appStartTime!).inMilliseconds\n          : null,\n    };\n  }\n}\n</code></pre>"},{"location":"monitoring/performance/#2-screen-performance-tracking","title":"2. Screen Performance Tracking","text":"<pre><code>// lib/services/screen_performance_tracker.dart\nclass ScreenPerformanceTracker {\n  static final Map&lt;String, DateTime&gt; _screenStartTimes = {};\n  static final Map&lt;String, ScreenMetrics&gt; _screenMetrics = {};\n\n  static void trackScreenStart(String screenName) {\n    _screenStartTimes[screenName] = DateTime.now();\n    PerformanceService.startTrace('screen_$screenName');\n  }\n\n  static void trackScreenReady(String screenName) {\n    final startTime = _screenStartTimes[screenName];\n    if (startTime != null) {\n      final loadTime = DateTime.now().difference(startTime);\n\n      _screenMetrics[screenName] = ScreenMetrics(\n        screenName: screenName,\n        loadTime: loadTime,\n        timestamp: DateTime.now(),\n      );\n\n      PerformanceService.setTraceAttribute(\n        'screen_$screenName',\n        'load_time_ms',\n        loadTime.inMilliseconds.toString(),\n      );\n\n      PerformanceService.stopTrace('screen_$screenName');\n\n      // Track slow screen loads\n      if (loadTime.inSeconds &gt; 3) {\n        PerformanceService.setTraceAttribute(\n          'slow_screen_load',\n          'screen_name',\n          screenName,\n        );\n      }\n    }\n  }\n\n  static void trackScreenExit(String screenName) {\n    final startTime = _screenStartTimes.remove(screenName);\n    if (startTime != null) {\n      final sessionTime = DateTime.now().difference(startTime);\n\n      PerformanceService.setTraceAttribute(\n        'screen_session_$screenName',\n        'session_time_ms',\n        sessionTime.inMilliseconds.toString(),\n      );\n    }\n  }\n\n  static Map&lt;String, ScreenMetrics&gt; getScreenMetrics() =&gt; Map.from(_screenMetrics);\n\n  static ScreenMetrics? getScreenMetric(String screenName) =&gt; _screenMetrics[screenName];\n}\n\nclass ScreenMetrics {\n  final String screenName;\n  final Duration loadTime;\n  final DateTime timestamp;\n\n  ScreenMetrics({\n    required this.screenName,\n    required this.loadTime,\n    required this.timestamp,\n  });\n}\n</code></pre>"},{"location":"monitoring/performance/#performance-dashboard","title":"Performance Dashboard","text":""},{"location":"monitoring/performance/#1-performance-metrics-widget","title":"1. Performance Metrics Widget","text":"<pre><code>// lib/widgets/performance_dashboard.dart\nclass PerformanceDashboard extends StatefulWidget {\n  @override\n  _PerformanceDashboardState createState() =&gt; _PerformanceDashboardState();\n}\n\nclass _PerformanceDashboardState extends State&lt;PerformanceDashboard&gt; {\n  Timer? _updateTimer;\n\n  @override\n  void initState() {\n    super.initState();\n    _updateTimer = Timer.periodic(const Duration(seconds: 1), (_) {\n      if (mounted) setState(() {});\n    });\n  }\n\n  @override\n  void dispose() {\n    _updateTimer?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!kDebugMode) return const SizedBox.shrink();\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Performance Dashboard')),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            _buildFrameRateSection(),\n            const SizedBox(height: 16),\n            _buildMemorySection(),\n            const SizedBox(height: 16),\n            _buildNetworkSection(),\n            const SizedBox(height: 16),\n            _buildLaunchMetricsSection(),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildFrameRateSection() {\n    final metrics = FrameRateMonitor.getFrameRateMetrics();\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Frame Rate', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            Text('Average FPS: ${metrics['average_fps']?.toStringAsFixed(1) ?? 'N/A'}'),\n            Text('Frame Count: ${metrics['frame_count']}'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildMemorySection() {\n    final snapshot = MemoryMonitor.getCurrentMemoryUsage();\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Memory Usage', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            if (snapshot != null) ...[\n              Text('Heap Usage: ${(snapshot.heapUsage / 1024 / 1024).toStringAsFixed(1)} MB'),\n              Text('Heap Capacity: ${(snapshot.heapCapacity / 1024 / 1024).toStringAsFixed(1)} MB'),\n              Text('Utilization: ${(snapshot.heapUtilization * 100).toStringAsFixed(1)}%'),\n            ] else\n              const Text('No memory data available'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildNetworkSection() {\n    final stats = NetworkPerformanceMonitor.getNetworkPerformanceStats();\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Network Performance', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            if (stats.isNotEmpty) ...[\n              Text('Total Requests: ${stats['total_requests']}'),\n              Text('Success Rate: ${(stats['success_rate'] * 100).toStringAsFixed(1)}%'),\n              Text('Avg Duration: ${stats['average_duration_ms']?.toStringAsFixed(0)} ms'),\n            ] else\n              const Text('No network data available'),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildLaunchMetricsSection() {\n    final metrics = AppLaunchTracker.getLaunchMetrics();\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text('Launch Metrics', style: Theme.of(context).textTheme.titleMedium),\n            const SizedBox(height: 8),\n            Text('Time to First Frame: ${metrics['time_to_first_frame_ms'] ?? 'N/A'} ms'),\n            Text('Total Launch Time: ${metrics['total_launch_time_ms'] ?? 'N/A'} ms'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"monitoring/performance/#2-performance-overlay","title":"2. Performance Overlay","text":"<pre><code>// lib/widgets/performance_overlay.dart\nclass PerformanceOverlay extends StatefulWidget {\n  final Widget child;\n\n  const PerformanceOverlay({Key? key, required this.child}) : super(key: key);\n\n  @override\n  _PerformanceOverlayState createState() =&gt; _PerformanceOverlayState();\n}\n\nclass _PerformanceOverlayState extends State&lt;PerformanceOverlay&gt; {\n  bool _showOverlay = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        widget.child,\n        if (_showOverlay &amp;&amp; kDebugMode)\n          Positioned(\n            top: 100,\n            right: 16,\n            child: Container(\n              padding: const EdgeInsets.all(8),\n              decoration: BoxDecoration(\n                color: Colors.black.withOpacity(0.8),\n                borderRadius: BorderRadius.circular(8),\n              ),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                mainAxisSize: MainAxisSize.min,\n                children: [\n                  Text(\n                    'FPS: ${FrameRateMonitor.averageFps.toStringAsFixed(1)}',\n                    style: const TextStyle(color: Colors.white, fontSize: 12),\n                  ),\n                  Text(\n                    'Memory: ${_getMemoryUsage()}',\n                    style: const TextStyle(color: Colors.white, fontSize: 12),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        if (kDebugMode)\n          Positioned(\n            bottom: 100,\n            right: 16,\n            child: FloatingActionButton(\n              mini: true,\n              onPressed: () =&gt; setState(() =&gt; _showOverlay = !_showOverlay),\n              child: Icon(_showOverlay ? Icons.visibility_off : Icons.visibility),\n            ),\n          ),\n      ],\n    );\n  }\n\n  String _getMemoryUsage() {\n    final snapshot = MemoryMonitor.getCurrentMemoryUsage();\n    if (snapshot != null) {\n      return '${(snapshot.heapUsage / 1024 / 1024).toStringAsFixed(1)} MB';\n    }\n    return 'N/A';\n  }\n}\n</code></pre> <p>Performance monitoring is crucial for maintaining optimal user experience. Implement comprehensive monitoring, track key metrics, and use the data to identify and resolve performance bottlenecks proactively.</p>"},{"location":"native/flutter-cli-vs-alternatives/","title":"Flutter CLI vs Alternatives","text":"<p>Comprehensive comparison of Flutter development approaches and tooling options for different project requirements.</p>"},{"location":"native/flutter-cli-vs-alternatives/#overview","title":"Overview","text":"<p>Flutter offers multiple development approaches, each with distinct advantages and use cases. This guide helps you choose the right approach for your project.</p>"},{"location":"native/flutter-cli-vs-alternatives/#development-approaches","title":"Development Approaches","text":""},{"location":"native/flutter-cli-vs-alternatives/#1-flutter-cli-standard","title":"1. Flutter CLI (Standard)","text":"<p>The official Flutter development toolkit.</p>"},{"location":"native/flutter-cli-vs-alternatives/#advantages","title":"Advantages","text":"<ul> <li>Full control over the development environment</li> <li>Latest features and updates</li> <li>Complete customization of build processes</li> <li>Direct access to all Flutter APIs</li> <li>No vendor lock-in</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#disadvantages","title":"Disadvantages","text":"<ul> <li>Manual setup required for each platform</li> <li>More configuration needed</li> <li>Steeper learning curve for beginners</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#best-for","title":"Best For","text":"<ul> <li>Production applications</li> <li>Custom native integrations</li> <li>Performance-critical apps</li> <li>Long-term projects</li> </ul> <pre><code># Installation\nflutter create my_app\ncd my_app\nflutter run\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#2-flutter-with-firebase-recommended","title":"2. Flutter with Firebase (Recommended)","text":"<p>Flutter CLI enhanced with Firebase services.</p>"},{"location":"native/flutter-cli-vs-alternatives/#advantages_1","title":"Advantages","text":"<ul> <li>Backend services included</li> <li>Real-time database and authentication</li> <li>Cloud functions and hosting</li> <li>Analytics and crash reporting</li> <li>Easy scaling</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Vendor lock-in to Google ecosystem</li> <li>Pricing can scale with usage</li> <li>Limited customization of backend</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#best-for_1","title":"Best For","text":"<ul> <li>Rapid prototyping</li> <li>Apps requiring real-time features</li> <li>Teams without backend expertise</li> </ul> <pre><code># Setup\nflutter create my_app\ncd my_app\nfirebase init\nflutter pub add firebase_core\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#3-flutter-with-supabase","title":"3. Flutter with Supabase","text":"<p>Open-source Firebase alternative.</p>"},{"location":"native/flutter-cli-vs-alternatives/#advantages_2","title":"Advantages","text":"<ul> <li>Open source and self-hostable</li> <li>PostgreSQL database</li> <li>Real-time subscriptions</li> <li>Built-in authentication</li> <li>No vendor lock-in</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Smaller ecosystem than Firebase</li> <li>Less mature tooling</li> <li>Self-hosting complexity</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#best-for_2","title":"Best For","text":"<ul> <li>Privacy-conscious applications</li> <li>PostgreSQL preference</li> <li>Open-source requirements</li> </ul> <pre><code># Setup\nflutter create my_app\ncd my_app\nflutter pub add supabase_flutter\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#4-flutter-with-custom-backend","title":"4. Flutter with Custom Backend","text":"<p>Flutter with your own backend solution.</p>"},{"location":"native/flutter-cli-vs-alternatives/#advantages_3","title":"Advantages","text":"<ul> <li>Complete control over backend</li> <li>Technology choice freedom</li> <li>Custom business logic</li> <li>No third-party dependencies</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Higher development complexity</li> <li>Infrastructure management</li> <li>Longer development time</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#best-for_3","title":"Best For","text":"<ul> <li>Enterprise applications</li> <li>Specific technology requirements</li> <li>Existing backend systems</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#comparison-matrix","title":"Comparison Matrix","text":"Feature Flutter CLI Firebase Supabase Custom Backend Setup Complexity Medium Easy Easy High Development Speed Medium Fast Fast Slow Customization High Medium High Highest Vendor Lock-in None High Low None Scaling Manual Automatic Manual/Auto Manual Cost Free Pay-as-use Free/Paid Infrastructure Learning Curve Medium Low Low High"},{"location":"native/flutter-cli-vs-alternatives/#decision-framework","title":"Decision Framework","text":""},{"location":"native/flutter-cli-vs-alternatives/#choose-flutter-cli-when","title":"Choose Flutter CLI when:","text":"<ul> <li>Building production applications</li> <li>Need full control over the stack</li> <li>Have experienced developers</li> <li>Long-term project with custom requirements</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#choose-firebase-when","title":"Choose Firebase when:","text":"<ul> <li>Rapid prototyping needed</li> <li>Real-time features required</li> <li>Small to medium team</li> <li>Want managed backend services</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#choose-supabase-when","title":"Choose Supabase when:","text":"<ul> <li>Prefer open-source solutions</li> <li>Need PostgreSQL features</li> <li>Want Firebase-like experience without lock-in</li> <li>Privacy and data control important</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#choose-custom-backend-when","title":"Choose Custom Backend when:","text":"<ul> <li>Enterprise requirements</li> <li>Existing backend systems</li> <li>Specific technology constraints</li> <li>Maximum customization needed</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#migration-paths","title":"Migration Paths","text":""},{"location":"native/flutter-cli-vs-alternatives/#from-firebase-to-custom-backend","title":"From Firebase to Custom Backend","text":"<pre><code>// 1. Abstract your data layer\nabstract class UserRepository {\n  Future&lt;User&gt; getUser(String id);\n  Future&lt;void&gt; updateUser(User user);\n}\n\n// 2. Create Firebase implementation\nclass FirebaseUserRepository implements UserRepository {\n  // Firebase-specific implementation\n}\n\n// 3. Create custom backend implementation\nclass ApiUserRepository implements UserRepository {\n  // Custom API implementation\n}\n\n// 4. Use dependency injection\nfinal userRepository = GetIt.instance&lt;UserRepository&gt;();\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#from-supabase-to-custom-backend","title":"From Supabase to Custom Backend","text":"<pre><code>// Similar abstraction approach\nabstract class DatabaseService {\n  Future&lt;List&lt;T&gt;&gt; query&lt;T&gt;(String table);\n  Future&lt;void&gt; insert&lt;T&gt;(String table, T data);\n}\n\nclass SupabaseService implements DatabaseService {\n  // Supabase implementation\n}\n\nclass CustomApiService implements DatabaseService {\n  // Custom API implementation\n}\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#best-practices","title":"Best Practices","text":""},{"location":"native/flutter-cli-vs-alternatives/#1-architecture-independence","title":"1. Architecture Independence","text":"<pre><code>// Use repository pattern\nclass PostRepository {\n  final DatabaseService _db;\n  final StorageService _storage;\n\n  PostRepository(this._db, this._storage);\n\n  Future&lt;List&lt;Post&gt;&gt; getPosts() async {\n    return await _db.query&lt;Post&gt;('posts');\n  }\n}\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#2-environment-configuration","title":"2. Environment Configuration","text":"<pre><code>// config/app_config.dart\nclass AppConfig {\n  static const String environment = String.fromEnvironment('ENV', defaultValue: 'dev');\n\n  static String get apiUrl {\n    switch (environment) {\n      case 'prod':\n        return 'https://api.myapp.com';\n      case 'staging':\n        return 'https://staging-api.myapp.com';\n      default:\n        return 'http://localhost:3000';\n    }\n  }\n}\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#3-feature-flags","title":"3. Feature Flags","text":"<pre><code>// Use feature flags for gradual migration\nclass FeatureFlags {\n  static const bool useNewBackend = bool.fromEnvironment('USE_NEW_BACKEND');\n\n  static UserRepository getUserRepository() {\n    if (useNewBackend) {\n      return CustomUserRepository();\n    }\n    return FirebaseUserRepository();\n  }\n}\n</code></pre>"},{"location":"native/flutter-cli-vs-alternatives/#performance-considerations","title":"Performance Considerations","text":""},{"location":"native/flutter-cli-vs-alternatives/#flutter-cli","title":"Flutter CLI","text":"<ul> <li>Fastest runtime performance</li> <li>Smallest app size</li> <li>Direct native access</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#firebase","title":"Firebase","text":"<ul> <li>Network latency for remote calls</li> <li>Offline capabilities with local caching</li> <li>Real-time performance excellent</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#supabase","title":"Supabase","text":"<ul> <li>PostgreSQL performance benefits</li> <li>Real-time subscriptions efficient</li> <li>Self-hosting can improve latency</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#custom-backend","title":"Custom Backend","text":"<ul> <li>Optimized for specific use cases</li> <li>Caching strategies customizable</li> <li>Database choice flexibility</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#security-implications","title":"Security Implications","text":""},{"location":"native/flutter-cli-vs-alternatives/#flutter-cli_1","title":"Flutter CLI","text":"<ul> <li>Full responsibility for security</li> <li>Custom authentication implementation</li> <li>Manual security updates</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#firebase_1","title":"Firebase","text":"<ul> <li>Google security standards</li> <li>Built-in security rules</li> <li>Automatic security updates</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#supabase_1","title":"Supabase","text":"<ul> <li>Row Level Security (RLS)</li> <li>PostgreSQL security features</li> <li>Self-hosted security control</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#custom-backend_1","title":"Custom Backend","text":"<ul> <li>Complete control over security</li> <li>Custom security implementation</li> <li>Manual security management</li> </ul>"},{"location":"native/flutter-cli-vs-alternatives/#conclusion","title":"Conclusion","text":"<p>The choice between Flutter development approaches depends on your specific requirements:</p> <ul> <li>Start with Flutter CLI for maximum flexibility</li> <li>Add Firebase for rapid development with managed services</li> <li>Consider Supabase for open-source Firebase alternative</li> <li>Build custom backend for enterprise or specific requirements</li> </ul> <p>Remember that you can always migrate between approaches as your project evolves, especially if you follow good architectural patterns from the beginning.</p>"},{"location":"native/flutter-cli-vs-alternatives/#next-steps","title":"Next Steps","text":"<ol> <li>Evaluate your project requirements</li> <li>Consider team expertise and timeline</li> <li>Start with the simplest approach that meets your needs</li> <li>Plan for potential future migrations</li> <li>Implement proper abstraction layers</li> </ol> <p>Choose the approach that best fits your current needs while keeping future flexibility in mind.</p>"},{"location":"native/permissions/","title":"Permissions Management","text":"<p>Comprehensive guide to handling permissions in Flutter applications across iOS, Android, and Web platforms.</p>"},{"location":"native/permissions/#overview","title":"Overview","text":"<p>Permissions are essential for accessing device features like camera, location, storage, and notifications. This guide covers permission handling, best practices, and platform-specific implementations.</p>"},{"location":"native/permissions/#permission-setup","title":"Permission Setup","text":""},{"location":"native/permissions/#1-permission-dependencies","title":"1. Permission Dependencies","text":"<pre><code># pubspec.yaml\ndependencies:\n  permission_handler: ^11.0.1\n  geolocator: ^9.0.2\n  image_picker: ^1.0.4\n  camera: ^0.10.5\n  local_auth: ^2.1.6\n</code></pre>"},{"location":"native/permissions/#2-platform-configuration","title":"2. Platform Configuration","text":""},{"location":"native/permissions/#ios-configuration-iosrunnerinfoplist","title":"iOS Configuration (ios/Runner/Info.plist)","text":"<pre><code>&lt;!-- Camera Permission --&gt;\n&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs camera access to take photos for posts&lt;/string&gt;\n\n&lt;!-- Photo Library Permission --&gt;\n&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs photo library access to select images for posts&lt;/string&gt;\n\n&lt;!-- Location Permission --&gt;\n&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs location access to show nearby content&lt;/string&gt;\n&lt;key&gt;NSLocationAlwaysAndWhenInUseUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs location access to show nearby content&lt;/string&gt;\n\n&lt;!-- Microphone Permission --&gt;\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs microphone access to record audio for posts&lt;/string&gt;\n\n&lt;!-- Contacts Permission --&gt;\n&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs contacts access to find friends&lt;/string&gt;\n\n&lt;!-- Notifications Permission --&gt;\n&lt;key&gt;NSUserNotificationUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs notification permission to send updates&lt;/string&gt;\n\n&lt;!-- Biometric Permission --&gt;\n&lt;key&gt;NSFaceIDUsageDescription&lt;/key&gt;\n&lt;string&gt;This app uses Face ID for secure authentication&lt;/string&gt;\n</code></pre>"},{"location":"native/permissions/#android-configuration-androidappsrcmainandroidmanifestxml","title":"Android Configuration (android/app/src/main/AndroidManifest.xml)","text":"<pre><code>&lt;!-- Internet Permission --&gt;\n&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n\n&lt;!-- Camera Permission --&gt;\n&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n&lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" /&gt;\n\n&lt;!-- Storage Permissions --&gt;\n&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n\n&lt;!-- Location Permissions --&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n\n&lt;!-- Microphone Permission --&gt;\n&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n\n&lt;!-- Contacts Permission --&gt;\n&lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt;\n\n&lt;!-- Notification Permission (Android 13+) --&gt;\n&lt;uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" /&gt;\n\n&lt;!-- Biometric Permission --&gt;\n&lt;uses-permission android:name=\"android.permission.USE_FINGERPRINT\" /&gt;\n&lt;uses-permission android:name=\"android.permission.USE_BIOMETRIC\" /&gt;\n</code></pre>"},{"location":"native/permissions/#permission-service","title":"Permission Service","text":""},{"location":"native/permissions/#1-permission-manager","title":"1. Permission Manager","text":"<pre><code>// lib/services/permission_service.dart\nimport 'package:permission_handler/permission_handler.dart';\n\nclass PermissionService {\n  // Check single permission\n  static Future&lt;bool&gt; hasPermission(Permission permission) async {\n    final status = await permission.status;\n    return status.isGranted;\n  }\n\n  // Request single permission\n  static Future&lt;bool&gt; requestPermission(Permission permission) async {\n    if (await hasPermission(permission)) {\n      return true;\n    }\n\n    final status = await permission.request();\n    return status.isGranted;\n  }\n\n  // Check multiple permissions\n  static Future&lt;Map&lt;Permission, bool&gt;&gt; hasPermissions(List&lt;Permission&gt; permissions) async {\n    final Map&lt;Permission, bool&gt; results = {};\n\n    for (final permission in permissions) {\n      results[permission] = await hasPermission(permission);\n    }\n\n    return results;\n  }\n\n  // Request multiple permissions\n  static Future&lt;Map&lt;Permission, bool&gt;&gt; requestPermissions(List&lt;Permission&gt; permissions) async {\n    final Map&lt;Permission, bool&gt; results = {};\n\n    for (final permission in permissions) {\n      results[permission] = await requestPermission(permission);\n    }\n\n    return results;\n  }\n\n  // Check if permission is permanently denied\n  static Future&lt;bool&gt; isPermanentlyDenied(Permission permission) async {\n    final status = await permission.status;\n    return status.isPermanentlyDenied;\n  }\n\n  // Open app settings\n  static Future&lt;void&gt; openAppSettings() async {\n    await openAppSettings();\n  }\n}\n</code></pre>"},{"location":"native/permissions/#2-specific-permission-handlers","title":"2. Specific Permission Handlers","text":"<pre><code>// lib/services/specific_permissions.dart\nclass CameraPermissionHandler {\n  static Future&lt;bool&gt; requestCameraPermission() async {\n    return await PermissionService.requestPermission(Permission.camera);\n  }\n\n  static Future&lt;bool&gt; hasCameraPermission() async {\n    return await PermissionService.hasPermission(Permission.camera);\n  }\n\n  static Future&lt;void&gt; handleCameraPermission(BuildContext context) async {\n    if (!await hasCameraPermission()) {\n      final granted = await requestCameraPermission();\n\n      if (!granted) {\n        if (await PermissionService.isPermanentlyDenied(Permission.camera)) {\n          _showPermissionDeniedDialog(context, 'Camera');\n        } else {\n          _showPermissionRequiredDialog(context, 'Camera');\n        }\n      }\n    }\n  }\n\n  static void _showPermissionDeniedDialog(BuildContext context, String permission) {\n    showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: Text('$permission Permission Required'),\n        content: Text(\n          '$permission permission is required for this feature. '\n          'Please enable it in app settings.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.of(context).pop();\n              PermissionService.openAppSettings();\n            },\n            child: const Text('Settings'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  static void _showPermissionRequiredDialog(BuildContext context, String permission) {\n    showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: Text('$permission Permission Required'),\n        content: Text('This app needs $permission permission to function properly.'),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('OK'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass LocationPermissionHandler {\n  static Future&lt;bool&gt; requestLocationPermission() async {\n    return await PermissionService.requestPermission(Permission.location);\n  }\n\n  static Future&lt;bool&gt; hasLocationPermission() async {\n    return await PermissionService.hasPermission(Permission.location);\n  }\n\n  static Future&lt;LocationPermissionStatus&gt; getLocationPermissionStatus() async {\n    final status = await Permission.location.status;\n\n    if (status.isGranted) return LocationPermissionStatus.granted;\n    if (status.isDenied) return LocationPermissionStatus.denied;\n    if (status.isPermanentlyDenied) return LocationPermissionStatus.permanentlyDenied;\n    if (status.isRestricted) return LocationPermissionStatus.restricted;\n\n    return LocationPermissionStatus.unknown;\n  }\n}\n\nenum LocationPermissionStatus {\n  granted,\n  denied,\n  permanentlyDenied,\n  restricted,\n  unknown,\n}\n\nclass StoragePermissionHandler {\n  static Future&lt;bool&gt; requestStoragePermission() async {\n    if (Platform.isAndroid) {\n      // Android 13+ uses different permissions\n      if (await _isAndroid13OrHigher()) {\n        return await PermissionService.requestPermissions([\n          Permission.photos,\n          Permission.videos,\n        ]).then((results) =&gt; results.values.every((granted) =&gt; granted));\n      } else {\n        return await PermissionService.requestPermission(Permission.storage);\n      }\n    }\n\n    // iOS uses photo library permission\n    return await PermissionService.requestPermission(Permission.photos);\n  }\n\n  static Future&lt;bool&gt; hasStoragePermission() async {\n    if (Platform.isAndroid) {\n      if (await _isAndroid13OrHigher()) {\n        final results = await PermissionService.hasPermissions([\n          Permission.photos,\n          Permission.videos,\n        ]);\n        return results.values.every((granted) =&gt; granted);\n      } else {\n        return await PermissionService.hasPermission(Permission.storage);\n      }\n    }\n\n    return await PermissionService.hasPermission(Permission.photos);\n  }\n\n  static Future&lt;bool&gt; _isAndroid13OrHigher() async {\n    if (!Platform.isAndroid) return false;\n\n    final androidInfo = await DeviceInfoPlugin().androidInfo;\n    return androidInfo.version.sdkInt &gt;= 33;\n  }\n}\n</code></pre>"},{"location":"native/permissions/#permission-widgets","title":"Permission Widgets","text":""},{"location":"native/permissions/#1-permission-guard-widget","title":"1. Permission Guard Widget","text":"<pre><code>// lib/widgets/permission_guard.dart\nclass PermissionGuard extends StatefulWidget {\n  final Permission permission;\n  final Widget child;\n  final Widget? fallback;\n  final String? permissionName;\n  final String? description;\n\n  const PermissionGuard({\n    Key? key,\n    required this.permission,\n    required this.child,\n    this.fallback,\n    this.permissionName,\n    this.description,\n  }) : super(key: key);\n\n  @override\n  _PermissionGuardState createState() =&gt; _PermissionGuardState();\n}\n\nclass _PermissionGuardState extends State&lt;PermissionGuard&gt; {\n  bool _hasPermission = false;\n  bool _isLoading = true;\n  bool _isPermanentlyDenied = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkPermission();\n  }\n\n  Future&lt;void&gt; _checkPermission() async {\n    final hasPermission = await PermissionService.hasPermission(widget.permission);\n    final isPermanentlyDenied = await PermissionService.isPermanentlyDenied(widget.permission);\n\n    setState(() {\n      _hasPermission = hasPermission;\n      _isPermanentlyDenied = isPermanentlyDenied;\n      _isLoading = false;\n    });\n  }\n\n  Future&lt;void&gt; _requestPermission() async {\n    final granted = await PermissionService.requestPermission(widget.permission);\n\n    setState(() {\n      _hasPermission = granted;\n    });\n\n    if (!granted) {\n      await _checkPermission(); // Check if permanently denied\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isLoading) {\n      return const Center(child: CircularProgressIndicator());\n    }\n\n    if (_hasPermission) {\n      return widget.child;\n    }\n\n    return widget.fallback ?? _buildPermissionRequest();\n  }\n\n  Widget _buildPermissionRequest() {\n    return Center(\n      child: Padding(\n        padding: const EdgeInsets.all(24),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              _getPermissionIcon(),\n              size: 64,\n              color: Colors.grey[400],\n            ),\n            const SizedBox(height: 16),\n            Text(\n              '${widget.permissionName ?? 'Permission'} Required',\n              style: Theme.of(context).textTheme.headlineSmall,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 8),\n            Text(\n              widget.description ?? \n              'This feature requires ${widget.permissionName?.toLowerCase() ?? 'permission'} access.',\n              style: Theme.of(context).textTheme.bodyMedium,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 24),\n            if (_isPermanentlyDenied)\n              ElevatedButton(\n                onPressed: () =&gt; PermissionService.openAppSettings(),\n                child: const Text('Open Settings'),\n              )\n            else\n              ElevatedButton(\n                onPressed: _requestPermission,\n                child: const Text('Grant Permission'),\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  IconData _getPermissionIcon() {\n    switch (widget.permission) {\n      case Permission.camera:\n        return Icons.camera_alt;\n      case Permission.location:\n        return Icons.location_on;\n      case Permission.microphone:\n        return Icons.mic;\n      case Permission.photos:\n        return Icons.photo_library;\n      case Permission.contacts:\n        return Icons.contacts;\n      default:\n        return Icons.security;\n    }\n  }\n}\n</code></pre>"},{"location":"native/permissions/#2-permission-status-widget","title":"2. Permission Status Widget","text":"<pre><code>// lib/widgets/permission_status_widget.dart\nclass PermissionStatusWidget extends StatefulWidget {\n  final List&lt;Permission&gt; permissions;\n\n  const PermissionStatusWidget({\n    Key? key,\n    required this.permissions,\n  }) : super(key: key);\n\n  @override\n  _PermissionStatusWidgetState createState() =&gt; _PermissionStatusWidgetState();\n}\n\nclass _PermissionStatusWidgetState extends State&lt;PermissionStatusWidget&gt; {\n  Map&lt;Permission, PermissionStatus&gt; _permissionStatuses = {};\n\n  @override\n  void initState() {\n    super.initState();\n    _checkPermissions();\n  }\n\n  Future&lt;void&gt; _checkPermissions() async {\n    final Map&lt;Permission, PermissionStatus&gt; statuses = {};\n\n    for (final permission in widget.permissions) {\n      statuses[permission] = await permission.status;\n    }\n\n    setState(() {\n      _permissionStatuses = statuses;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(\n              'Permission Status',\n              style: Theme.of(context).textTheme.titleMedium,\n            ),\n            const SizedBox(height: 12),\n            ...widget.permissions.map((permission) {\n              final status = _permissionStatuses[permission];\n              return _buildPermissionRow(permission, status);\n            }).toList(),\n            const SizedBox(height: 12),\n            ElevatedButton(\n              onPressed: _checkPermissions,\n              child: const Text('Refresh'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildPermissionRow(Permission permission, PermissionStatus? status) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4),\n      child: Row(\n        children: [\n          Icon(\n            _getPermissionIcon(permission),\n            size: 20,\n            color: _getStatusColor(status),\n          ),\n          const SizedBox(width: 12),\n          Expanded(\n            child: Text(_getPermissionName(permission)),\n          ),\n          Container(\n            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),\n            decoration: BoxDecoration(\n              color: _getStatusColor(status).withOpacity(0.1),\n              borderRadius: BorderRadius.circular(12),\n            ),\n            child: Text(\n              _getStatusText(status),\n              style: TextStyle(\n                color: _getStatusColor(status),\n                fontSize: 12,\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  IconData _getPermissionIcon(Permission permission) {\n    switch (permission) {\n      case Permission.camera:\n        return Icons.camera_alt;\n      case Permission.location:\n        return Icons.location_on;\n      case Permission.microphone:\n        return Icons.mic;\n      case Permission.photos:\n        return Icons.photo_library;\n      case Permission.contacts:\n        return Icons.contacts;\n      case Permission.notification:\n        return Icons.notifications;\n      default:\n        return Icons.security;\n    }\n  }\n\n  String _getPermissionName(Permission permission) {\n    switch (permission) {\n      case Permission.camera:\n        return 'Camera';\n      case Permission.location:\n        return 'Location';\n      case Permission.microphone:\n        return 'Microphone';\n      case Permission.photos:\n        return 'Photos';\n      case Permission.contacts:\n        return 'Contacts';\n      case Permission.notification:\n        return 'Notifications';\n      default:\n        return permission.toString().split('.').last;\n    }\n  }\n\n  Color _getStatusColor(PermissionStatus? status) {\n    switch (status) {\n      case PermissionStatus.granted:\n        return Colors.green;\n      case PermissionStatus.denied:\n        return Colors.orange;\n      case PermissionStatus.permanentlyDenied:\n        return Colors.red;\n      case PermissionStatus.restricted:\n        return Colors.grey;\n      default:\n        return Colors.grey;\n    }\n  }\n\n  String _getStatusText(PermissionStatus? status) {\n    switch (status) {\n      case PermissionStatus.granted:\n        return 'Granted';\n      case PermissionStatus.denied:\n        return 'Denied';\n      case PermissionStatus.permanentlyDenied:\n        return 'Blocked';\n      case PermissionStatus.restricted:\n        return 'Restricted';\n      default:\n        return 'Unknown';\n    }\n  }\n}\n</code></pre>"},{"location":"native/permissions/#permission-flows","title":"Permission Flows","text":""},{"location":"native/permissions/#1-camera-permission-flow","title":"1. Camera Permission Flow","text":"<pre><code>// lib/flows/camera_permission_flow.dart\nclass CameraPermissionFlow {\n  static Future&lt;bool&gt; requestCameraAccess(BuildContext context) async {\n    // Check if already granted\n    if (await CameraPermissionHandler.hasCameraPermission()) {\n      return true;\n    }\n\n    // Show explanation dialog first\n    final shouldRequest = await _showPermissionExplanation(context);\n    if (!shouldRequest) return false;\n\n    // Request permission\n    final granted = await CameraPermissionHandler.requestCameraPermission();\n\n    if (!granted) {\n      // Check if permanently denied\n      if (await PermissionService.isPermanentlyDenied(Permission.camera)) {\n        await _showPermanentlyDeniedDialog(context);\n      }\n    }\n\n    return granted;\n  }\n\n  static Future&lt;bool&gt; _showPermissionExplanation(BuildContext context) async {\n    return await showDialog&lt;bool&gt;(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Camera Access'),\n        content: const Text(\n          'This app needs camera access to take photos for your posts. '\n          'Your photos are only stored locally and shared when you choose to post them.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(false),\n            child: const Text('Not Now'),\n          ),\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(true),\n            child: const Text('Allow'),\n          ),\n        ],\n      ),\n    ) ?? false;\n  }\n\n  static Future&lt;void&gt; _showPermanentlyDeniedDialog(BuildContext context) async {\n    await showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Camera Permission Blocked'),\n        content: const Text(\n          'Camera permission has been permanently denied. '\n          'Please enable it in app settings to use this feature.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.of(context).pop();\n              PermissionService.openAppSettings();\n            },\n            child: const Text('Open Settings'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"native/permissions/#2-location-permission-flow","title":"2. Location Permission Flow","text":"<pre><code>// lib/flows/location_permission_flow.dart\nclass LocationPermissionFlow {\n  static Future&lt;bool&gt; requestLocationAccess(BuildContext context, {\n    bool showRationale = true,\n  }) async {\n    // Check current status\n    final status = await LocationPermissionHandler.getLocationPermissionStatus();\n\n    switch (status) {\n      case LocationPermissionStatus.granted:\n        return true;\n\n      case LocationPermissionStatus.denied:\n        if (showRationale) {\n          final shouldRequest = await _showLocationRationale(context);\n          if (!shouldRequest) return false;\n        }\n        return await LocationPermissionHandler.requestLocationPermission();\n\n      case LocationPermissionStatus.permanentlyDenied:\n        await _showLocationPermanentlyDenied(context);\n        return false;\n\n      case LocationPermissionStatus.restricted:\n        await _showLocationRestricted(context);\n        return false;\n\n      default:\n        return false;\n    }\n  }\n\n  static Future&lt;bool&gt; _showLocationRationale(BuildContext context) async {\n    return await showDialog&lt;bool&gt;(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Location Access'),\n        content: const Text(\n          'This app uses your location to show nearby content and improve your experience. '\n          'Your location data is not shared with third parties.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(false),\n            child: const Text('Deny'),\n          ),\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(true),\n            child: const Text('Allow'),\n          ),\n        ],\n      ),\n    ) ?? false;\n  }\n\n  static Future&lt;void&gt; _showLocationPermanentlyDenied(BuildContext context) async {\n    await showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Location Permission Required'),\n        content: const Text(\n          'Location access has been permanently denied. '\n          'Please enable it in app settings to use location features.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('Cancel'),\n          ),\n          TextButton(\n            onPressed: () {\n              Navigator.of(context).pop();\n              PermissionService.openAppSettings();\n            },\n            child: const Text('Settings'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  static Future&lt;void&gt; _showLocationRestricted(BuildContext context) async {\n    await showDialog(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Location Restricted'),\n        content: const Text(\n          'Location access is restricted on this device. '\n          'This may be due to parental controls or device management policies.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(),\n            child: const Text('OK'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"native/permissions/#testing-permissions","title":"Testing Permissions","text":""},{"location":"native/permissions/#1-permission-testing","title":"1. Permission Testing","text":"<pre><code>// test/permissions/permission_service_test.dart\nvoid main() {\n  group('Permission Service Tests', () {\n    test('should check permission status correctly', () async {\n      // Mock permission status\n      when(Permission.camera.status).thenAnswer((_) async =&gt; PermissionStatus.granted);\n\n      final hasPermission = await PermissionService.hasPermission(Permission.camera);\n      expect(hasPermission, isTrue);\n    });\n\n    test('should request permission correctly', () async {\n      when(Permission.camera.status).thenAnswer((_) async =&gt; PermissionStatus.denied);\n      when(Permission.camera.request()).thenAnswer((_) async =&gt; PermissionStatus.granted);\n\n      final granted = await PermissionService.requestPermission(Permission.camera);\n      expect(granted, isTrue);\n    });\n  });\n}\n</code></pre> <p>Proper permission handling is crucial for user trust and app functionality. Always explain why permissions are needed and provide graceful fallbacks when permissions are denied.</p>"},{"location":"native/platform-channels/","title":"Platform Channels","text":"<p>Comprehensive guide to implementing platform channels in Flutter for native iOS and Android integration.</p>"},{"location":"native/platform-channels/#overview","title":"Overview","text":"<p>Platform channels enable communication between Flutter and native platform code (iOS/Android). This is essential for accessing platform-specific APIs and integrating with native libraries.</p>"},{"location":"native/platform-channels/#channel-types","title":"Channel Types","text":""},{"location":"native/platform-channels/#1-methodchannel","title":"1. MethodChannel","text":"<p>For invoking methods on the platform side.</p> <pre><code>// Flutter side\nclass BatteryService {\n  static const platform = MethodChannel('com.example.app/battery');\n\n  Future&lt;String&gt; getBatteryLevel() async {\n    try {\n      final int result = await platform.invokeMethod('getBatteryLevel');\n      return 'Battery level at $result%.';\n    } on PlatformException catch (e) {\n      return \"Failed to get battery level: '${e.message}'.\";\n    }\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#2-eventchannel","title":"2. EventChannel","text":"<p>For streaming data from platform to Flutter.</p> <pre><code>// Flutter side\nclass LocationService {\n  static const EventChannel _eventChannel = \n      EventChannel('com.example.app/location');\n\n  Stream&lt;LocationData&gt; get locationStream {\n    return _eventChannel.receiveBroadcastStream().map(\n      (dynamic event) =&gt; LocationData.fromMap(event),\n    );\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#3-basicmessagechannel","title":"3. BasicMessageChannel","text":"<p>For basic message passing with custom codecs.</p> <pre><code>// Flutter side\nclass CustomMessageService {\n  static const BasicMessageChannel&lt;String&gt; _channel =\n      BasicMessageChannel('com.example.app/messages', StringCodec());\n\n  Future&lt;String&gt; sendMessage(String message) async {\n    final String reply = await _channel.send(message);\n    return reply;\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#ios-implementation","title":"iOS Implementation","text":""},{"location":"native/platform-channels/#methodchannel-implementation","title":"MethodChannel Implementation","text":"<pre><code>// iOS (Swift) - AppDelegate.swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -&gt; Bool {\n\n    let controller : FlutterViewController = window?.rootViewController as! FlutterViewController\n    let batteryChannel = FlutterMethodChannel(name: \"com.example.app/battery\",\n                                              binaryMessenger: controller.binaryMessenger)\n\n    batteryChannel.setMethodCallHandler({\n      (call: FlutterMethodCall, result: @escaping FlutterResult) -&gt; Void in\n\n      guard call.method == \"getBatteryLevel\" else {\n        result(FlutterMethodNotImplemented)\n        return\n      }\n\n      self.receiveBatteryLevel(result: result)\n    })\n\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n\n  private func receiveBatteryLevel(result: FlutterResult) {\n    let device = UIDevice.current\n    device.isBatteryMonitoringEnabled = true\n\n    if device.batteryState == UIDevice.BatteryState.unknown {\n      result(FlutterError(code: \"UNAVAILABLE\",\n                         message: \"Battery level not available.\",\n                         details: nil))\n    } else {\n      result(Int(device.batteryLevel * 100))\n    }\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#eventchannel-implementation","title":"EventChannel Implementation","text":"<pre><code>// iOS (Swift) - Location streaming\nclass LocationStreamHandler: NSObject, FlutterStreamHandler {\n  private var locationManager: CLLocationManager?\n  private var eventSink: FlutterEventSink?\n\n  func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -&gt; FlutterError? {\n    self.eventSink = events\n\n    locationManager = CLLocationManager()\n    locationManager?.delegate = self\n    locationManager?.requestWhenInUseAuthorization()\n    locationManager?.startUpdatingLocation()\n\n    return nil\n  }\n\n  func onCancel(withArguments arguments: Any?) -&gt; FlutterError? {\n    locationManager?.stopUpdatingLocation()\n    locationManager = nil\n    eventSink = nil\n    return nil\n  }\n}\n\nextension LocationStreamHandler: CLLocationManagerDelegate {\n  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n    guard let location = locations.last else { return }\n\n    let locationData = [\n      \"latitude\": location.coordinate.latitude,\n      \"longitude\": location.coordinate.longitude,\n      \"accuracy\": location.horizontalAccuracy\n    ]\n\n    eventSink?(locationData)\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#android-implementation","title":"Android Implementation","text":""},{"location":"native/platform-channels/#methodchannel-implementation_1","title":"MethodChannel Implementation","text":"<pre><code>// Android (Kotlin) - MainActivity.kt\npackage com.example.app\n\nimport android.content.Context\nimport android.content.ContextWrapper\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.os.BatteryManager\nimport android.os.Build.VERSION\nimport android.os.Build.VERSION_CODES\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity: FlutterActivity() {\n    private val CHANNEL = \"com.example.app/battery\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -&gt;\n            when (call.method) {\n                \"getBatteryLevel\" -&gt; {\n                    val batteryLevel = getBatteryLevel()\n                    if (batteryLevel != -1) {\n                        result.success(batteryLevel)\n                    } else {\n                        result.error(\"UNAVAILABLE\", \"Battery level not available.\", null)\n                    }\n                }\n                else -&gt; result.notImplemented()\n            }\n        }\n    }\n\n    private fun getBatteryLevel(): Int {\n        val batteryLevel: Int\n        if (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) {\n            val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n            batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n        } else {\n            val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))\n            batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        }\n        return batteryLevel\n    }\n}\n</code></pre>"},{"location":"native/platform-channels/#eventchannel-implementation_1","title":"EventChannel Implementation","text":"<pre><code>// Android (Kotlin) - Location streaming\nimport io.flutter.plugin.common.EventChannel\nimport android.location.LocationManager\nimport android.location.LocationListener\n\nclass LocationStreamHandler : EventChannel.StreamHandler, LocationListener {\n    private var locationManager: LocationManager? = null\n    private var eventSink: EventChannel.EventSink? = null\n\n    override fun onListen(arguments: Any?, events: EventChannel.EventSink?) {\n        eventSink = events\n        locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager\n\n        try {\n            locationManager?.requestLocationUpdates(\n                LocationManager.GPS_PROVIDER,\n                1000L, // minimum time interval\n                1f,    // minimum distance\n                this\n            )\n        } catch (e: SecurityException) {\n            eventSink?.error(\"PERMISSION_DENIED\", \"Location permission not granted\", null)\n        }\n    }\n\n    override fun onCancel(arguments: Any?) {\n        locationManager?.removeUpdates(this)\n        locationManager = null\n        eventSink = null\n    }\n\n    override fun onLocationChanged(location: Location) {\n        val locationData = mapOf(\n            \"latitude\" to location.latitude,\n            \"longitude\" to location.longitude,\n            \"accuracy\" to location.accuracy.toDouble()\n        )\n        eventSink?.success(locationData)\n    }\n}\n</code></pre>"},{"location":"native/platform-channels/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"native/platform-channels/#1-plugin-architecture","title":"1. Plugin Architecture","text":"<pre><code>// Create a proper plugin structure\nclass CameraPlugin {\n  static const MethodChannel _channel = MethodChannel('camera_plugin');\n\n  static Future&lt;String&gt; takePicture() async {\n    final String path = await _channel.invokeMethod('takePicture');\n    return path;\n  }\n\n  static Future&lt;void&gt; setFlashMode(bool enabled) async {\n    await _channel.invokeMethod('setFlashMode', {'enabled': enabled});\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#2-error-handling","title":"2. Error Handling","text":"<pre><code>class PlatformService {\n  static const MethodChannel _channel = MethodChannel('platform_service');\n\n  static Future&lt;T&gt; safeInvoke&lt;T&gt;(String method, [dynamic arguments]) async {\n    try {\n      return await _channel.invokeMethod&lt;T&gt;(method, arguments);\n    } on PlatformException catch (e) {\n      throw PlatformServiceException(\n        code: e.code,\n        message: e.message ?? 'Unknown platform error',\n        details: e.details,\n      );\n    } catch (e) {\n      throw PlatformServiceException(\n        code: 'UNKNOWN_ERROR',\n        message: e.toString(),\n      );\n    }\n  }\n}\n\nclass PlatformServiceException implements Exception {\n  final String code;\n  final String message;\n  final dynamic details;\n\n  PlatformServiceException({\n    required this.code,\n    required this.message,\n    this.details,\n  });\n}\n</code></pre>"},{"location":"native/platform-channels/#3-type-safety","title":"3. Type Safety","text":"<pre><code>// Use proper data models\nclass LocationData {\n  final double latitude;\n  final double longitude;\n  final double accuracy;\n\n  LocationData({\n    required this.latitude,\n    required this.longitude,\n    required this.accuracy,\n  });\n\n  factory LocationData.fromMap(Map&lt;dynamic, dynamic&gt; map) {\n    return LocationData(\n      latitude: (map['latitude'] as num).toDouble(),\n      longitude: (map['longitude'] as num).toDouble(),\n      accuracy: (map['accuracy'] as num).toDouble(),\n    );\n  }\n\n  Map&lt;String, dynamic&gt; toMap() {\n    return {\n      'latitude': latitude,\n      'longitude': longitude,\n      'accuracy': accuracy,\n    };\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#testing-platform-channels","title":"Testing Platform Channels","text":""},{"location":"native/platform-channels/#unit-testing","title":"Unit Testing","text":"<pre><code>// test/platform_channel_test.dart\nimport 'package:flutter/services.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  const MethodChannel channel = MethodChannel('com.example.app/battery');\n\n  setUp(() {\n    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger\n        .setMockMethodCallHandler(channel, (MethodCall methodCall) async {\n      if (methodCall.method == 'getBatteryLevel') {\n        return 42;\n      }\n      return null;\n    });\n  });\n\n  tearDown(() {\n    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger\n        .setMockMethodCallHandler(channel, null);\n  });\n\n  test('getBatteryLevel', () async {\n    final BatteryService service = BatteryService();\n    final String result = await service.getBatteryLevel();\n    expect(result, 'Battery level at 42%.');\n  });\n}\n</code></pre>"},{"location":"native/platform-channels/#integration-testing","title":"Integration Testing","text":"<pre><code>// integration_test/platform_channel_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Platform Channel Integration', () {\n    testWidgets('battery level returns valid value', (tester) async {\n      final service = BatteryService();\n      final result = await service.getBatteryLevel();\n\n      expect(result, contains('Battery level at'));\n      expect(result, contains('%'));\n    });\n  });\n}\n</code></pre>"},{"location":"native/platform-channels/#best-practices","title":"Best Practices","text":""},{"location":"native/platform-channels/#1-channel-naming","title":"1. Channel Naming","text":"<pre><code>// Use reverse domain notation\nstatic const String channelName = 'com.yourcompany.yourapp/feature';\n</code></pre>"},{"location":"native/platform-channels/#2-method-naming","title":"2. Method Naming","text":"<pre><code>// Use clear, descriptive method names\nawait channel.invokeMethod('getUserLocation');\nawait channel.invokeMethod('startLocationUpdates');\nawait channel.invokeMethod('stopLocationUpdates');\n</code></pre>"},{"location":"native/platform-channels/#3-data-serialization","title":"3. Data Serialization","text":"<pre><code>// Use consistent data formats\nclass ApiResponse {\n  final bool success;\n  final String? error;\n  final Map&lt;String, dynamic&gt;? data;\n\n  factory ApiResponse.fromMap(Map&lt;dynamic, dynamic&gt; map) {\n    return ApiResponse(\n      success: map['success'] as bool,\n      error: map['error'] as String?,\n      data: map['data'] as Map&lt;String, dynamic&gt;?,\n    );\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#4-resource-management","title":"4. Resource Management","text":"<pre><code>// Properly dispose of resources\nclass LocationService {\n  StreamSubscription? _subscription;\n\n  void startListening() {\n    _subscription = locationStream.listen((location) {\n      // Handle location updates\n    });\n  }\n\n  void dispose() {\n    _subscription?.cancel();\n    _subscription = null;\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#common-use-cases","title":"Common Use Cases","text":""},{"location":"native/platform-channels/#1-device-information","title":"1. Device Information","text":"<pre><code>// Get device-specific information\nclass DeviceInfo {\n  static const MethodChannel _channel = MethodChannel('device_info');\n\n  static Future&lt;Map&lt;String, String&gt;&gt; getDeviceInfo() async {\n    final Map&lt;dynamic, dynamic&gt; info = await _channel.invokeMethod('getDeviceInfo');\n    return Map&lt;String, String&gt;.from(info);\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#2-native-ui-components","title":"2. Native UI Components","text":"<pre><code>// Integrate native UI components\nclass NativeMapView extends StatefulWidget {\n  @override\n  _NativeMapViewState createState() =&gt; _NativeMapViewState();\n}\n\nclass _NativeMapViewState extends State&lt;NativeMapView&gt; {\n  static const String viewType = 'native_map_view';\n\n  @override\n  Widget build(BuildContext context) {\n    if (Platform.isAndroid) {\n      return AndroidView(\n        viewType: viewType,\n        onPlatformViewCreated: _onPlatformViewCreated,\n      );\n    } else if (Platform.isIOS) {\n      return UiKitView(\n        viewType: viewType,\n        onPlatformViewCreated: _onPlatformViewCreated,\n      );\n    }\n    return Text('Platform not supported');\n  }\n\n  void _onPlatformViewCreated(int id) {\n    // Initialize platform view\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#3-background-processing","title":"3. Background Processing","text":"<pre><code>// Handle background tasks\nclass BackgroundService {\n  static const MethodChannel _channel = MethodChannel('background_service');\n\n  static Future&lt;void&gt; startBackgroundTask() async {\n    await _channel.invokeMethod('startBackgroundTask');\n  }\n\n  static Future&lt;void&gt; stopBackgroundTask() async {\n    await _channel.invokeMethod('stopBackgroundTask');\n  }\n}\n</code></pre>"},{"location":"native/platform-channels/#troubleshooting","title":"Troubleshooting","text":""},{"location":"native/platform-channels/#common-issues","title":"Common Issues","text":"<ol> <li>Channel not found: Ensure channel names match exactly</li> <li>Method not implemented: Check method name spelling</li> <li>Type casting errors: Verify data types match expectations</li> <li>Permission errors: Handle platform permissions properly</li> </ol>"},{"location":"native/platform-channels/#debugging-tips","title":"Debugging Tips","text":"<pre><code>// Add logging for debugging\nclass DebugChannel {\n  static const MethodChannel _channel = MethodChannel('debug_channel');\n\n  static Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [dynamic arguments]) async {\n    print('Invoking method: $method with arguments: $arguments');\n    try {\n      final result = await _channel.invokeMethod&lt;T&gt;(method, arguments);\n      print('Method result: $result');\n      return result;\n    } catch (e) {\n      print('Method error: $e');\n      rethrow;\n    }\n  }\n}\n</code></pre> <p>Platform channels are powerful tools for accessing native functionality. Use them judiciously and always consider if existing plugins can meet your needs before implementing custom channels.</p>"},{"location":"native/platform-specific/","title":"Platform-Specific Implementation","text":"<p>Comprehensive guide to implementing platform-specific features and handling differences between iOS, Android, and Web in Flutter applications.</p>"},{"location":"native/platform-specific/#overview","title":"Overview","text":"<p>Platform-specific implementation allows you to leverage unique features of each platform while maintaining a shared codebase. This guide covers platform detection, conditional compilation, and native integrations.</p>"},{"location":"native/platform-specific/#platform-detection","title":"Platform Detection","text":""},{"location":"native/platform-specific/#1-platform-utilities","title":"1. Platform Utilities","text":"<pre><code>// lib/utils/platform_utils.dart\nimport 'dart:io';\nimport 'package:flutter/foundation.dart';\n\nclass PlatformUtils {\n  // Basic platform detection\n  static bool get isIOS =&gt; !kIsWeb &amp;&amp; Platform.isIOS;\n  static bool get isAndroid =&gt; !kIsWeb &amp;&amp; Platform.isAndroid;\n  static bool get isWeb =&gt; kIsWeb;\n  static bool get isMobile =&gt; isIOS || isAndroid;\n  static bool get isDesktop =&gt; !kIsWeb &amp;&amp; (Platform.isWindows || Platform.isMacOS || Platform.isLinux);\n\n  // Detailed platform info\n  static String get platformName {\n    if (kIsWeb) return 'Web';\n    return Platform.operatingSystem;\n  }\n\n  static String get platformVersion {\n    if (kIsWeb) return 'Unknown';\n    return Platform.operatingSystemVersion;\n  }\n\n  // Feature detection\n  static bool get supportsHapticFeedback =&gt; isMobile;\n  static bool get supportsBiometrics =&gt; isMobile;\n  static bool get supportsNotifications =&gt; isMobile;\n  static bool get supportsFileSystem =&gt; !isWeb;\n  static bool get supportsCamera =&gt; isMobile;\n  static bool get supportsLocation =&gt; isMobile;\n\n  // UI capabilities\n  static bool get hasPhysicalKeyboard =&gt; isDesktop;\n  static bool get hasTouchScreen =&gt; isMobile || isWeb;\n  static bool get supportsMultiWindow =&gt; isDesktop;\n}\n</code></pre>"},{"location":"native/platform-specific/#2-conditional-compilation","title":"2. Conditional Compilation","text":"<pre><code>// lib/config/platform_config.dart\nclass PlatformConfig {\n  // API endpoints\n  static String get baseUrl {\n    if (kDebugMode) {\n      if (PlatformUtils.isWeb) {\n        return 'http://localhost:3000';\n      } else if (PlatformUtils.isAndroid) {\n        return 'http://10.0.2.2:3000'; // Android emulator\n      } else {\n        return 'http://localhost:3000'; // iOS simulator\n      }\n    }\n    return 'https://api.yourapp.com';\n  }\n\n  // Storage paths\n  static Future&lt;String&gt; get documentsPath async {\n    if (PlatformUtils.isWeb) {\n      return '/web-storage';\n    }\n    final directory = await getApplicationDocumentsDirectory();\n    return directory.path;\n  }\n\n  // App-specific configurations\n  static Map&lt;String, dynamic&gt; get appConfig {\n    return {\n      'enableAnalytics': !kDebugMode,\n      'enableCrashReporting': PlatformUtils.isMobile &amp;&amp; !kDebugMode,\n      'enablePushNotifications': PlatformUtils.isMobile,\n      'maxImageSize': PlatformUtils.isMobile ? 1024 : 2048,\n      'cacheSize': PlatformUtils.isMobile ? 50 : 100, // MB\n    };\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#ios-specific-implementation","title":"iOS-Specific Implementation","text":""},{"location":"native/platform-specific/#1-ios-native-features","title":"1. iOS Native Features","text":"<pre><code>// lib/platform/ios/ios_features.dart\nimport 'package:flutter/services.dart';\n\nclass IOSFeatures {\n  static const MethodChannel _channel = MethodChannel('ios_features');\n\n  // Haptic feedback\n  static Future&lt;void&gt; lightImpact() async {\n    if (PlatformUtils.isIOS) {\n      await HapticFeedback.lightImpact();\n    }\n  }\n\n  static Future&lt;void&gt; mediumImpact() async {\n    if (PlatformUtils.isIOS) {\n      await HapticFeedback.mediumImpact();\n    }\n  }\n\n  static Future&lt;void&gt; heavyImpact() async {\n    if (PlatformUtils.isIOS) {\n      await HapticFeedback.heavyImpact();\n    }\n  }\n\n  // iOS-specific UI\n  static Future&lt;void&gt; setStatusBarStyle(String style) async {\n    if (PlatformUtils.isIOS) {\n      try {\n        await _channel.invokeMethod('setStatusBarStyle', {'style': style});\n      } catch (e) {\n        print('Failed to set status bar style: $e');\n      }\n    }\n  }\n\n  // iOS app settings\n  static Future&lt;void&gt; openAppSettings() async {\n    if (PlatformUtils.isIOS) {\n      try {\n        await _channel.invokeMethod('openAppSettings');\n      } catch (e) {\n        print('Failed to open app settings: $e');\n      }\n    }\n  }\n\n  // iOS-specific sharing\n  static Future&lt;void&gt; shareWithActivityController(String text, {String? url}) async {\n    if (PlatformUtils.isIOS) {\n      try {\n        await _channel.invokeMethod('shareWithActivityController', {\n          'text': text,\n          'url': url,\n        });\n      } catch (e) {\n        print('Failed to share: $e');\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#2-ios-configuration","title":"2. iOS Configuration","text":"<pre><code>// lib/platform/ios/ios_config.dart\nclass IOSConfig {\n  // iOS-specific app configuration\n  static const Map&lt;String, dynamic&gt; config = {\n    'bundleId': 'com.yourapp.flutter',\n    'appStoreId': '123456789',\n    'teamId': 'ABCD123456',\n    'urlScheme': 'yourapp',\n  };\n\n  // iOS permissions\n  static const List&lt;String&gt; requiredPermissions = [\n    'NSCameraUsageDescription',\n    'NSPhotoLibraryUsageDescription',\n    'NSLocationWhenInUseUsageDescription',\n    'NSMicrophoneUsageDescription',\n  ];\n\n  // iOS capabilities\n  static const List&lt;String&gt; capabilities = [\n    'com.apple.developer.associated-domains',\n    'com.apple.developer.in-app-payments',\n    'aps-environment',\n  ];\n}\n</code></pre>"},{"location":"native/platform-specific/#android-specific-implementation","title":"Android-Specific Implementation","text":""},{"location":"native/platform-specific/#1-android-native-features","title":"1. Android Native Features","text":"<pre><code>// lib/platform/android/android_features.dart\nimport 'package:flutter/services.dart';\n\nclass AndroidFeatures {\n  static const MethodChannel _channel = MethodChannel('android_features');\n\n  // Android-specific navigation\n  static Future&lt;void&gt; setSystemUIOverlayStyle({\n    Color? statusBarColor,\n    Color? navigationBarColor,\n    bool? statusBarIconBrightness,\n  }) async {\n    if (PlatformUtils.isAndroid) {\n      SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(\n        statusBarColor: statusBarColor,\n        navigationBarColor: navigationBarColor,\n        statusBarIconBrightness: statusBarIconBrightness != null \n            ? (statusBarIconBrightness ? Brightness.light : Brightness.dark)\n            : null,\n      ));\n    }\n  }\n\n  // Android back button handling\n  static Future&lt;bool&gt; handleBackButton() async {\n    if (PlatformUtils.isAndroid) {\n      try {\n        return await _channel.invokeMethod('handleBackButton') ?? false;\n      } catch (e) {\n        print('Failed to handle back button: $e');\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // Android-specific sharing\n  static Future&lt;void&gt; shareWithIntent(String text, {String? mimeType}) async {\n    if (PlatformUtils.isAndroid) {\n      try {\n        await _channel.invokeMethod('shareWithIntent', {\n          'text': text,\n          'mimeType': mimeType ?? 'text/plain',\n        });\n      } catch (e) {\n        print('Failed to share: $e');\n      }\n    }\n  }\n\n  // Android app info\n  static Future&lt;Map&lt;String, dynamic&gt;?&gt; getAppInfo() async {\n    if (PlatformUtils.isAndroid) {\n      try {\n        return await _channel.invokeMethod('getAppInfo');\n      } catch (e) {\n        print('Failed to get app info: $e');\n        return null;\n      }\n    }\n    return null;\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#2-android-configuration","title":"2. Android Configuration","text":"<pre><code>// lib/platform/android/android_config.dart\nclass AndroidConfig {\n  // Android-specific app configuration\n  static const Map&lt;String, dynamic&gt; config = {\n    'packageName': 'com.yourapp.flutter',\n    'versionCode': 1,\n    'minSdkVersion': 21,\n    'targetSdkVersion': 33,\n    'compileSdkVersion': 33,\n  };\n\n  // Android permissions\n  static const List&lt;String&gt; requiredPermissions = [\n    'android.permission.INTERNET',\n    'android.permission.CAMERA',\n    'android.permission.READ_EXTERNAL_STORAGE',\n    'android.permission.WRITE_EXTERNAL_STORAGE',\n    'android.permission.ACCESS_FINE_LOCATION',\n    'android.permission.ACCESS_COARSE_LOCATION',\n  ];\n\n  // Android features\n  static const List&lt;String&gt; features = [\n    'android.hardware.camera',\n    'android.hardware.location',\n    'android.hardware.location.gps',\n  ];\n}\n</code></pre>"},{"location":"native/platform-specific/#web-specific-implementation","title":"Web-Specific Implementation","text":""},{"location":"native/platform-specific/#1-web-features","title":"1. Web Features","text":"<pre><code>// lib/platform/web/web_features.dart\nimport 'dart:html' as html;\nimport 'dart:js' as js;\n\nclass WebFeatures {\n  // Web-specific navigation\n  static void setPageTitle(String title) {\n    if (PlatformUtils.isWeb) {\n      html.document.title = title;\n    }\n  }\n\n  // Web storage\n  static void setLocalStorage(String key, String value) {\n    if (PlatformUtils.isWeb) {\n      html.window.localStorage[key] = value;\n    }\n  }\n\n  static String? getLocalStorage(String key) {\n    if (PlatformUtils.isWeb) {\n      return html.window.localStorage[key];\n    }\n    return null;\n  }\n\n  // Web clipboard\n  static Future&lt;void&gt; copyToClipboard(String text) async {\n    if (PlatformUtils.isWeb) {\n      try {\n        await html.window.navigator.clipboard?.writeText(text);\n      } catch (e) {\n        // Fallback for older browsers\n        _fallbackCopyToClipboard(text);\n      }\n    }\n  }\n\n  static void _fallbackCopyToClipboard(String text) {\n    final textArea = html.TextAreaElement();\n    textArea.value = text;\n    html.document.body?.append(textArea);\n    textArea.select();\n    html.document.execCommand('copy');\n    textArea.remove();\n  }\n\n  // Web download\n  static void downloadFile(String content, String filename, {String mimeType = 'text/plain'}) {\n    if (PlatformUtils.isWeb) {\n      final blob = html.Blob([content], mimeType);\n      final url = html.Url.createObjectUrlFromBlob(blob);\n      final anchor = html.AnchorElement(href: url)\n        ..setAttribute('download', filename)\n        ..click();\n      html.Url.revokeObjectUrl(url);\n    }\n  }\n\n  // Web URL handling\n  static void openUrl(String url, {bool newTab = true}) {\n    if (PlatformUtils.isWeb) {\n      html.window.open(url, newTab ? '_blank' : '_self');\n    }\n  }\n\n  // Web analytics\n  static void trackEvent(String event, Map&lt;String, dynamic&gt; parameters) {\n    if (PlatformUtils.isWeb &amp;&amp; !kDebugMode) {\n      js.context.callMethod('gtag', ['event', event, js.JsObject.jsify(parameters)]);\n    }\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#2-web-configuration","title":"2. Web Configuration","text":"<pre><code>// lib/platform/web/web_config.dart\nclass WebConfig {\n  // Web-specific configuration\n  static const Map&lt;String, dynamic&gt; config = {\n    'baseHref': '/',\n    'title': 'Your Flutter App',\n    'description': 'A Flutter web application',\n    'keywords': 'flutter, web, app',\n    'author': 'Your Name',\n  };\n\n  // Web meta tags\n  static const Map&lt;String, String&gt; metaTags = {\n    'viewport': 'width=device-width, initial-scale=1.0',\n    'theme-color': '#2196F3',\n    'apple-mobile-web-app-capable': 'yes',\n    'apple-mobile-web-app-status-bar-style': 'default',\n  };\n\n  // PWA configuration\n  static const Map&lt;String, dynamic&gt; pwaConfig = {\n    'name': 'Your Flutter App',\n    'short_name': 'FlutterApp',\n    'start_url': '/',\n    'display': 'standalone',\n    'background_color': '#ffffff',\n    'theme_color': '#2196F3',\n  };\n}\n</code></pre>"},{"location":"native/platform-specific/#platform-adaptive-widgets","title":"Platform-Adaptive Widgets","text":""},{"location":"native/platform-specific/#1-adaptive-app-bar","title":"1. Adaptive App Bar","text":"<pre><code>// lib/widgets/adaptive_app_bar.dart\nclass AdaptiveAppBar extends StatelessWidget implements PreferredSizeWidget {\n  final String title;\n  final List&lt;Widget&gt;? actions;\n  final Widget? leading;\n  final bool automaticallyImplyLeading;\n\n  const AdaptiveAppBar({\n    Key? key,\n    required this.title,\n    this.actions,\n    this.leading,\n    this.automaticallyImplyLeading = true,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return CupertinoNavigationBar(\n        middle: Text(title),\n        trailing: actions != null ? Row(\n          mainAxisSize: MainAxisSize.min,\n          children: actions!,\n        ) : null,\n        leading: leading,\n        automaticallyImplyLeading: automaticallyImplyLeading,\n      );\n    }\n\n    return AppBar(\n      title: Text(title),\n      actions: actions,\n      leading: leading,\n      automaticallyImplyLeading: automaticallyImplyLeading,\n      elevation: PlatformUtils.isWeb ? 1 : 4,\n    );\n  }\n\n  @override\n  Size get preferredSize =&gt; const Size.fromHeight(kToolbarHeight);\n}\n</code></pre>"},{"location":"native/platform-specific/#2-adaptive-button","title":"2. Adaptive Button","text":"<pre><code>// lib/widgets/adaptive_button.dart\nclass AdaptiveButton extends StatelessWidget {\n  final String text;\n  final VoidCallback? onPressed;\n  final bool isPrimary;\n  final Color? color;\n\n  const AdaptiveButton({\n    Key? key,\n    required this.text,\n    this.onPressed,\n    this.isPrimary = true,\n    this.color,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return CupertinoButton(\n        onPressed: onPressed,\n        color: isPrimary ? (color ?? CupertinoColors.activeBlue) : null,\n        child: Text(text),\n      );\n    }\n\n    if (isPrimary) {\n      return ElevatedButton(\n        onPressed: onPressed,\n        style: color != null ? ElevatedButton.styleFrom(backgroundColor: color) : null,\n        child: Text(text),\n      );\n    }\n\n    return OutlinedButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#3-adaptive-dialog","title":"3. Adaptive Dialog","text":"<pre><code>// lib/widgets/adaptive_dialog.dart\nclass AdaptiveDialog {\n  static Future&lt;bool?&gt; showConfirmDialog(\n    BuildContext context, {\n    required String title,\n    required String content,\n    String confirmText = 'OK',\n    String cancelText = 'Cancel',\n  }) {\n    if (PlatformUtils.isIOS) {\n      return showCupertinoDialog&lt;bool&gt;(\n        context: context,\n        builder: (context) =&gt; CupertinoAlertDialog(\n          title: Text(title),\n          content: Text(content),\n          actions: [\n            CupertinoDialogAction(\n              onPressed: () =&gt; Navigator.of(context).pop(false),\n              child: Text(cancelText),\n            ),\n            CupertinoDialogAction(\n              onPressed: () =&gt; Navigator.of(context).pop(true),\n              isDefaultAction: true,\n              child: Text(confirmText),\n            ),\n          ],\n        ),\n      );\n    }\n\n    return showDialog&lt;bool&gt;(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: Text(title),\n        content: Text(content),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(false),\n            child: Text(cancelText),\n          ),\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(true),\n            child: Text(confirmText),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#platform-services","title":"Platform Services","text":""},{"location":"native/platform-specific/#1-platform-service-factory","title":"1. Platform Service Factory","text":"<pre><code>// lib/services/platform_service_factory.dart\nabstract class PlatformService {\n  Future&lt;void&gt; initialize();\n  Future&lt;void&gt; dispose();\n}\n\nclass PlatformServiceFactory {\n  static T create&lt;T extends PlatformService&gt;() {\n    if (T == NotificationService) {\n      if (PlatformUtils.isIOS) {\n        return IOSNotificationService() as T;\n      } else if (PlatformUtils.isAndroid) {\n        return AndroidNotificationService() as T;\n      } else {\n        return WebNotificationService() as T;\n      }\n    }\n\n    if (T == FileService) {\n      if (PlatformUtils.isWeb) {\n        return WebFileService() as T;\n      } else {\n        return MobileFileService() as T;\n      }\n    }\n\n    throw UnsupportedError('Service $T not supported on this platform');\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#2-platform-specific-services","title":"2. Platform-Specific Services","text":"<pre><code>// lib/services/notification_service.dart\nabstract class NotificationService extends PlatformService {\n  Future&lt;void&gt; showNotification(String title, String body);\n  Future&lt;bool&gt; requestPermission();\n}\n\nclass IOSNotificationService implements NotificationService {\n  @override\n  Future&lt;void&gt; initialize() async {\n    // iOS-specific initialization\n  }\n\n  @override\n  Future&lt;void&gt; showNotification(String title, String body) async {\n    // iOS notification implementation\n  }\n\n  @override\n  Future&lt;bool&gt; requestPermission() async {\n    // iOS permission request\n    return true;\n  }\n\n  @override\n  Future&lt;void&gt; dispose() async {\n    // iOS cleanup\n  }\n}\n\nclass AndroidNotificationService implements NotificationService {\n  @override\n  Future&lt;void&gt; initialize() async {\n    // Android-specific initialization\n  }\n\n  @override\n  Future&lt;void&gt; showNotification(String title, String body) async {\n    // Android notification implementation\n  }\n\n  @override\n  Future&lt;bool&gt; requestPermission() async {\n    // Android permission request\n    return true;\n  }\n\n  @override\n  Future&lt;void&gt; dispose() async {\n    // Android cleanup\n  }\n}\n\nclass WebNotificationService implements NotificationService {\n  @override\n  Future&lt;void&gt; initialize() async {\n    // Web-specific initialization\n  }\n\n  @override\n  Future&lt;void&gt; showNotification(String title, String body) async {\n    // Web notification implementation\n    if (PlatformUtils.isWeb) {\n      html.Notification(title, body: body);\n    }\n  }\n\n  @override\n  Future&lt;bool&gt; requestPermission() async {\n    // Web permission request\n    if (PlatformUtils.isWeb) {\n      final permission = await html.Notification.requestPermission();\n      return permission == 'granted';\n    }\n    return false;\n  }\n\n  @override\n  Future&lt;void&gt; dispose() async {\n    // Web cleanup\n  }\n}\n</code></pre>"},{"location":"native/platform-specific/#testing-platform-specific-code","title":"Testing Platform-Specific Code","text":""},{"location":"native/platform-specific/#1-platform-testing","title":"1. Platform Testing","text":"<pre><code>// test/platform/platform_utils_test.dart\nvoid main() {\n  group('Platform Utils Tests', () {\n    test('should detect platform correctly', () {\n      // Note: In tests, platform detection might not work as expected\n      // Use mocking for reliable tests\n\n      expect(PlatformUtils.platformName, isNotEmpty);\n      expect(PlatformUtils.supportsHapticFeedback, isA&lt;bool&gt;());\n    });\n\n    testWidgets('should show platform-appropriate widgets', (tester) async {\n      await tester.pumpWidget(MaterialApp(\n        home: AdaptiveButton(\n          text: 'Test',\n          onPressed: () {},\n        ),\n      ));\n\n      // Verify correct widget type is shown\n      if (PlatformUtils.isIOS) {\n        expect(find.byType(CupertinoButton), findsOneWidget);\n      } else {\n        expect(find.byType(ElevatedButton), findsOneWidget);\n      }\n    });\n  });\n}\n</code></pre> <p>Platform-specific implementation allows you to provide the best user experience on each platform while maintaining code reusability. Always provide fallbacks and test thoroughly across platforms.</p>"},{"location":"security/api-security/","title":"API Security","text":"<p>Comprehensive guide to implementing secure API communication in Flutter applications.</p>"},{"location":"security/api-security/#overview","title":"Overview","text":"<p>API security is crucial for protecting user data and preventing unauthorized access. This guide covers authentication, authorization, secure communication, and best practices for API security.</p>"},{"location":"security/api-security/#authentication-authorization","title":"Authentication &amp; Authorization","text":""},{"location":"security/api-security/#1-jwt-token-management","title":"1. JWT Token Management","text":"<pre><code>// lib/services/auth_token_service.dart\nimport 'package:jwt_decoder/jwt_decoder.dart';\n\nclass AuthTokenService {\n  static const String _accessTokenKey = 'access_token';\n  static const String _refreshTokenKey = 'refresh_token';\n\n  // Store tokens securely\n  static Future&lt;void&gt; storeTokens({\n    required String accessToken,\n    required String refreshToken,\n  }) async {\n    final secureStorage = FlutterSecureStorage();\n\n    await Future.wait([\n      secureStorage.write(key: _accessTokenKey, value: accessToken),\n      secureStorage.write(key: _refreshTokenKey, value: refreshToken),\n    ]);\n  }\n\n  // Get access token\n  static Future&lt;String?&gt; getAccessToken() async {\n    final secureStorage = FlutterSecureStorage();\n    return await secureStorage.read(key: _accessTokenKey);\n  }\n\n  // Get refresh token\n  static Future&lt;String?&gt; getRefreshToken() async {\n    final secureStorage = FlutterSecureStorage();\n    return await secureStorage.read(key: _refreshTokenKey);\n  }\n\n  // Check if token is valid\n  static Future&lt;bool&gt; isTokenValid() async {\n    final token = await getAccessToken();\n    if (token == null) return false;\n\n    try {\n      return !JwtDecoder.isExpired(token);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Get token expiry time\n  static Future&lt;DateTime?&gt; getTokenExpiry() async {\n    final token = await getAccessToken();\n    if (token == null) return null;\n\n    try {\n      return JwtDecoder.getExpirationDate(token);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Clear all tokens\n  static Future&lt;void&gt; clearTokens() async {\n    final secureStorage = FlutterSecureStorage();\n\n    await Future.wait([\n      secureStorage.delete(key: _accessTokenKey),\n      secureStorage.delete(key: _refreshTokenKey),\n    ]);\n  }\n\n  // Extract user ID from token\n  static Future&lt;String?&gt; getUserIdFromToken() async {\n    final token = await getAccessToken();\n    if (token == null) return null;\n\n    try {\n      final decodedToken = JwtDecoder.decode(token);\n      return decodedToken['sub'] ?? decodedToken['user_id'];\n    } catch (e) {\n      return null;\n    }\n  }\n}\n</code></pre>"},{"location":"security/api-security/#2-api-interceptor-for-authentication","title":"2. API Interceptor for Authentication","text":"<pre><code>// lib/services/auth_interceptor.dart\nimport 'package:dio/dio.dart';\n\nclass AuthInterceptor extends Interceptor {\n  final Dio _dio;\n  final AuthTokenService _tokenService;\n\n  AuthInterceptor(this._dio, this._tokenService);\n\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {\n    // Add access token to requests\n    final token = await _tokenService.getAccessToken();\n    if (token != null) {\n      options.headers['Authorization'] = 'Bearer $token';\n    }\n\n    // Add security headers\n    options.headers['X-Requested-With'] = 'XMLHttpRequest';\n    options.headers['Accept'] = 'application/json';\n    options.headers['Content-Type'] = 'application/json';\n\n    handler.next(options);\n  }\n\n  @override\n  void onError(DioError err, ErrorInterceptorHandler handler) async {\n    // Handle 401 Unauthorized - token expired\n    if (err.response?.statusCode == 401) {\n      try {\n        // Attempt to refresh token\n        final refreshed = await _refreshToken();\n        if (refreshed) {\n          // Retry the original request\n          final response = await _retry(err.requestOptions);\n          handler.resolve(response);\n          return;\n        }\n      } catch (e) {\n        // Refresh failed, redirect to login\n        await _handleAuthFailure();\n      }\n    }\n\n    handler.next(err);\n  }\n\n  Future&lt;bool&gt; _refreshToken() async {\n    final refreshToken = await _tokenService.getRefreshToken();\n    if (refreshToken == null) return false;\n\n    try {\n      final response = await _dio.post('/auth/refresh', data: {\n        'refresh_token': refreshToken,\n      });\n\n      final newAccessToken = response.data['access_token'];\n      final newRefreshToken = response.data['refresh_token'];\n\n      await _tokenService.storeTokens(\n        accessToken: newAccessToken,\n        refreshToken: newRefreshToken,\n      );\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  Future&lt;Response&lt;dynamic&gt;&gt; _retry(RequestOptions requestOptions) async {\n    // Add new token to retry request\n    final token = await _tokenService.getAccessToken();\n    if (token != null) {\n      requestOptions.headers['Authorization'] = 'Bearer $token';\n    }\n\n    return _dio.fetch(requestOptions);\n  }\n\n  Future&lt;void&gt; _handleAuthFailure() async {\n    // Clear tokens\n    await _tokenService.clearTokens();\n\n    // Navigate to login screen\n    // This should be handled by your navigation service\n    NavigationService.navigateToLogin();\n  }\n}\n</code></pre>"},{"location":"security/api-security/#secure-http-communication","title":"Secure HTTP Communication","text":""},{"location":"security/api-security/#1-certificate-pinning","title":"1. Certificate Pinning","text":"<pre><code>// lib/services/secure_http_client.dart\nimport 'package:dio_certificate_pinning/dio_certificate_pinning.dart';\n\nclass SecureHttpClient {\n  static Dio createSecureClient() {\n    final dio = Dio();\n\n    // Add certificate pinning\n    dio.interceptors.add(\n      CertificatePinningInterceptor(\n        allowedSHAFingerprints: [\n          'SHA256:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=', // Your server's certificate fingerprint\n        ],\n      ),\n    );\n\n    // Configure timeouts\n    dio.options.connectTimeout = const Duration(seconds: 10);\n    dio.options.receiveTimeout = const Duration(seconds: 10);\n    dio.options.sendTimeout = const Duration(seconds: 10);\n\n    // Add security headers\n    dio.options.headers.addAll({\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n    });\n\n    return dio;\n  }\n}\n</code></pre>"},{"location":"security/api-security/#2-request-signing","title":"2. Request Signing","text":"<pre><code>// lib/services/request_signer.dart\nimport 'dart:convert';\nimport 'dart:typed_data';\nimport 'package:crypto/crypto.dart';\n\nclass RequestSigner {\n  final String _secretKey;\n\n  RequestSigner(this._secretKey);\n\n  // Sign request with HMAC\n  String signRequest({\n    required String method,\n    required String path,\n    required Map&lt;String, dynamic&gt; body,\n    required int timestamp,\n  }) {\n    final payload = _createPayload(method, path, body, timestamp);\n    final key = utf8.encode(_secretKey);\n    final bytes = utf8.encode(payload);\n\n    final hmac = Hmac(sha256, key);\n    final digest = hmac.convert(bytes);\n\n    return digest.toString();\n  }\n\n  String _createPayload(\n    String method,\n    String path,\n    Map&lt;String, dynamic&gt; body,\n    int timestamp,\n  ) {\n    final bodyString = body.isNotEmpty ? jsonEncode(body) : '';\n    return '$method|$path|$bodyString|$timestamp';\n  }\n\n  // Verify response signature\n  bool verifyResponse(String signature, String responseBody) {\n    final key = utf8.encode(_secretKey);\n    final bytes = utf8.encode(responseBody);\n\n    final hmac = Hmac(sha256, key);\n    final digest = hmac.convert(bytes);\n\n    return digest.toString() == signature;\n  }\n}\n\n// Interceptor for request signing\nclass RequestSigningInterceptor extends Interceptor {\n  final RequestSigner _signer;\n\n  RequestSigningInterceptor(this._signer);\n\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    final timestamp = DateTime.now().millisecondsSinceEpoch;\n    final signature = _signer.signRequest(\n      method: options.method,\n      path: options.path,\n      body: options.data ?? {},\n      timestamp: timestamp,\n    );\n\n    options.headers['X-Timestamp'] = timestamp.toString();\n    options.headers['X-Signature'] = signature;\n\n    handler.next(options);\n  }\n}\n</code></pre>"},{"location":"security/api-security/#input-validation-sanitization","title":"Input Validation &amp; Sanitization","text":""},{"location":"security/api-security/#1-input-validator","title":"1. Input Validator","text":"<pre><code>// lib/utils/input_validator.dart\nclass InputValidator {\n  // Email validation\n  static bool isValidEmail(String email) {\n    final emailRegex = RegExp(\n      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n    );\n    return emailRegex.hasMatch(email);\n  }\n\n  // Password strength validation\n  static bool isStrongPassword(String password) {\n    if (password.length &lt; 8) return false;\n\n    final hasUppercase = password.contains(RegExp(r'[A-Z]'));\n    final hasLowercase = password.contains(RegExp(r'[a-z]'));\n    final hasDigits = password.contains(RegExp(r'[0-9]'));\n    final hasSpecialCharacters = password.contains(RegExp(r'[!@#$%^&amp;*(),.?\":{}|&lt;&gt;]'));\n\n    return hasUppercase &amp;&amp; hasLowercase &amp;&amp; hasDigits &amp;&amp; hasSpecialCharacters;\n  }\n\n  // Sanitize input to prevent XSS\n  static String sanitizeInput(String input) {\n    return input\n        .replaceAll('&lt;', '&amp;lt;')\n        .replaceAll('&gt;', '&amp;gt;')\n        .replaceAll('\"', '&amp;quot;')\n        .replaceAll(\"'\", '&amp;#x27;')\n        .replaceAll('&amp;', '&amp;amp;');\n  }\n\n  // Validate and sanitize URL\n  static String? sanitizeUrl(String url) {\n    try {\n      final uri = Uri.parse(url);\n\n      // Only allow HTTP and HTTPS\n      if (!['http', 'https'].contains(uri.scheme)) {\n        return null;\n      }\n\n      return uri.toString();\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Validate file upload\n  static bool isValidFileUpload(String filename, List&lt;String&gt; allowedExtensions) {\n    final extension = filename.split('.').last.toLowerCase();\n    return allowedExtensions.contains(extension);\n  }\n\n  // Check for SQL injection patterns\n  static bool containsSqlInjection(String input) {\n    final sqlPatterns = [\n      r\"(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\\b)\",\n      r\"(--|#|/\\*|\\*/)\",\n      r\"(\\b(OR|AND)\\s+\\d+\\s*=\\s*\\d+)\",\n      r\"(\\'\\s*(OR|AND)\\s*\\'\\w*\\'\\s*=\\s*\\'\\w*)\",\n    ];\n\n    for (final pattern in sqlPatterns) {\n      if (RegExp(pattern, caseSensitive: false).hasMatch(input)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n</code></pre>"},{"location":"security/api-security/#2-request-validation-interceptor","title":"2. Request Validation Interceptor","text":"<pre><code>// lib/services/validation_interceptor.dart\nclass ValidationInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    // Validate request data\n    if (options.data != null) {\n      final validationResult = _validateRequestData(options.data);\n      if (!validationResult.isValid) {\n        handler.reject(\n          DioError(\n            requestOptions: options,\n            error: 'Invalid request data: ${validationResult.errors.join(', ')}',\n            type: DioErrorType.other,\n          ),\n        );\n        return;\n      }\n    }\n\n    // Validate query parameters\n    if (options.queryParameters.isNotEmpty) {\n      final validationResult = _validateQueryParameters(options.queryParameters);\n      if (!validationResult.isValid) {\n        handler.reject(\n          DioError(\n            requestOptions: options,\n            error: 'Invalid query parameters: ${validationResult.errors.join(', ')}',\n            type: DioErrorType.other,\n          ),\n        );\n        return;\n      }\n    }\n\n    handler.next(options);\n  }\n\n  ValidationResult _validateRequestData(dynamic data) {\n    final errors = &lt;String&gt;[];\n\n    if (data is Map&lt;String, dynamic&gt;) {\n      for (final entry in data.entries) {\n        if (entry.value is String) {\n          final value = entry.value as String;\n\n          // Check for SQL injection\n          if (InputValidator.containsSqlInjection(value)) {\n            errors.add('${entry.key} contains potentially malicious content');\n          }\n\n          // Check for excessive length\n          if (value.length &gt; 10000) {\n            errors.add('${entry.key} exceeds maximum length');\n          }\n        }\n      }\n    }\n\n    return ValidationResult(errors.isEmpty, errors);\n  }\n\n  ValidationResult _validateQueryParameters(Map&lt;String, dynamic&gt; params) {\n    final errors = &lt;String&gt;[];\n\n    for (final entry in params.entries) {\n      final value = entry.value.toString();\n\n      // Check for SQL injection\n      if (InputValidator.containsSqlInjection(value)) {\n        errors.add('${entry.key} contains potentially malicious content');\n      }\n\n      // Check for excessive length\n      if (value.length &gt; 1000) {\n        errors.add('${entry.key} exceeds maximum length');\n      }\n    }\n\n    return ValidationResult(errors.isEmpty, errors);\n  }\n}\n\nclass ValidationResult {\n  final bool isValid;\n  final List&lt;String&gt; errors;\n\n  ValidationResult(this.isValid, this.errors);\n}\n</code></pre>"},{"location":"security/api-security/#rate-limiting-throttling","title":"Rate Limiting &amp; Throttling","text":""},{"location":"security/api-security/#1-rate-limiter","title":"1. Rate Limiter","text":"<pre><code>// lib/services/rate_limiter.dart\nclass RateLimiter {\n  final Map&lt;String, List&lt;DateTime&gt;&gt; _requests = {};\n  final int _maxRequests;\n  final Duration _timeWindow;\n\n  RateLimiter({\n    required int maxRequests,\n    required Duration timeWindow,\n  }) : _maxRequests = maxRequests,\n       _timeWindow = timeWindow;\n\n  bool canMakeRequest(String identifier) {\n    final now = DateTime.now();\n    final requests = _requests[identifier] ?? [];\n\n    // Remove old requests outside the time window\n    requests.removeWhere((time) =&gt; now.difference(time) &gt; _timeWindow);\n\n    // Check if under the limit\n    if (requests.length &lt; _maxRequests) {\n      requests.add(now);\n      _requests[identifier] = requests;\n      return true;\n    }\n\n    return false;\n  }\n\n  Duration? getRetryAfter(String identifier) {\n    final requests = _requests[identifier] ?? [];\n    if (requests.isEmpty) return null;\n\n    final oldestRequest = requests.first;\n    final retryAfter = _timeWindow - DateTime.now().difference(oldestRequest);\n\n    return retryAfter.isNegative ? null : retryAfter;\n  }\n\n  void reset(String identifier) {\n    _requests.remove(identifier);\n  }\n}\n\n// Rate limiting interceptor\nclass RateLimitingInterceptor extends Interceptor {\n  final RateLimiter _rateLimiter;\n\n  RateLimitingInterceptor(this._rateLimiter);\n\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {\n    final identifier = _getIdentifier(options);\n\n    if (!_rateLimiter.canMakeRequest(identifier)) {\n      final retryAfter = _rateLimiter.getRetryAfter(identifier);\n\n      handler.reject(\n        DioError(\n          requestOptions: options,\n          error: 'Rate limit exceeded. Retry after: ${retryAfter?.inSeconds}s',\n          type: DioErrorType.other,\n        ),\n      );\n      return;\n    }\n\n    handler.next(options);\n  }\n\n  String _getIdentifier(RequestOptions options) {\n    // Use endpoint + user ID as identifier\n    final userId = options.headers['X-User-ID'] ?? 'anonymous';\n    return '${options.path}_$userId';\n  }\n}\n</code></pre>"},{"location":"security/api-security/#error-handling-logging","title":"Error Handling &amp; Logging","text":""},{"location":"security/api-security/#1-secure-error-handler","title":"1. Secure Error Handler","text":"<pre><code>// lib/services/secure_error_handler.dart\nclass SecureErrorHandler {\n  static void handleApiError(DioError error) {\n    // Log error securely (without sensitive data)\n    final sanitizedError = _sanitizeError(error);\n    _logError(sanitizedError);\n\n    // Show user-friendly error message\n    final userMessage = _getUserFriendlyMessage(error);\n    _showErrorToUser(userMessage);\n  }\n\n  static Map&lt;String, dynamic&gt; _sanitizeError(DioError error) {\n    return {\n      'type': error.type.toString(),\n      'statusCode': error.response?.statusCode,\n      'path': error.requestOptions.path,\n      'method': error.requestOptions.method,\n      'timestamp': DateTime.now().toIso8601String(),\n      // Don't log sensitive headers or data\n    };\n  }\n\n  static void _logError(Map&lt;String, dynamic&gt; error) {\n    // Log to secure logging service\n    if (kDebugMode) {\n      print('API Error: $error');\n    } else {\n      // Send to crash reporting service\n      FirebaseCrashlytics.instance.recordError(\n        error,\n        null,\n        fatal: false,\n      );\n    }\n  }\n\n  static String _getUserFriendlyMessage(DioError error) {\n    switch (error.response?.statusCode) {\n      case 400:\n        return 'Invalid request. Please check your input.';\n      case 401:\n        return 'Authentication required. Please log in.';\n      case 403:\n        return 'Access denied. You don\\'t have permission for this action.';\n      case 404:\n        return 'The requested resource was not found.';\n      case 429:\n        return 'Too many requests. Please try again later.';\n      case 500:\n        return 'Server error. Please try again later.';\n      default:\n        return 'An unexpected error occurred. Please try again.';\n    }\n  }\n\n  static void _showErrorToUser(String message) {\n    // Show error message to user through your UI framework\n    // This could be a snackbar, dialog, or toast\n  }\n}\n</code></pre>"},{"location":"security/api-security/#security-testing","title":"Security Testing","text":""},{"location":"security/api-security/#1-api-security-tests","title":"1. API Security Tests","text":"<pre><code>// test/security/api_security_test.dart\nvoid main() {\n  group('API Security Tests', () {\n    late MockDio mockDio;\n    late AuthInterceptor authInterceptor;\n\n    setUp(() {\n      mockDio = MockDio();\n      authInterceptor = AuthInterceptor(mockDio, AuthTokenService());\n    });\n\n    test('should add authorization header to requests', () async {\n      // Arrange\n      when(AuthTokenService.getAccessToken()).thenAnswer((_) async =&gt; 'test_token');\n\n      final options = RequestOptions(path: '/test');\n      final handler = MockRequestInterceptorHandler();\n\n      // Act\n      await authInterceptor.onRequest(options, handler);\n\n      // Assert\n      expect(options.headers['Authorization'], 'Bearer test_token');\n      verify(handler.next(options)).called(1);\n    });\n\n    test('should handle 401 errors by refreshing token', () async {\n      // Arrange\n      final error = DioError(\n        requestOptions: RequestOptions(path: '/test'),\n        response: Response(\n          statusCode: 401,\n          requestOptions: RequestOptions(path: '/test'),\n        ),\n        type: DioErrorType.response,\n      );\n\n      when(AuthTokenService.getRefreshToken()).thenAnswer((_) async =&gt; 'refresh_token');\n      when(mockDio.post('/auth/refresh', data: anyNamed('data')))\n          .thenAnswer((_) async =&gt; Response(\n                data: {\n                  'access_token': 'new_access_token',\n                  'refresh_token': 'new_refresh_token',\n                },\n                statusCode: 200,\n                requestOptions: RequestOptions(path: '/auth/refresh'),\n              ));\n\n      final handler = MockErrorInterceptorHandler();\n\n      // Act\n      await authInterceptor.onError(error, handler);\n\n      // Assert\n      verify(AuthTokenService.storeTokens(\n        accessToken: 'new_access_token',\n        refreshToken: 'new_refresh_token',\n      )).called(1);\n    });\n\n    test('should validate input for SQL injection', () {\n      // Test cases\n      final testCases = [\n        {'input': \"'; DROP TABLE users; --\", 'expected': true},\n        {'input': \"normal input\", 'expected': false},\n        {'input': \"1' OR '1'='1\", 'expected': true},\n        {'input': \"SELECT * FROM users\", 'expected': true},\n      ];\n\n      for (final testCase in testCases) {\n        final result = InputValidator.containsSqlInjection(testCase['input'] as String);\n        expect(result, testCase['expected'], reason: 'Failed for input: ${testCase['input']}');\n      }\n    });\n  });\n}\n</code></pre> <p>API security requires multiple layers of protection. Implement authentication, validate all inputs, use HTTPS with certificate pinning, and monitor for suspicious activity.</p>"},{"location":"security/app-security/","title":"Application Security","text":"<p>Comprehensive guide to implementing security measures in Flutter applications to protect against common vulnerabilities and threats.</p>"},{"location":"security/app-security/#overview","title":"Overview","text":"<p>Application security encompasses protecting the app from various threats including reverse engineering, tampering, data theft, and malicious attacks. This guide covers security best practices for Flutter apps.</p>"},{"location":"security/app-security/#code-obfuscation-protection","title":"Code Obfuscation &amp; Protection","text":""},{"location":"security/app-security/#1-code-obfuscation","title":"1. Code Obfuscation","text":"<pre><code># Build with obfuscation enabled\nflutter build apk --obfuscate --split-debug-info=build/debug-info\nflutter build ios --obfuscate --split-debug-info=build/debug-info\n\n# For release builds\nflutter build apk --release --obfuscate --split-debug-info=build/debug-info\nflutter build ios --release --obfuscate --split-debug-info=build/debug-info\n</code></pre>"},{"location":"security/app-security/#2-proguard-configuration-android","title":"2. ProGuard Configuration (Android)","text":"<pre><code># android/app/proguard-rules.pro\n\n# Keep Flutter classes\n-keep class io.flutter.** { *; }\n-keep class io.flutter.plugins.** { *; }\n\n# Keep app-specific classes\n-keep class com.yourapp.** { *; }\n\n# Obfuscate everything else\n-obfuscate\n-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*\n\n# Remove debug information\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n\n# Keep native methods\n-keepclasseswithmembernames class * {\n    native &lt;methods&gt;;\n}\n\n# Keep serializable classes\n-keepclassmembers class * implements java.io.Serializable {\n    static final long serialVersionUID;\n    private static final java.io.ObjectStreamField[] serialPersistentFields;\n    private void writeObject(java.io.ObjectOutputStream);\n    private void readObject(java.io.ObjectInputStream);\n    java.lang.Object writeReplace();\n    java.lang.Object readResolve();\n}\n</code></pre>"},{"location":"security/app-security/#rootjailbreak-detection","title":"Root/Jailbreak Detection","text":""},{"location":"security/app-security/#1-root-detection-service","title":"1. Root Detection Service","text":"<pre><code>// lib/services/security_service.dart\nimport 'package:flutter_jailbreak_detection/flutter_jailbreak_detection.dart';\nimport 'package:device_info_plus/device_info_plus.dart';\n\nclass SecurityService {\n  static Future&lt;SecurityStatus&gt; checkDeviceSecurity() async {\n    final isJailbroken = await FlutterJailbreakDetection.jailbroken;\n    final isDeveloperMode = await FlutterJailbreakDetation.developerMode;\n    final isRealDevice = await FlutterJailbreakDetection.isRealDevice;\n\n    return SecurityStatus(\n      isJailbroken: isJailbroken,\n      isDeveloperMode: isDeveloperMode,\n      isRealDevice: isRealDevice,\n      isSecure: !isJailbroken &amp;&amp; !isDeveloperMode &amp;&amp; isRealDevice,\n    );\n  }\n\n  static Future&lt;bool&gt; isRunningOnEmulator() async {\n    final deviceInfo = DeviceInfoPlugin();\n\n    if (Platform.isAndroid) {\n      final androidInfo = await deviceInfo.androidInfo;\n      return androidInfo.isPhysicalDevice == false;\n    } else if (Platform.isIOS) {\n      final iosInfo = await deviceInfo.iosInfo;\n      return iosInfo.isPhysicalDevice == false;\n    }\n\n    return false;\n  }\n\n  static Future&lt;void&gt; handleInsecureDevice(BuildContext context) async {\n    await showDialog(\n      context: context,\n      barrierDismissible: false,\n      builder: (context) =&gt; AlertDialog(\n        title: const Text('Security Warning'),\n        content: const Text(\n          'This app cannot run on rooted/jailbroken devices or emulators '\n          'for security reasons.',\n        ),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; SystemNavigator.pop(),\n            child: const Text('Exit'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass SecurityStatus {\n  final bool isJailbroken;\n  final bool isDeveloperMode;\n  final bool isRealDevice;\n  final bool isSecure;\n\n  const SecurityStatus({\n    required this.isJailbroken,\n    required this.isDeveloperMode,\n    required this.isRealDevice,\n    required this.isSecure,\n  });\n}\n</code></pre>"},{"location":"security/app-security/#2-security-guard-widget","title":"2. Security Guard Widget","text":"<pre><code>// lib/widgets/security_guard.dart\nclass SecurityGuard extends StatefulWidget {\n  final Widget child;\n  final bool enforceSecurityChecks;\n\n  const SecurityGuard({\n    Key? key,\n    required this.child,\n    this.enforceSecurityChecks = true,\n  }) : super(key: key);\n\n  @override\n  _SecurityGuardState createState() =&gt; _SecurityGuardState();\n}\n\nclass _SecurityGuardState extends State&lt;SecurityGuard&gt; {\n  bool _isSecure = false;\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _checkSecurity();\n  }\n\n  Future&lt;void&gt; _checkSecurity() async {\n    if (!widget.enforceSecurityChecks) {\n      setState(() {\n        _isSecure = true;\n        _isLoading = false;\n      });\n      return;\n    }\n\n    try {\n      final securityStatus = await SecurityService.checkDeviceSecurity();\n\n      setState(() {\n        _isSecure = securityStatus.isSecure;\n        _isLoading = false;\n      });\n\n      if (!_isSecure) {\n        await SecurityService.handleInsecureDevice(context);\n      }\n    } catch (e) {\n      // If security check fails, assume secure in production\n      setState(() {\n        _isSecure = !kDebugMode;\n        _isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_isLoading) {\n      return const Scaffold(\n        body: Center(\n          child: CircularProgressIndicator(),\n        ),\n      );\n    }\n\n    if (!_isSecure) {\n      return Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              const Icon(\n                Icons.security,\n                size: 64,\n                color: Colors.red,\n              ),\n              const SizedBox(height: 16),\n              const Text(\n                'Security Check Failed',\n                style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n              ),\n              const SizedBox(height: 8),\n              const Text(\n                'This app cannot run on this device for security reasons.',\n                textAlign: TextAlign.center,\n              ),\n              const SizedBox(height: 24),\n              ElevatedButton(\n                onPressed: () =&gt; SystemNavigator.pop(),\n                child: const Text('Exit'),\n              ),\n            ],\n          ),\n        ),\n      );\n    }\n\n    return widget.child;\n  }\n}\n</code></pre>"},{"location":"security/app-security/#biometric-authentication","title":"Biometric Authentication","text":""},{"location":"security/app-security/#1-biometric-service","title":"1. Biometric Service","text":"<pre><code>// lib/services/biometric_service.dart\nimport 'package:local_auth/local_auth.dart';\n\nclass BiometricService {\n  static final LocalAuthentication _localAuth = LocalAuthentication();\n\n  // Check if biometrics are available\n  static Future&lt;bool&gt; isBiometricAvailable() async {\n    try {\n      final isAvailable = await _localAuth.canCheckBiometrics;\n      final isDeviceSupported = await _localAuth.isDeviceSupported();\n      return isAvailable &amp;&amp; isDeviceSupported;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Get available biometric types\n  static Future&lt;List&lt;BiometricType&gt;&gt; getAvailableBiometrics() async {\n    try {\n      return await _localAuth.getAvailableBiometrics();\n    } catch (e) {\n      return [];\n    }\n  }\n\n  // Authenticate with biometrics\n  static Future&lt;bool&gt; authenticateWithBiometrics({\n    String localizedReason = 'Please authenticate to continue',\n    bool useErrorDialogs = true,\n    bool stickyAuth = false,\n  }) async {\n    try {\n      final isAuthenticated = await _localAuth.authenticate(\n        localizedReason: localizedReason,\n        options: AuthenticationOptions(\n          useErrorDialogs: useErrorDialogs,\n          stickyAuth: stickyAuth,\n          biometricOnly: true,\n        ),\n      );\n\n      return isAuthenticated;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Check if user has enrolled biometrics\n  static Future&lt;bool&gt; hasEnrolledBiometrics() async {\n    final availableBiometrics = await getAvailableBiometrics();\n    return availableBiometrics.isNotEmpty;\n  }\n\n  // Get biometric type string\n  static String getBiometricTypeString(List&lt;BiometricType&gt; types) {\n    if (types.contains(BiometricType.face)) {\n      return 'Face ID';\n    } else if (types.contains(BiometricType.fingerprint)) {\n      return 'Fingerprint';\n    } else if (types.contains(BiometricType.iris)) {\n      return 'Iris';\n    } else {\n      return 'Biometric';\n    }\n  }\n}\n</code></pre>"},{"location":"security/app-security/#2-biometric-authentication-widget","title":"2. Biometric Authentication Widget","text":"<pre><code>// lib/widgets/biometric_auth_widget.dart\nclass BiometricAuthWidget extends StatefulWidget {\n  final VoidCallback onSuccess;\n  final VoidCallback? onFailure;\n  final String title;\n  final String subtitle;\n\n  const BiometricAuthWidget({\n    Key? key,\n    required this.onSuccess,\n    this.onFailure,\n    this.title = 'Biometric Authentication',\n    this.subtitle = 'Use your biometric to authenticate',\n  }) : super(key: key);\n\n  @override\n  _BiometricAuthWidgetState createState() =&gt; _BiometricAuthWidgetState();\n}\n\nclass _BiometricAuthWidgetState extends State&lt;BiometricAuthWidget&gt; {\n  bool _isAuthenticating = false;\n  String _biometricType = 'Biometric';\n\n  @override\n  void initState() {\n    super.initState();\n    _initializeBiometric();\n  }\n\n  Future&lt;void&gt; _initializeBiometric() async {\n    final availableBiometrics = await BiometricService.getAvailableBiometrics();\n    setState(() {\n      _biometricType = BiometricService.getBiometricTypeString(availableBiometrics);\n    });\n  }\n\n  Future&lt;void&gt; _authenticate() async {\n    setState(() {\n      _isAuthenticating = true;\n    });\n\n    try {\n      final isAuthenticated = await BiometricService.authenticateWithBiometrics(\n        localizedReason: 'Please verify your identity to continue',\n      );\n\n      if (isAuthenticated) {\n        widget.onSuccess();\n      } else {\n        widget.onFailure?.call();\n      }\n    } catch (e) {\n      widget.onFailure?.call();\n    } finally {\n      if (mounted) {\n        setState(() {\n          _isAuthenticating = false;\n        });\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(24),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Icon(\n              _getBiometricIcon(),\n              size: 64,\n              color: Theme.of(context).primaryColor,\n            ),\n            const SizedBox(height: 16),\n            Text(\n              widget.title,\n              style: Theme.of(context).textTheme.headlineSmall,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 8),\n            Text(\n              widget.subtitle,\n              style: Theme.of(context).textTheme.bodyMedium,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 24),\n            SizedBox(\n              width: double.infinity,\n              child: ElevatedButton(\n                onPressed: _isAuthenticating ? null : _authenticate,\n                child: _isAuthenticating\n                    ? const CircularProgressIndicator()\n                    : Text('Use $_biometricType'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  IconData _getBiometricIcon() {\n    switch (_biometricType) {\n      case 'Face ID':\n        return Icons.face;\n      case 'Fingerprint':\n        return Icons.fingerprint;\n      default:\n        return Icons.security;\n    }\n  }\n}\n</code></pre>"},{"location":"security/app-security/#app-integrity-tampering-detection","title":"App Integrity &amp; Tampering Detection","text":""},{"location":"security/app-security/#1-integrity-checker","title":"1. Integrity Checker","text":"<pre><code>// lib/services/integrity_service.dart\nimport 'package:crypto/crypto.dart';\n\nclass IntegrityService {\n  // Check app signature (Android)\n  static Future&lt;bool&gt; verifyAppSignature() async {\n    if (!Platform.isAndroid) return true;\n\n    try {\n      // This would require platform-specific implementation\n      // to check the app's signing certificate\n      return await _checkAndroidSignature();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static Future&lt;bool&gt; _checkAndroidSignature() async {\n    // Platform-specific implementation needed\n    // This is a placeholder for the actual signature verification\n    return true;\n  }\n\n  // Check if app is running in debug mode\n  static bool isDebugMode() {\n    return kDebugMode;\n  }\n\n  // Check for suspicious modifications\n  static Future&lt;bool&gt; checkAppIntegrity() async {\n    // Check if running on emulator\n    final isEmulator = await SecurityService.isRunningOnEmulator();\n    if (isEmulator &amp;&amp; !kDebugMode) return false;\n\n    // Check app signature\n    final validSignature = await verifyAppSignature();\n    if (!validSignature) return false;\n\n    // Check for debugging tools\n    final hasDebuggingTools = await _checkForDebuggingTools();\n    if (hasDebuggingTools &amp;&amp; !kDebugMode) return false;\n\n    return true;\n  }\n\n  static Future&lt;bool&gt; _checkForDebuggingTools() async {\n    // Check for common debugging tools and frameworks\n    // This is a simplified check\n    try {\n      // Check for Frida, Xposed, etc.\n      // Platform-specific implementation needed\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Generate app checksum\n  static Future&lt;String&gt; generateAppChecksum() async {\n    try {\n      // Get app binary data and generate checksum\n      // This requires platform-specific implementation\n      final appData = await _getAppBinaryData();\n      final digest = sha256.convert(appData);\n      return digest.toString();\n    } catch (e) {\n      return '';\n    }\n  }\n\n  static Future&lt;List&lt;int&gt;&gt; _getAppBinaryData() async {\n    // Platform-specific implementation to get app binary\n    // This is a placeholder\n    return [];\n  }\n}\n</code></pre>"},{"location":"security/app-security/#2-anti-tampering-measures","title":"2. Anti-Tampering Measures","text":"<pre><code>// lib/services/anti_tampering_service.dart\nclass AntiTamperingService {\n  static const String _expectedChecksum = 'your_app_checksum_here';\n\n  // Verify app hasn't been modified\n  static Future&lt;bool&gt; verifyAppIntegrity() async {\n    final currentChecksum = await IntegrityService.generateAppChecksum();\n    return currentChecksum == _expectedChecksum;\n  }\n\n  // Check for hooking frameworks\n  static Future&lt;bool&gt; detectHooking() async {\n    try {\n      // Check for common hooking frameworks\n      final hasXposed = await _checkForXposed();\n      final hasFrida = await _checkForFrida();\n      final hasSubstrate = await _checkForSubstrate();\n\n      return hasXposed || hasFrida || hasSubstrate;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static Future&lt;bool&gt; _checkForXposed() async {\n    // Check for Xposed framework\n    try {\n      // Platform-specific implementation\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static Future&lt;bool&gt; _checkForFrida() async {\n    // Check for Frida framework\n    try {\n      // Look for Frida-related files and processes\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static Future&lt;bool&gt; _checkForSubstrate() async {\n    // Check for Substrate framework (iOS)\n    try {\n      // Platform-specific implementation\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Runtime application self-protection\n  static void enableRASP() {\n    // Implement runtime protection measures\n    _enableAntiDebugging();\n    _enableAntiHooking();\n    _enableIntegrityChecks();\n  }\n\n  static void _enableAntiDebugging() {\n    // Implement anti-debugging measures\n    if (kDebugMode) return;\n\n    // Check for debugger attachment\n    Timer.periodic(const Duration(seconds: 5), (timer) {\n      if (_isDebuggerAttached()) {\n        SystemNavigator.pop();\n      }\n    });\n  }\n\n  static bool _isDebuggerAttached() {\n    // Platform-specific debugger detection\n    return false;\n  }\n\n  static void _enableAntiHooking() {\n    // Implement anti-hooking measures\n    Timer.periodic(const Duration(seconds: 10), (timer) async {\n      if (await detectHooking()) {\n        SystemNavigator.pop();\n      }\n    });\n  }\n\n  static void _enableIntegrityChecks() {\n    // Periodic integrity checks\n    Timer.periodic(const Duration(minutes: 5), (timer) async {\n      if (!await verifyAppIntegrity()) {\n        SystemNavigator.pop();\n      }\n    });\n  }\n}\n</code></pre>"},{"location":"security/app-security/#secure-communication","title":"Secure Communication","text":""},{"location":"security/app-security/#1-certificate-pinning","title":"1. Certificate Pinning","text":"<pre><code>// lib/services/certificate_pinning_service.dart\nimport 'package:dio_certificate_pinning/dio_certificate_pinning.dart';\n\nclass CertificatePinningService {\n  static Dio createPinnedClient() {\n    final dio = Dio();\n\n    // Add certificate pinning interceptor\n    dio.interceptors.add(\n      CertificatePinningInterceptor(\n        allowedSHAFingerprints: [\n          // Add your server's certificate fingerprints\n          'SHA256:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',\n          'SHA256:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=',\n        ],\n      ),\n    );\n\n    return dio;\n  }\n\n  // Verify certificate manually\n  static bool verifyCertificate(X509Certificate cert) {\n    final fingerprint = _getCertificateFingerprint(cert);\n    final allowedFingerprints = [\n      'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',\n      'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=',\n    ];\n\n    return allowedFingerprints.contains(fingerprint);\n  }\n\n  static String _getCertificateFingerprint(X509Certificate cert) {\n    final bytes = cert.der;\n    final digest = sha256.convert(bytes);\n    return base64.encode(digest.bytes);\n  }\n}\n</code></pre>"},{"location":"security/app-security/#security-testing","title":"Security Testing","text":""},{"location":"security/app-security/#1-security-test-suite","title":"1. Security Test Suite","text":"<pre><code>// test/security/security_test.dart\nvoid main() {\n  group('Security Tests', () {\n    test('should detect insecure device', () async {\n      // Mock jailbroken device\n      when(FlutterJailbreakDetection.jailbroken).thenAnswer((_) async =&gt; true);\n\n      final securityStatus = await SecurityService.checkDeviceSecurity();\n      expect(securityStatus.isSecure, isFalse);\n    });\n\n    test('should verify app integrity', () async {\n      final isIntact = await IntegrityService.checkAppIntegrity();\n      expect(isIntact, isTrue);\n    });\n\n    test('should detect debugging tools', () async {\n      final hasDebuggingTools = await AntiTamperingService.detectHooking();\n      expect(hasDebuggingTools, isFalse);\n    });\n\n    test('should validate certificate pinning', () {\n      final mockCert = MockX509Certificate();\n      when(mockCert.der).thenReturn([1, 2, 3, 4, 5]);\n\n      final isValid = CertificatePinningService.verifyCertificate(mockCert);\n      expect(isValid, isA&lt;bool&gt;());\n    });\n  });\n}\n</code></pre> <p>Application security requires a multi-layered approach. Implement multiple security measures, regularly update them, and always assume that determined attackers will find ways to bypass individual protections.</p>"},{"location":"security/authentication/","title":"Authentication Implementation","text":"<p>Comprehensive guide to implementing secure authentication in Flutter applications using Supabase and other providers.</p>"},{"location":"security/authentication/#overview","title":"Overview","text":"<p>Authentication is critical for user security and app functionality. This guide covers multiple authentication methods, security best practices, and implementation patterns.</p>"},{"location":"security/authentication/#supabase-authentication","title":"Supabase Authentication","text":""},{"location":"security/authentication/#1-setup-and-configuration","title":"1. Setup and Configuration","text":"<pre><code># pubspec.yaml\ndependencies:\n  supabase_flutter: ^2.0.0\n  crypto: ^3.0.3\n</code></pre> <pre><code>// lib/services/auth_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass AuthService {\n  static final SupabaseClient _client = Supabase.instance.client;\n\n  // Get current user\n  static User? get currentUser =&gt; _client.auth.currentUser;\n\n  // Check if user is authenticated\n  static bool get isAuthenticated =&gt; currentUser != null;\n\n  // Auth state stream\n  static Stream&lt;AuthState&gt; get authStateChanges =&gt; _client.auth.onAuthStateChange;\n}\n</code></pre>"},{"location":"security/authentication/#2-emailpassword-authentication","title":"2. Email/Password Authentication","text":"<pre><code>class EmailAuthService extends AuthService {\n  // Sign up with email and password\n  static Future&lt;AuthResponse&gt; signUp({\n    required String email,\n    required String password,\n    Map&lt;String, dynamic&gt;? metadata,\n  }) async {\n    try {\n      final response = await _client.auth.signUp(\n        email: email,\n        password: password,\n        data: metadata,\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Sign up failed: ${e.toString()}');\n    }\n  }\n\n  // Sign in with email and password\n  static Future&lt;AuthResponse&gt; signIn({\n    required String email,\n    required String password,\n  }) async {\n    try {\n      final response = await _client.auth.signInWithPassword(\n        email: email,\n        password: password,\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Sign in failed: ${e.toString()}');\n    }\n  }\n\n  // Send password reset email\n  static Future&lt;void&gt; resetPassword(String email) async {\n    try {\n      await _client.auth.resetPasswordForEmail(email);\n    } catch (e) {\n      throw AuthException('Password reset failed: ${e.toString()}');\n    }\n  }\n\n  // Update password\n  static Future&lt;UserResponse&gt; updatePassword(String newPassword) async {\n    try {\n      final response = await _client.auth.updateUser(\n        UserAttributes(password: newPassword),\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Password update failed: ${e.toString()}');\n    }\n  }\n}\n</code></pre>"},{"location":"security/authentication/#3-social-authentication","title":"3. Social Authentication","text":"<pre><code>class SocialAuthService extends AuthService {\n  // Google Sign In\n  static Future&lt;AuthResponse&gt; signInWithGoogle() async {\n    try {\n      final response = await _client.auth.signInWithOAuth(\n        Provider.google,\n        redirectTo: 'your-app://auth-callback',\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Google sign in failed: ${e.toString()}');\n    }\n  }\n\n  // Apple Sign In\n  static Future&lt;AuthResponse&gt; signInWithApple() async {\n    try {\n      final response = await _client.auth.signInWithOAuth(\n        Provider.apple,\n        redirectTo: 'your-app://auth-callback',\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Apple sign in failed: ${e.toString()}');\n    }\n  }\n\n  // Facebook Sign In\n  static Future&lt;AuthResponse&gt; signInWithFacebook() async {\n    try {\n      final response = await _client.auth.signInWithOAuth(\n        Provider.facebook,\n        redirectTo: 'your-app://auth-callback',\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('Facebook sign in failed: ${e.toString()}');\n    }\n  }\n}\n</code></pre>"},{"location":"security/authentication/#4-phone-authentication","title":"4. Phone Authentication","text":"<pre><code>class PhoneAuthService extends AuthService {\n  // Send OTP to phone\n  static Future&lt;void&gt; sendOTP(String phone) async {\n    try {\n      await _client.auth.signInWithOtp(phone: phone);\n    } catch (e) {\n      throw AuthException('OTP send failed: ${e.toString()}');\n    }\n  }\n\n  // Verify OTP\n  static Future&lt;AuthResponse&gt; verifyOTP({\n    required String phone,\n    required String token,\n  }) async {\n    try {\n      final response = await _client.auth.verifyOTP(\n        phone: phone,\n        token: token,\n        type: OtpType.sms,\n      );\n      return response;\n    } catch (e) {\n      throw AuthException('OTP verification failed: ${e.toString()}');\n    }\n  }\n}\n</code></pre>"},{"location":"security/authentication/#authentication-state-management","title":"Authentication State Management","text":""},{"location":"security/authentication/#1-riverpod-implementation","title":"1. Riverpod Implementation","text":"<pre><code>// lib/providers/auth_provider.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nfinal authStateProvider = StreamProvider&lt;AuthState&gt;((ref) {\n  return AuthService.authStateChanges;\n});\n\nfinal currentUserProvider = Provider&lt;User?&gt;((ref) {\n  final authState = ref.watch(authStateProvider);\n  return authState.when(\n    data: (state) =&gt; state.session?.user,\n    loading: () =&gt; null,\n    error: (_, __) =&gt; null,\n  );\n});\n\nfinal isAuthenticatedProvider = Provider&lt;bool&gt;((ref) {\n  final user = ref.watch(currentUserProvider);\n  return user != null;\n});\n\nclass AuthNotifier extends StateNotifier&lt;AsyncValue&lt;User?&gt;&gt; {\n  AuthNotifier() : super(const AsyncValue.loading()) {\n    _init();\n  }\n\n  void _init() {\n    AuthService.authStateChanges.listen((authState) {\n      state = AsyncValue.data(authState.session?.user);\n    });\n  }\n\n  Future&lt;void&gt; signIn(String email, String password) async {\n    state = const AsyncValue.loading();\n    try {\n      await EmailAuthService.signIn(email: email, password: password);\n    } catch (e) {\n      state = AsyncValue.error(e, StackTrace.current);\n    }\n  }\n\n  Future&lt;void&gt; signUp(String email, String password) async {\n    state = const AsyncValue.loading();\n    try {\n      await EmailAuthService.signUp(email: email, password: password);\n    } catch (e) {\n      state = AsyncValue.error(e, StackTrace.current);\n    }\n  }\n\n  Future&lt;void&gt; signOut() async {\n    try {\n      await AuthService.signOut();\n    } catch (e) {\n      state = AsyncValue.error(e, StackTrace.current);\n    }\n  }\n}\n\nfinal authNotifierProvider = StateNotifierProvider&lt;AuthNotifier, AsyncValue&lt;User?&gt;&gt;((ref) {\n  return AuthNotifier();\n});\n</code></pre>"},{"location":"security/authentication/#2-bloc-implementation","title":"2. BLoC Implementation","text":"<pre><code>// lib/blocs/auth_bloc.dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nabstract class AuthEvent {}\n\nclass AuthSignInRequested extends AuthEvent {\n  final String email;\n  final String password;\n  AuthSignInRequested(this.email, this.password);\n}\n\nclass AuthSignUpRequested extends AuthEvent {\n  final String email;\n  final String password;\n  AuthSignUpRequested(this.email, this.password);\n}\n\nclass AuthSignOutRequested extends AuthEvent {}\n\nabstract class AuthState {}\n\nclass AuthInitial extends AuthState {}\nclass AuthLoading extends AuthState {}\nclass AuthAuthenticated extends AuthState {\n  final User user;\n  AuthAuthenticated(this.user);\n}\nclass AuthUnauthenticated extends AuthState {}\nclass AuthError extends AuthState {\n  final String message;\n  AuthError(this.message);\n}\n\nclass AuthBloc extends Bloc&lt;AuthEvent, AuthState&gt; {\n  AuthBloc() : super(AuthInitial()) {\n    on&lt;AuthSignInRequested&gt;(_onSignInRequested);\n    on&lt;AuthSignUpRequested&gt;(_onSignUpRequested);\n    on&lt;AuthSignOutRequested&gt;(_onSignOutRequested);\n\n    // Listen to auth state changes\n    AuthService.authStateChanges.listen((authState) {\n      if (authState.session?.user != null) {\n        add(AuthUserChanged(authState.session!.user));\n      } else {\n        add(AuthUserChanged(null));\n      }\n    });\n  }\n\n  Future&lt;void&gt; _onSignInRequested(AuthSignInRequested event, Emitter&lt;AuthState&gt; emit) async {\n    emit(AuthLoading());\n    try {\n      await EmailAuthService.signIn(email: event.email, password: event.password);\n    } catch (e) {\n      emit(AuthError(e.toString()));\n    }\n  }\n}\n</code></pre>"},{"location":"security/authentication/#ui-components","title":"UI Components","text":""},{"location":"security/authentication/#1-login-screen","title":"1. Login Screen","text":"<pre><code>// lib/screens/login_screen.dart\nclass LoginScreen extends ConsumerStatefulWidget {\n  @override\n  _LoginScreenState createState() =&gt; _LoginScreenState();\n}\n\nclass _LoginScreenState extends ConsumerState&lt;LoginScreen&gt; {\n  final _formKey = GlobalKey&lt;FormState&gt;();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  bool _isLoading = false;\n\n  @override\n  Widget build(BuildContext context) {\n    ref.listen(authNotifierProvider, (previous, next) {\n      next.when(\n        data: (user) {\n          if (user != null) {\n            Navigator.of(context).pushReplacementNamed('/home');\n          }\n        },\n        loading: () =&gt; setState(() =&gt; _isLoading = true),\n        error: (error, _) {\n          setState(() =&gt; _isLoading = false);\n          ScaffoldMessenger.of(context).showSnackBar(\n            SnackBar(content: Text(error.toString())),\n          );\n        },\n      );\n    });\n\n    return Scaffold(\n      body: SafeArea(\n        child: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(labelText: 'Email'),\n                  validator: (value) {\n                    if (value?.isEmpty ?? true) return 'Email is required';\n                    if (!value!.contains('@')) return 'Invalid email';\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n                TextFormField(\n                  controller: _passwordController,\n                  decoration: const InputDecoration(labelText: 'Password'),\n                  obscureText: true,\n                  validator: (value) {\n                    if (value?.isEmpty ?? true) return 'Password is required';\n                    if (value!.length &lt; 6) return 'Password must be at least 6 characters';\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 24),\n                ElevatedButton(\n                  onPressed: _isLoading ? null : _signIn,\n                  child: _isLoading \n                    ? const CircularProgressIndicator()\n                    : const Text('Sign In'),\n                ),\n                const SizedBox(height: 16),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n                  children: [\n                    ElevatedButton.icon(\n                      onPressed: _signInWithGoogle,\n                      icon: const Icon(Icons.login),\n                      label: const Text('Google'),\n                    ),\n                    ElevatedButton.icon(\n                      onPressed: _signInWithApple,\n                      icon: const Icon(Icons.apple),\n                      label: const Text('Apple'),\n                    ),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  void _signIn() {\n    if (_formKey.currentState?.validate() ?? false) {\n      ref.read(authNotifierProvider.notifier).signIn(\n        _emailController.text,\n        _passwordController.text,\n      );\n    }\n  }\n\n  void _signInWithGoogle() {\n    // Implement Google sign in\n  }\n\n  void _signInWithApple() {\n    // Implement Apple sign in\n  }\n}\n</code></pre>"},{"location":"security/authentication/#2-auth-guard","title":"2. Auth Guard","text":"<pre><code>// lib/widgets/auth_guard.dart\nclass AuthGuard extends ConsumerWidget {\n  final Widget child;\n  final Widget? fallback;\n\n  const AuthGuard({\n    Key? key,\n    required this.child,\n    this.fallback,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final isAuthenticated = ref.watch(isAuthenticatedProvider);\n\n    if (isAuthenticated) {\n      return child;\n    }\n\n    return fallback ?? const LoginScreen();\n  }\n}\n\n// Usage\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: AuthGuard(\n        child: HomeScreen(),\n        fallback: LoginScreen(),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"security/authentication/#security-best-practices","title":"Security Best Practices","text":""},{"location":"security/authentication/#1-token-management","title":"1. Token Management","text":"<pre><code>// lib/services/token_service.dart\nclass TokenService {\n  static const String _accessTokenKey = 'access_token';\n  static const String _refreshTokenKey = 'refresh_token';\n\n  // Store tokens securely\n  static Future&lt;void&gt; storeTokens({\n    required String accessToken,\n    required String refreshToken,\n  }) async {\n    await SecureStorage.write(_accessTokenKey, accessToken);\n    await SecureStorage.write(_refreshTokenKey, refreshToken);\n  }\n\n  // Get access token\n  static Future&lt;String?&gt; getAccessToken() async {\n    return await SecureStorage.read(_accessTokenKey);\n  }\n\n  // Refresh token if needed\n  static Future&lt;String?&gt; refreshAccessToken() async {\n    final refreshToken = await SecureStorage.read(_refreshTokenKey);\n    if (refreshToken == null) return null;\n\n    try {\n      final response = await _client.auth.refreshSession(refreshToken);\n      if (response.session != null) {\n        await storeTokens(\n          accessToken: response.session!.accessToken,\n          refreshToken: response.session!.refreshToken!,\n        );\n        return response.session!.accessToken;\n      }\n    } catch (e) {\n      // Refresh failed, user needs to re-authenticate\n      await clearTokens();\n    }\n    return null;\n  }\n\n  // Clear tokens on logout\n  static Future&lt;void&gt; clearTokens() async {\n    await SecureStorage.delete(_accessTokenKey);\n    await SecureStorage.delete(_refreshTokenKey);\n  }\n}\n</code></pre>"},{"location":"security/authentication/#2-secure-storage","title":"2. Secure Storage","text":"<pre><code>// lib/services/secure_storage.dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n\nclass SecureStorage {\n  static const _storage = FlutterSecureStorage(\n    aOptions: AndroidOptions(\n      encryptedSharedPreferences: true,\n    ),\n    iOptions: IOSOptions(\n      accessibility: IOSAccessibility.first_unlock_this_device,\n    ),\n  );\n\n  static Future&lt;void&gt; write(String key, String value) async {\n    await _storage.write(key: key, value: value);\n  }\n\n  static Future&lt;String?&gt; read(String key) async {\n    return await _storage.read(key: key);\n  }\n\n  static Future&lt;void&gt; delete(String key) async {\n    await _storage.delete(key: key);\n  }\n\n  static Future&lt;void&gt; deleteAll() async {\n    await _storage.deleteAll();\n  }\n}\n</code></pre>"},{"location":"security/authentication/#3-biometric-authentication","title":"3. Biometric Authentication","text":"<pre><code>// lib/services/biometric_service.dart\nimport 'package:local_auth/local_auth.dart';\n\nclass BiometricService {\n  static final LocalAuthentication _localAuth = LocalAuthentication();\n\n  static Future&lt;bool&gt; isAvailable() async {\n    try {\n      return await _localAuth.canCheckBiometrics;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  static Future&lt;List&lt;BiometricType&gt;&gt; getAvailableBiometrics() async {\n    try {\n      return await _localAuth.getAvailableBiometrics();\n    } catch (e) {\n      return [];\n    }\n  }\n\n  static Future&lt;bool&gt; authenticate({\n    required String reason,\n    bool biometricOnly = false,\n  }) async {\n    try {\n      return await _localAuth.authenticate(\n        localizedFallbackTitle: 'Use PIN',\n        authMessages: const [\n          AndroidAuthMessages(\n            signInTitle: 'Biometric authentication required',\n            cancelButton: 'Cancel',\n          ),\n          IOSAuthMessages(\n            cancelButton: 'Cancel',\n          ),\n        ],\n        options: AuthenticationOptions(\n          biometricOnly: biometricOnly,\n          stickyAuth: true,\n        ),\n      );\n    } catch (e) {\n      return false;\n    }\n  }\n}\n</code></pre>"},{"location":"security/authentication/#session-management","title":"Session Management","text":""},{"location":"security/authentication/#1-session-persistence","title":"1. Session Persistence","text":"<pre><code>// lib/services/session_service.dart\nclass SessionService {\n  static const String _sessionKey = 'user_session';\n\n  static Future&lt;void&gt; saveSession(Session session) async {\n    final sessionData = {\n      'access_token': session.accessToken,\n      'refresh_token': session.refreshToken,\n      'expires_at': session.expiresAt,\n      'user': session.user.toJson(),\n    };\n\n    await SecureStorage.write(_sessionKey, jsonEncode(sessionData));\n  }\n\n  static Future&lt;Session?&gt; loadSession() async {\n    final sessionJson = await SecureStorage.read(_sessionKey);\n    if (sessionJson == null) return null;\n\n    try {\n      final sessionData = jsonDecode(sessionJson);\n      return Session.fromJson(sessionData);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  static Future&lt;void&gt; clearSession() async {\n    await SecureStorage.delete(_sessionKey);\n  }\n}\n</code></pre>"},{"location":"security/authentication/#2-auto-logout","title":"2. Auto-logout","text":"<pre><code>// lib/services/auto_logout_service.dart\nclass AutoLogoutService {\n  static Timer? _timer;\n  static const Duration _timeoutDuration = Duration(minutes: 30);\n\n  static void startTimer() {\n    _resetTimer();\n  }\n\n  static void _resetTimer() {\n    _timer?.cancel();\n    _timer = Timer(_timeoutDuration, () {\n      _logout();\n    });\n  }\n\n  static void resetTimer() {\n    if (_timer?.isActive ?? false) {\n      _resetTimer();\n    }\n  }\n\n  static void stopTimer() {\n    _timer?.cancel();\n    _timer = null;\n  }\n\n  static void _logout() {\n    // Perform logout\n    AuthService.signOut();\n  }\n}\n\n// Usage in app lifecycle\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =&gt; _MyAppState();\n}\n\nclass _MyAppState extends State&lt;MyApp&gt; with WidgetsBindingObserver {\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n    AutoLogoutService.startTimer();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    if (state == AppLifecycleState.resumed) {\n      AutoLogoutService.resetTimer();\n    } else if (state == AppLifecycleState.paused) {\n      AutoLogoutService.stopTimer();\n    }\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    AutoLogoutService.stopTimer();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"security/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"security/authentication/#1-unit-tests","title":"1. Unit Tests","text":"<pre><code>// test/auth_service_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\n\nclass MockSupabaseClient extends Mock implements SupabaseClient {}\n\nvoid main() {\n  group('AuthService Tests', () {\n    late MockSupabaseClient mockClient;\n\n    setUp(() {\n      mockClient = MockSupabaseClient();\n    });\n\n    test('should sign in user with valid credentials', () async {\n      // Arrange\n      when(mockClient.auth.signInWithPassword(\n        email: 'test@example.com',\n        password: 'password123',\n      )).thenAnswer((_) async =&gt; AuthResponse(\n        session: Session(\n          accessToken: 'token',\n          refreshToken: 'refresh',\n          expiresAt: DateTime.now().add(Duration(hours: 1)).millisecondsSinceEpoch,\n          user: User(id: '123', email: 'test@example.com'),\n        ),\n      ));\n\n      // Act\n      final result = await EmailAuthService.signIn(\n        email: 'test@example.com',\n        password: 'password123',\n      );\n\n      // Assert\n      expect(result.session?.user.email, 'test@example.com');\n    });\n  });\n}\n</code></pre>"},{"location":"security/authentication/#2-widget-tests","title":"2. Widget Tests","text":"<pre><code>// test/login_screen_test.dart\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('LoginScreen Tests', () {\n    testWidgets('should show validation error for invalid email', (tester) async {\n      await tester.pumpWidget(MaterialApp(home: LoginScreen()));\n\n      await tester.enterText(find.byType(TextFormField).first, 'invalid-email');\n      await tester.tap(find.text('Sign In'));\n      await tester.pump();\n\n      expect(find.text('Invalid email'), findsOneWidget);\n    });\n  });\n}\n</code></pre> <p>Authentication is the foundation of app security. Implement it carefully, test thoroughly, and always follow security best practices to protect your users' data.</p>"},{"location":"security/data-security/","title":"Data Security","text":"<p>Comprehensive guide to implementing data security measures in Flutter applications, covering encryption, secure storage, and data protection.</p>"},{"location":"security/data-security/#overview","title":"Overview","text":"<p>Data security is critical for protecting user information, credentials, and sensitive application data. This guide covers encryption, secure storage, data classification, and privacy protection.</p>"},{"location":"security/data-security/#secure-storage","title":"Secure Storage","text":""},{"location":"security/data-security/#1-flutter-secure-storage","title":"1. Flutter Secure Storage","text":"<pre><code>// lib/services/secure_storage_service.dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n\nclass SecureStorageService {\n  static const FlutterSecureStorage _storage = FlutterSecureStorage(\n    aOptions: AndroidOptions(\n      encryptedSharedPreferences: true,\n      sharedPreferencesName: 'secure_prefs',\n      preferencesKeyPrefix: 'app_',\n    ),\n    iOptions: IOSOptions(\n      groupId: 'group.com.yourapp.flutter',\n      accountName: 'YourApp',\n      accessibility: IOSAccessibility.first_unlock_this_device,\n    ),\n  );\n\n  // Store sensitive data\n  static Future&lt;void&gt; storeSecureData(String key, String value) async {\n    try {\n      await _storage.write(key: key, value: value);\n    } catch (e) {\n      throw SecureStorageException('Failed to store secure data: $e');\n    }\n  }\n\n  // Retrieve sensitive data\n  static Future&lt;String?&gt; getSecureData(String key) async {\n    try {\n      return await _storage.read(key: key);\n    } catch (e) {\n      throw SecureStorageException('Failed to retrieve secure data: $e');\n    }\n  }\n\n  // Store encrypted JSON\n  static Future&lt;void&gt; storeSecureJson(String key, Map&lt;String, dynamic&gt; data) async {\n    final jsonString = jsonEncode(data);\n    await storeSecureData(key, jsonString);\n  }\n\n  // Retrieve encrypted JSON\n  static Future&lt;Map&lt;String, dynamic&gt;?&gt; getSecureJson(String key) async {\n    final jsonString = await getSecureData(key);\n    if (jsonString == null) return null;\n\n    try {\n      return jsonDecode(jsonString) as Map&lt;String, dynamic&gt;;\n    } catch (e) {\n      throw SecureStorageException('Failed to parse JSON data: $e');\n    }\n  }\n\n  // Delete secure data\n  static Future&lt;void&gt; deleteSecureData(String key) async {\n    try {\n      await _storage.delete(key: key);\n    } catch (e) {\n      throw SecureStorageException('Failed to delete secure data: $e');\n    }\n  }\n\n  // Clear all secure data\n  static Future&lt;void&gt; clearAllSecureData() async {\n    try {\n      await _storage.deleteAll();\n    } catch (e) {\n      throw SecureStorageException('Failed to clear secure data: $e');\n    }\n  }\n\n  // Check if key exists\n  static Future&lt;bool&gt; containsKey(String key) async {\n    try {\n      return await _storage.containsKey(key: key);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Get all keys\n  static Future&lt;Map&lt;String, String&gt;&gt; getAllSecureData() async {\n    try {\n      return await _storage.readAll();\n    } catch (e) {\n      throw SecureStorageException('Failed to read all secure data: $e');\n    }\n  }\n}\n\nclass SecureStorageException implements Exception {\n  final String message;\n  SecureStorageException(this.message);\n\n  @override\n  String toString() =&gt; 'SecureStorageException: $message';\n}\n</code></pre>"},{"location":"security/data-security/#2-encrypted-database","title":"2. Encrypted Database","text":"<pre><code>// lib/services/encrypted_database_service.dart\nimport 'package:sqflite_sqlcipher/sqflite.dart';\n\nclass EncryptedDatabaseService {\n  static Database? _database;\n  static const String _databaseName = 'secure_app.db';\n  static const int _databaseVersion = 1;\n\n  // Initialize encrypted database\n  static Future&lt;Database&gt; get database async {\n    if (_database != null) return _database!;\n\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  static Future&lt;Database&gt; _initDatabase() async {\n    final databasesPath = await getDatabasesPath();\n    final path = join(databasesPath, _databaseName);\n\n    // Get encryption password from secure storage\n    final password = await _getDatabasePassword();\n\n    return await openDatabase(\n      path,\n      version: _databaseVersion,\n      password: password,\n      onCreate: _onCreate,\n      onUpgrade: _onUpgrade,\n    );\n  }\n\n  static Future&lt;String&gt; _getDatabasePassword() async {\n    const passwordKey = 'database_password';\n\n    // Try to get existing password\n    String? password = await SecureStorageService.getSecureData(passwordKey);\n\n    if (password == null) {\n      // Generate new password\n      password = _generateSecurePassword();\n      await SecureStorageService.storeSecureData(passwordKey, password);\n    }\n\n    return password;\n  }\n\n  static String _generateSecurePassword() {\n    final random = Random.secure();\n    final bytes = List&lt;int&gt;.generate(32, (i) =&gt; random.nextInt(256));\n    return base64.encode(bytes);\n  }\n\n  static Future&lt;void&gt; _onCreate(Database db, int version) async {\n    // Create tables with encryption\n    await db.execute('''\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        username TEXT NOT NULL,\n        email TEXT NOT NULL,\n        encrypted_data TEXT,\n        created_at INTEGER NOT NULL\n      )\n    ''');\n\n    await db.execute('''\n      CREATE TABLE secure_notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER NOT NULL,\n        title TEXT NOT NULL,\n        encrypted_content TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        FOREIGN KEY (user_id) REFERENCES users (id)\n      )\n    ''');\n  }\n\n  static Future&lt;void&gt; _onUpgrade(Database db, int oldVersion, int newVersion) async {\n    // Handle database upgrades\n    if (oldVersion &lt; 2) {\n      // Add new columns or tables\n    }\n  }\n\n  // Insert encrypted data\n  static Future&lt;int&gt; insertEncryptedData(String table, Map&lt;String, dynamic&gt; data) async {\n    final db = await database;\n\n    // Encrypt sensitive fields\n    final encryptedData = await _encryptSensitiveFields(data);\n\n    return await db.insert(table, encryptedData);\n  }\n\n  // Query encrypted data\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; queryEncryptedData(\n    String table, {\n    String? where,\n    List&lt;dynamic&gt;? whereArgs,\n  }) async {\n    final db = await database;\n\n    final results = await db.query(\n      table,\n      where: where,\n      whereArgs: whereArgs,\n    );\n\n    // Decrypt sensitive fields\n    final decryptedResults = &lt;Map&lt;String, dynamic&gt;&gt;[];\n    for (final result in results) {\n      final decryptedResult = await _decryptSensitiveFields(result);\n      decryptedResults.add(decryptedResult);\n    }\n\n    return decryptedResults;\n  }\n\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; _encryptSensitiveFields(Map&lt;String, dynamic&gt; data) async {\n    final encryptedData = Map&lt;String, dynamic&gt;.from(data);\n\n    // Encrypt specific fields\n    if (data.containsKey('encrypted_data')) {\n      final plaintext = data['encrypted_data'] as String;\n      encryptedData['encrypted_data'] = await EncryptionService.encrypt(plaintext);\n    }\n\n    if (data.containsKey('encrypted_content')) {\n      final plaintext = data['encrypted_content'] as String;\n      encryptedData['encrypted_content'] = await EncryptionService.encrypt(plaintext);\n    }\n\n    return encryptedData;\n  }\n\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; _decryptSensitiveFields(Map&lt;String, dynamic&gt; data) async {\n    final decryptedData = Map&lt;String, dynamic&gt;.from(data);\n\n    // Decrypt specific fields\n    if (data.containsKey('encrypted_data') &amp;&amp; data['encrypted_data'] != null) {\n      final ciphertext = data['encrypted_data'] as String;\n      decryptedData['encrypted_data'] = await EncryptionService.decrypt(ciphertext);\n    }\n\n    if (data.containsKey('encrypted_content') &amp;&amp; data['encrypted_content'] != null) {\n      final ciphertext = data['encrypted_content'] as String;\n      decryptedData['encrypted_content'] = await EncryptionService.decrypt(ciphertext);\n    }\n\n    return decryptedData;\n  }\n\n  // Close database\n  static Future&lt;void&gt; closeDatabase() async {\n    if (_database != null) {\n      await _database!.close();\n      _database = null;\n    }\n  }\n}\n</code></pre>"},{"location":"security/data-security/#encryption-services","title":"Encryption Services","text":""},{"location":"security/data-security/#1-aes-encryption-service","title":"1. AES Encryption Service","text":"<pre><code>// lib/services/encryption_service.dart\nimport 'package:encrypt/encrypt.dart';\n\nclass EncryptionService {\n  static late final Encrypter _encrypter;\n  static late final IV _iv;\n  static bool _initialized = false;\n\n  // Initialize encryption service\n  static Future&lt;void&gt; initialize() async {\n    if (_initialized) return;\n\n    final key = await _getOrCreateEncryptionKey();\n    _encrypter = Encrypter(AES(key));\n    _iv = IV.fromSecureRandom(16);\n    _initialized = true;\n  }\n\n  static Future&lt;Key&gt; _getOrCreateEncryptionKey() async {\n    const keyName = 'encryption_key';\n\n    // Try to get existing key\n    String? keyString = await SecureStorageService.getSecureData(keyName);\n\n    if (keyString == null) {\n      // Generate new key\n      final key = Key.fromSecureRandom(32);\n      keyString = key.base64;\n      await SecureStorageService.storeSecureData(keyName, keyString);\n      return key;\n    }\n\n    return Key.fromBase64(keyString);\n  }\n\n  // Encrypt string data\n  static Future&lt;String&gt; encrypt(String plaintext) async {\n    await initialize();\n\n    final encrypted = _encrypter.encrypt(plaintext, iv: _iv);\n    return encrypted.base64;\n  }\n\n  // Decrypt string data\n  static Future&lt;String&gt; decrypt(String ciphertext) async {\n    await initialize();\n\n    final encrypted = Encrypted.fromBase64(ciphertext);\n    return _encrypter.decrypt(encrypted, iv: _iv);\n  }\n\n  // Encrypt JSON data\n  static Future&lt;String&gt; encryptJson(Map&lt;String, dynamic&gt; data) async {\n    final jsonString = jsonEncode(data);\n    return await encrypt(jsonString);\n  }\n\n  // Decrypt JSON data\n  static Future&lt;Map&lt;String, dynamic&gt;&gt; decryptJson(String ciphertext) async {\n    final jsonString = await decrypt(ciphertext);\n    return jsonDecode(jsonString) as Map&lt;String, dynamic&gt;;\n  }\n\n  // Encrypt file\n  static Future&lt;void&gt; encryptFile(String inputPath, String outputPath) async {\n    await initialize();\n\n    final inputFile = File(inputPath);\n    final outputFile = File(outputPath);\n\n    final bytes = await inputFile.readAsBytes();\n    final encrypted = _encrypter.encryptBytes(bytes, iv: _iv);\n\n    await outputFile.writeAsBytes(encrypted.bytes);\n  }\n\n  // Decrypt file\n  static Future&lt;void&gt; decryptFile(String inputPath, String outputPath) async {\n    await initialize();\n\n    final inputFile = File(inputPath);\n    final outputFile = File(outputPath);\n\n    final encryptedBytes = await inputFile.readAsBytes();\n    final encrypted = Encrypted(encryptedBytes);\n    final decryptedBytes = _encrypter.decryptBytes(encrypted, iv: _iv);\n\n    await outputFile.writeAsBytes(decryptedBytes);\n  }\n\n  // Generate hash\n  static String generateHash(String input) {\n    final bytes = utf8.encode(input);\n    final digest = sha256.convert(bytes);\n    return digest.toString();\n  }\n\n  // Generate HMAC\n  static String generateHMAC(String input, String secret) {\n    final key = utf8.encode(secret);\n    final bytes = utf8.encode(input);\n    final hmac = Hmac(sha256, key);\n    final digest = hmac.convert(bytes);\n    return digest.toString();\n  }\n}\n</code></pre>"},{"location":"security/data-security/#2-key-management-service","title":"2. Key Management Service","text":"<pre><code>// lib/services/key_management_service.dart\nclass KeyManagementService {\n  static const String _masterKeyName = 'master_key';\n  static const String _keyVersionName = 'key_version';\n\n  // Generate master key\n  static Future&lt;void&gt; generateMasterKey() async {\n    final masterKey = Key.fromSecureRandom(32);\n    await SecureStorageService.storeSecureData(_masterKeyName, masterKey.base64);\n    await SecureStorageService.storeSecureData(_keyVersionName, '1');\n  }\n\n  // Get master key\n  static Future&lt;Key?&gt; getMasterKey() async {\n    final keyString = await SecureStorageService.getSecureData(_masterKeyName);\n    if (keyString == null) return null;\n\n    return Key.fromBase64(keyString);\n  }\n\n  // Rotate master key\n  static Future&lt;void&gt; rotateMasterKey() async {\n    final oldKey = await getMasterKey();\n    if (oldKey == null) {\n      await generateMasterKey();\n      return;\n    }\n\n    // Generate new key\n    final newKey = Key.fromSecureRandom(32);\n\n    // Get current version\n    final versionString = await SecureStorageService.getSecureData(_keyVersionName);\n    final currentVersion = int.tryParse(versionString ?? '1') ?? 1;\n    final newVersion = currentVersion + 1;\n\n    // Store new key and version\n    await SecureStorageService.storeSecureData(_masterKeyName, newKey.base64);\n    await SecureStorageService.storeSecureData(_keyVersionName, newVersion.toString());\n\n    // Re-encrypt existing data with new key\n    await _reEncryptExistingData(oldKey, newKey);\n  }\n\n  static Future&lt;void&gt; _reEncryptExistingData(Key oldKey, Key newKey) async {\n    // This would re-encrypt all existing encrypted data\n    // Implementation depends on your data structure\n\n    // Example: Re-encrypt secure storage data\n    final allData = await SecureStorageService.getAllSecureData();\n\n    for (final entry in allData.entries) {\n      if (entry.key.startsWith('encrypted_')) {\n        try {\n          // Decrypt with old key\n          final oldEncrypter = Encrypter(AES(oldKey));\n          final iv = IV.fromSecureRandom(16);\n          final encrypted = Encrypted.fromBase64(entry.value);\n          final plaintext = oldEncrypter.decrypt(encrypted, iv: iv);\n\n          // Encrypt with new key\n          final newEncrypter = Encrypter(AES(newKey));\n          final newEncrypted = newEncrypter.encrypt(plaintext, iv: iv);\n\n          // Store re-encrypted data\n          await SecureStorageService.storeSecureData(entry.key, newEncrypted.base64);\n        } catch (e) {\n          print('Failed to re-encrypt ${entry.key}: $e');\n        }\n      }\n    }\n  }\n\n  // Derive key from password\n  static Key deriveKeyFromPassword(String password, String salt) {\n    final saltBytes = utf8.encode(salt);\n    final passwordBytes = utf8.encode(password);\n\n    // Use PBKDF2 for key derivation\n    final pbkdf2 = PBKDF2();\n    final derivedBytes = pbkdf2.generateKey(passwordBytes, saltBytes, 10000, 32);\n\n    return Key(Uint8List.fromList(derivedBytes));\n  }\n\n  // Generate salt\n  static String generateSalt() {\n    final random = Random.secure();\n    final bytes = List&lt;int&gt;.generate(16, (i) =&gt; random.nextInt(256));\n    return base64.encode(bytes);\n  }\n}\n</code></pre>"},{"location":"security/data-security/#data-classification-protection","title":"Data Classification &amp; Protection","text":""},{"location":"security/data-security/#1-data-classification-service","title":"1. Data Classification Service","text":"<pre><code>// lib/services/data_classification_service.dart\nenum DataClassification {\n  public,\n  internal,\n  confidential,\n  restricted,\n}\n\nclass DataClassificationService {\n  static const Map&lt;DataClassification, DataProtectionLevel&gt; _protectionLevels = {\n    DataClassification.public: DataProtectionLevel.none,\n    DataClassification.internal: DataProtectionLevel.basic,\n    DataClassification.confidential: DataProtectionLevel.standard,\n    DataClassification.restricted: DataProtectionLevel.maximum,\n  };\n\n  // Classify data based on content\n  static DataClassification classifyData(String data) {\n    // Check for PII patterns\n    if (_containsPII(data)) {\n      return DataClassification.restricted;\n    }\n\n    // Check for financial information\n    if (_containsFinancialInfo(data)) {\n      return DataClassification.confidential;\n    }\n\n    // Check for internal identifiers\n    if (_containsInternalInfo(data)) {\n      return DataClassification.internal;\n    }\n\n    return DataClassification.public;\n  }\n\n  static bool _containsPII(String data) {\n    // Check for email addresses\n    final emailRegex = RegExp(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b');\n    if (emailRegex.hasMatch(data)) return true;\n\n    // Check for phone numbers\n    final phoneRegex = RegExp(r'\\b\\d{3}-\\d{3}-\\d{4}\\b|\\b\\(\\d{3}\\)\\s*\\d{3}-\\d{4}\\b');\n    if (phoneRegex.hasMatch(data)) return true;\n\n    // Check for SSN patterns\n    final ssnRegex = RegExp(r'\\b\\d{3}-\\d{2}-\\d{4}\\b');\n    if (ssnRegex.hasMatch(data)) return true;\n\n    return false;\n  }\n\n  static bool _containsFinancialInfo(String data) {\n    // Check for credit card numbers\n    final ccRegex = RegExp(r'\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b');\n    if (ccRegex.hasMatch(data)) return true;\n\n    // Check for bank account patterns\n    final bankRegex = RegExp(r'\\b\\d{8,17}\\b');\n    if (bankRegex.hasMatch(data)) return true;\n\n    return false;\n  }\n\n  static bool _containsInternalInfo(String data) {\n    // Check for internal IDs or codes\n    final internalRegex = RegExp(r'\\b(EMP|USR|SYS)\\d+\\b');\n    return internalRegex.hasMatch(data);\n  }\n\n  // Get protection level for classification\n  static DataProtectionLevel getProtectionLevel(DataClassification classification) {\n    return _protectionLevels[classification] ?? DataProtectionLevel.basic;\n  }\n\n  // Apply protection based on classification\n  static Future&lt;String&gt; protectData(String data, DataClassification classification) async {\n    final protectionLevel = getProtectionLevel(classification);\n\n    switch (protectionLevel) {\n      case DataProtectionLevel.none:\n        return data;\n\n      case DataProtectionLevel.basic:\n        return await EncryptionService.encrypt(data);\n\n      case DataProtectionLevel.standard:\n        final encrypted = await EncryptionService.encrypt(data);\n        return await _addIntegrityCheck(encrypted);\n\n      case DataProtectionLevel.maximum:\n        final encrypted = await EncryptionService.encrypt(data);\n        final withIntegrity = await _addIntegrityCheck(encrypted);\n        return await _addAccessControl(withIntegrity);\n    }\n  }\n\n  static Future&lt;String&gt; _addIntegrityCheck(String data) async {\n    final hash = EncryptionService.generateHash(data);\n    return '$data|$hash';\n  }\n\n  static Future&lt;String&gt; _addAccessControl(String data) async {\n    // Add access control metadata\n    final accessControl = {\n      'data': data,\n      'access_level': 'restricted',\n      'timestamp': DateTime.now().toIso8601String(),\n    };\n\n    return await EncryptionService.encryptJson(accessControl);\n  }\n}\n\nenum DataProtectionLevel {\n  none,\n  basic,\n  standard,\n  maximum,\n}\n</code></pre>"},{"location":"security/data-security/#2-data-masking-service","title":"2. Data Masking Service","text":"<pre><code>// lib/services/data_masking_service.dart\nclass DataMaskingService {\n  // Mask email addresses\n  static String maskEmail(String email) {\n    final parts = email.split('@');\n    if (parts.length != 2) return email;\n\n    final username = parts[0];\n    final domain = parts[1];\n\n    if (username.length &lt;= 2) {\n      return '${username[0]}***@$domain';\n    }\n\n    final maskedUsername = '${username.substring(0, 2)}${'*' * (username.length - 2)}';\n    return '$maskedUsername@$domain';\n  }\n\n  // Mask phone numbers\n  static String maskPhoneNumber(String phone) {\n    final digitsOnly = phone.replaceAll(RegExp(r'[^\\d]'), '');\n\n    if (digitsOnly.length == 10) {\n      return '(${digitsOnly.substring(0, 3)}) ***-${digitsOnly.substring(6)}';\n    } else if (digitsOnly.length == 11) {\n      return '${digitsOnly.substring(0, 1)} (${digitsOnly.substring(1, 4)}) ***-${digitsOnly.substring(7)}';\n    }\n\n    return phone;\n  }\n\n  // Mask credit card numbers\n  static String maskCreditCard(String cardNumber) {\n    final digitsOnly = cardNumber.replaceAll(RegExp(r'[^\\d]'), '');\n\n    if (digitsOnly.length &gt;= 13) {\n      final lastFour = digitsOnly.substring(digitsOnly.length - 4);\n      return '**** **** **** $lastFour';\n    }\n\n    return cardNumber;\n  }\n\n  // Mask SSN\n  static String maskSSN(String ssn) {\n    final digitsOnly = ssn.replaceAll(RegExp(r'[^\\d]'), '');\n\n    if (digitsOnly.length == 9) {\n      return '***-**-${digitsOnly.substring(5)}';\n    }\n\n    return ssn;\n  }\n\n  // Generic data masking\n  static String maskString(String input, {int visibleChars = 2}) {\n    if (input.length &lt;= visibleChars) {\n      return '*' * input.length;\n    }\n\n    final visible = input.substring(0, visibleChars);\n    final masked = '*' * (input.length - visibleChars);\n    return '$visible$masked';\n  }\n\n  // Mask based on data classification\n  static String maskByClassification(String data, DataClassification classification) {\n    switch (classification) {\n      case DataClassification.public:\n        return data;\n\n      case DataClassification.internal:\n        return maskString(data, visibleChars: 4);\n\n      case DataClassification.confidential:\n        return maskString(data, visibleChars: 2);\n\n      case DataClassification.restricted:\n        return '*' * data.length;\n    }\n  }\n}\n</code></pre>"},{"location":"security/data-security/#privacy-protection","title":"Privacy Protection","text":""},{"location":"security/data-security/#1-privacy-manager","title":"1. Privacy Manager","text":"<pre><code>// lib/services/privacy_manager.dart\nclass PrivacyManager {\n  static const String _privacySettingsKey = 'privacy_settings';\n\n  // Get privacy settings\n  static Future&lt;PrivacySettings&gt; getPrivacySettings() async {\n    final settingsJson = await SecureStorageService.getSecureJson(_privacySettingsKey);\n\n    if (settingsJson == null) {\n      return PrivacySettings.defaultSettings();\n    }\n\n    return PrivacySettings.fromJson(settingsJson);\n  }\n\n  // Update privacy settings\n  static Future&lt;void&gt; updatePrivacySettings(PrivacySettings settings) async {\n    await SecureStorageService.storeSecureJson(_privacySettingsKey, settings.toJson());\n  }\n\n  // Check if data collection is allowed\n  static Future&lt;bool&gt; isDataCollectionAllowed(DataType dataType) async {\n    final settings = await getPrivacySettings();\n\n    switch (dataType) {\n      case DataType.analytics:\n        return settings.allowAnalytics;\n      case DataType.crashReports:\n        return settings.allowCrashReports;\n      case DataType.location:\n        return settings.allowLocationTracking;\n      case DataType.personalInfo:\n        return settings.allowPersonalInfoCollection;\n    }\n  }\n\n  // Anonymize user data\n  static Map&lt;String, dynamic&gt; anonymizeUserData(Map&lt;String, dynamic&gt; userData) {\n    final anonymized = Map&lt;String, dynamic&gt;.from(userData);\n\n    // Remove or hash PII\n    if (anonymized.containsKey('email')) {\n      anonymized['email'] = EncryptionService.generateHash(anonymized['email']);\n    }\n\n    if (anonymized.containsKey('phone')) {\n      anonymized.remove('phone');\n    }\n\n    if (anonymized.containsKey('name')) {\n      anonymized.remove('name');\n    }\n\n    // Add anonymization timestamp\n    anonymized['anonymized_at'] = DateTime.now().toIso8601String();\n\n    return anonymized;\n  }\n\n  // Data retention management\n  static Future&lt;void&gt; cleanupExpiredData() async {\n    final settings = await getPrivacySettings();\n    final cutoffDate = DateTime.now().subtract(Duration(days: settings.dataRetentionDays));\n\n    // Clean up local database\n    await _cleanupDatabaseData(cutoffDate);\n\n    // Clean up cached files\n    await _cleanupCachedFiles(cutoffDate);\n\n    // Clean up logs\n    await _cleanupLogs(cutoffDate);\n  }\n\n  static Future&lt;void&gt; _cleanupDatabaseData(DateTime cutoffDate) async {\n    final db = await EncryptedDatabaseService.database;\n\n    await db.delete(\n      'user_activities',\n      where: 'created_at &lt; ?',\n      whereArgs: [cutoffDate.millisecondsSinceEpoch],\n    );\n  }\n\n  static Future&lt;void&gt; _cleanupCachedFiles(DateTime cutoffDate) async {\n    final cacheDir = await getTemporaryDirectory();\n    final files = cacheDir.listSync();\n\n    for (final file in files) {\n      if (file is File) {\n        final stat = await file.stat();\n        if (stat.modified.isBefore(cutoffDate)) {\n          await file.delete();\n        }\n      }\n    }\n  }\n\n  static Future&lt;void&gt; _cleanupLogs(DateTime cutoffDate) async {\n    // Clean up application logs older than cutoff date\n    // Implementation depends on your logging system\n  }\n}\n\nclass PrivacySettings {\n  final bool allowAnalytics;\n  final bool allowCrashReports;\n  final bool allowLocationTracking;\n  final bool allowPersonalInfoCollection;\n  final int dataRetentionDays;\n\n  const PrivacySettings({\n    required this.allowAnalytics,\n    required this.allowCrashReports,\n    required this.allowLocationTracking,\n    required this.allowPersonalInfoCollection,\n    required this.dataRetentionDays,\n  });\n\n  factory PrivacySettings.defaultSettings() {\n    return const PrivacySettings(\n      allowAnalytics: false,\n      allowCrashReports: true,\n      allowLocationTracking: false,\n      allowPersonalInfoCollection: false,\n      dataRetentionDays: 30,\n    );\n  }\n\n  factory PrivacySettings.fromJson(Map&lt;String, dynamic&gt; json) {\n    return PrivacySettings(\n      allowAnalytics: json['allowAnalytics'] ?? false,\n      allowCrashReports: json['allowCrashReports'] ?? true,\n      allowLocationTracking: json['allowLocationTracking'] ?? false,\n      allowPersonalInfoCollection: json['allowPersonalInfoCollection'] ?? false,\n      dataRetentionDays: json['dataRetentionDays'] ?? 30,\n    );\n  }\n\n  Map&lt;String, dynamic&gt; toJson() {\n    return {\n      'allowAnalytics': allowAnalytics,\n      'allowCrashReports': allowCrashReports,\n      'allowLocationTracking': allowLocationTracking,\n      'allowPersonalInfoCollection': allowPersonalInfoCollection,\n      'dataRetentionDays': dataRetentionDays,\n    };\n  }\n}\n\nenum DataType {\n  analytics,\n  crashReports,\n  location,\n  personalInfo,\n}\n</code></pre>"},{"location":"security/data-security/#security-testing","title":"Security Testing","text":""},{"location":"security/data-security/#1-data-security-tests","title":"1. Data Security Tests","text":"<pre><code>// test/security/data_security_test.dart\nvoid main() {\n  group('Data Security Tests', () {\n    test('should encrypt and decrypt data correctly', () async {\n      const plaintext = 'sensitive data';\n\n      final encrypted = await EncryptionService.encrypt(plaintext);\n      expect(encrypted, isNot(equals(plaintext)));\n\n      final decrypted = await EncryptionService.decrypt(encrypted);\n      expect(decrypted, equals(plaintext));\n    });\n\n    test('should classify data correctly', () {\n      const email = 'user@example.com';\n      const publicData = 'public information';\n\n      final emailClassification = DataClassificationService.classifyData(email);\n      expect(emailClassification, equals(DataClassification.restricted));\n\n      final publicClassification = DataClassificationService.classifyData(publicData);\n      expect(publicClassification, equals(DataClassification.public));\n    });\n\n    test('should mask sensitive data', () {\n      const email = 'john.doe@example.com';\n      const phone = '(555) 123-4567';\n\n      final maskedEmail = DataMaskingService.maskEmail(email);\n      expect(maskedEmail, equals('jo*******@example.com'));\n\n      final maskedPhone = DataMaskingService.maskPhoneNumber(phone);\n      expect(maskedPhone, equals('(555) ***-4567'));\n    });\n  });\n}\n</code></pre> <p>Data security requires a comprehensive approach including encryption, secure storage, data classification, and privacy protection. Regularly audit your data handling practices and stay updated with security best practices.</p>"},{"location":"setup/environment-setup/","title":"Flutter Environment Setup","text":"<p>Complete guide to setting up your Flutter development environment for building production-grade applications.</p>"},{"location":"setup/environment-setup/#prerequisites","title":"Prerequisites","text":""},{"location":"setup/environment-setup/#system-requirements","title":"System Requirements","text":"<p>macOS: - macOS 10.14 (Mojave) or later - Xcode 12.0 or later - CocoaPods 1.10.0 or later</p> <p>Windows: - Windows 10 64-bit or later - Visual Studio 2019 or later (for Windows development)</p> <p>Linux: - 64-bit distribution - Required libraries for development</p>"},{"location":"setup/environment-setup/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>RAM: 8GB minimum, 16GB recommended</li> <li>Storage: 10GB free space minimum</li> <li>Processor: Intel i5 or equivalent</li> </ul>"},{"location":"setup/environment-setup/#flutter-sdk-installation","title":"Flutter SDK Installation","text":""},{"location":"setup/environment-setup/#option-1-using-package-managers-recommended","title":"Option 1: Using Package Managers (Recommended)","text":"<p>macOS (Homebrew): <pre><code># Install Homebrew if not already installed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install Flutter\nbrew install --cask flutter\n\n# Add to PATH (add to ~/.zshrc or ~/.bash_profile)\nexport PATH=\"$PATH:/opt/homebrew/bin/flutter/bin\"\n</code></pre></p> <p>Windows (Chocolatey): <pre><code># Install Chocolatey if not already installed\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n\n# Install Flutter\nchoco install flutter\n</code></pre></p> <p>Linux (Snap): <pre><code>sudo snap install flutter --classic\n</code></pre></p>"},{"location":"setup/environment-setup/#option-2-manual-installation","title":"Option 2: Manual Installation","text":"<ol> <li>Download Flutter SDK</li> <li>Visit flutter.dev</li> <li> <p>Download the appropriate SDK for your platform</p> </li> <li> <p>Extract and Setup PATH <pre><code># Extract to desired location\ncd ~/development\nunzip ~/Downloads/flutter_macos_3.35.4-stable.zip\n\n# Add to PATH\nexport PATH=\"$PATH:`pwd`/flutter/bin\"\n</code></pre></p> </li> <li> <p>Verify Installation <pre><code>flutter --version\nflutter doctor\n</code></pre></p> </li> </ol>"},{"location":"setup/environment-setup/#ide-setup","title":"IDE Setup","text":""},{"location":"setup/environment-setup/#visual-studio-code-recommended","title":"Visual Studio Code (Recommended)","text":"<ol> <li>Install VS Code</li> <li> <p>Download from code.visualstudio.com</p> </li> <li> <p>Install Flutter Extensions <pre><code># Essential extensions\ncode --install-extension Dart-Code.flutter\ncode --install-extension Dart-Code.dart-code\n\n# Recommended extensions\ncode --install-extension ms-vscode.vscode-json\ncode --install-extension bradlc.vscode-tailwindcss\ncode --install-extension usernamehw.errorlens\ncode --install-extension ms-vscode.vscode-typescript-next\n</code></pre></p> </li> <li> <p>Configure VS Code Settings <pre><code>{\n  \"dart.flutterSdkPath\": \"/path/to/flutter\",\n  \"dart.previewFlutterUiGuides\": true,\n  \"dart.previewFlutterUiGuidesCustomTracking\": true,\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.lineLength\": 120\n}\n</code></pre></p> </li> </ol>"},{"location":"setup/environment-setup/#android-studio","title":"Android Studio","text":"<ol> <li>Install Android Studio</li> <li> <p>Download from developer.android.com</p> </li> <li> <p>Install Flutter Plugin</p> </li> <li>Go to Preferences \u2192 Plugins</li> <li>Search for \"Flutter\" and install</li> <li>Restart Android Studio</li> </ol>"},{"location":"setup/environment-setup/#platform-setup","title":"Platform Setup","text":""},{"location":"setup/environment-setup/#android-development","title":"Android Development","text":"<ol> <li>Install Android Studio</li> <li>Follow the installation wizard</li> <li> <p>Install Android SDK, Platform-Tools, and Build-Tools</p> </li> <li> <p>Configure Android SDK <pre><code># Add to ~/.zshrc or ~/.bash_profile\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n</code></pre></p> </li> <li> <p>Accept Android Licenses <pre><code>flutter doctor --android-licenses\n</code></pre></p> </li> <li> <p>Create Android Emulator <pre><code># List available system images\navdmanager list\n\n# Create emulator\navdmanager create avd -n flutter_emulator -k \"system-images;android-33;google_apis;x86_64\"\n\n# Start emulator\nemulator -avd flutter_emulator\n</code></pre></p> </li> </ol>"},{"location":"setup/environment-setup/#ios-development-macos-only","title":"iOS Development (macOS only)","text":"<ol> <li>Install Xcode</li> <li>Download from Mac App Store</li> <li> <p>Install Xcode Command Line Tools:      <pre><code>sudo xcode-select --install\n</code></pre></p> </li> <li> <p>Configure Xcode <pre><code># Open Xcode and accept license\nsudo xcodebuild -license accept\n\n# Install iOS Simulator\nsudo xcodebuild -downloadPlatform iOS\n</code></pre></p> </li> <li> <p>Install CocoaPods <pre><code>sudo gem install cocoapods\n</code></pre></p> </li> <li> <p>Setup iOS Simulator <pre><code># List available simulators\nxcrun simctl list devices\n\n# Open iOS Simulator\nopen -a Simulator\n</code></pre></p> </li> </ol>"},{"location":"setup/environment-setup/#development-tools","title":"Development Tools","text":""},{"location":"setup/environment-setup/#git-configuration","title":"Git Configuration","text":"<pre><code># Configure Git\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Set default branch name\ngit config --global init.defaultBranch main\n\n# Configure line endings\ngit config --global core.autocrlf input  # macOS/Linux\ngit config --global core.autocrlf true   # Windows\n</code></pre>"},{"location":"setup/environment-setup/#package-managers","title":"Package Managers","text":"<p>macOS (Homebrew): <pre><code># Install useful development tools\nbrew install git\nbrew install --cask sourcetree\nbrew install --cask postman\n</code></pre></p> <p>Windows (Chocolatey): <pre><code># Install useful development tools\nchoco install git\nchoco install sourcetree\nchoco install postman\n</code></pre></p>"},{"location":"setup/environment-setup/#verification","title":"Verification","text":""},{"location":"setup/environment-setup/#run-flutter-doctor","title":"Run Flutter Doctor","text":"<pre><code>flutter doctor -v\n</code></pre> <p>Expected output should show: - \u2705 Flutter (Channel stable, version 3.35.4) - \u2705 Android toolchain - \u2705 Xcode (macOS only) - \u2705 VS Code or Android Studio - \u2705 Connected device</p>"},{"location":"setup/environment-setup/#create-test-project","title":"Create Test Project","text":"<pre><code># Create a test project\nflutter create test_app\ncd test_app\n\n# Run the app\nflutter run\n</code></pre>"},{"location":"setup/environment-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setup/environment-setup/#common-issues","title":"Common Issues","text":"<p>Flutter command not found: <pre><code># Check PATH\necho $PATH\n\n# Add Flutter to PATH\nexport PATH=\"$PATH:/path/to/flutter/bin\"\n</code></pre></p> <p>Android licenses not accepted: <pre><code>flutter doctor --android-licenses\n</code></pre></p> <p>iOS development issues: <pre><code># Reset iOS Simulator\nxcrun simctl erase all\n\n# Reinstall CocoaPods\nsudo gem uninstall cocoapods\nsudo gem install cocoapods\n</code></pre></p> <p>Permission issues (macOS): <pre><code># Fix permissions\nsudo chown -R $(whoami) /usr/local/lib/node_modules\n</code></pre></p>"},{"location":"setup/environment-setup/#performance-optimization","title":"Performance Optimization","text":""},{"location":"setup/environment-setup/#development-settings","title":"Development Settings","text":"<pre><code># Enable web support (if needed)\nflutter config --enable-web\n\n# Disable analytics (optional)\nflutter config --no-analytics\n\n# Set up pre-compilation\nflutter config --enable-native-assets\n</code></pre>"},{"location":"setup/environment-setup/#ide-performance","title":"IDE Performance","text":"<p>VS Code: - Disable unnecessary extensions - Increase memory limit in settings - Use workspace-specific settings</p> <p>Android Studio: - Increase heap size in studio.vmoptions - Disable unused plugins - Use hardware acceleration</p>"},{"location":"setup/environment-setup/#next-steps","title":"Next Steps","text":"<p>After completing the environment setup:</p> <ol> <li>\u2705 Verify all tools are working with <code>flutter doctor</code></li> <li>\u2705 Create a test project and run it</li> <li>\u2705 Set up your preferred IDE with Flutter extensions</li> <li>\u2705 Configure version control (Git)</li> <li>\u2705 Proceed to Project Structure</li> </ol> <p>Your Flutter development environment is now ready for building production-grade applications!</p>"},{"location":"setup/flutter-installation/","title":"Flutter Installation Guide","text":"<p>Complete guide for installing Flutter and setting up your development environment for the Instagram Clone project.</p>"},{"location":"setup/flutter-installation/#overview","title":"Overview","text":"<p>This guide will help you install Flutter and set up your development environment on macOS, Windows, and Linux. Follow the steps for your operating system to get started with Flutter development.</p>"},{"location":"setup/flutter-installation/#prerequisites","title":"Prerequisites","text":""},{"location":"setup/flutter-installation/#system-requirements","title":"System Requirements","text":"<p>macOS: - macOS 10.14 (Mojave) or later - Disk space: 2.8 GB (does not include disk space for IDE/tools) - Tools: bash, curl, file, git 2.x, mkdir, rm, unzip, which, zip</p> <p>Windows: - Windows 10 or later (64-bit), x86-64 based - Disk space: 1.64 GB (does not include disk space for IDE/tools) - Tools: PowerShell 5.0 or newer, Git for Windows 2.x</p> <p>Linux: - 64-bit distribution - Disk space: 600 MB (does not include disk space for IDE/tools) - Tools: bash, curl, file, git 2.x, mkdir, rm, unzip, which, xz-utils, zip, libglu1-mesa</p>"},{"location":"setup/flutter-installation/#macos-installation","title":"macOS Installation","text":""},{"location":"setup/flutter-installation/#step-1-download-flutter-sdk","title":"Step 1: Download Flutter SDK","text":"<ol> <li> <p>Download the latest stable Flutter SDK:    <pre><code>cd ~/development\ncurl -O https://storage.googleapis.com/flutter_infra_release/releases/stable/macos/flutter_macos_3.35.0-stable.zip\nunzip flutter_macos_3.35.0-stable.zip\n</code></pre></p> </li> <li> <p>Add Flutter to your PATH:    <pre><code>export PATH=\"$PATH:`pwd`/flutter/bin\"\n</code></pre></p> </li> <li> <p>Make the PATH change permanent:    <pre><code>echo 'export PATH=\"$PATH:$HOME/development/flutter/bin\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n</code></pre></p> </li> </ol>"},{"location":"setup/flutter-installation/#step-2-install-xcode","title":"Step 2: Install Xcode","text":"<ol> <li>Install Xcode from the App Store or Apple Developer site</li> <li> <p>Configure Xcode command-line tools:    <pre><code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nsudo xcodebuild -runFirstLaunch\n</code></pre></p> </li> <li> <p>Accept the Xcode license:    <pre><code>sudo xcodebuild -license accept\n</code></pre></p> </li> </ol>"},{"location":"setup/flutter-installation/#step-3-install-cocoapods","title":"Step 3: Install CocoaPods","text":"<pre><code>sudo gem install cocoapods\n</code></pre>"},{"location":"setup/flutter-installation/#step-4-set-up-ios-simulator","title":"Step 4: Set up iOS Simulator","text":"<ol> <li>Open Xcode</li> <li>Go to Xcode &gt; Preferences &gt; Components</li> <li>Install an iOS Simulator</li> </ol>"},{"location":"setup/flutter-installation/#windows-installation","title":"Windows Installation","text":""},{"location":"setup/flutter-installation/#step-1-download-flutter-sdk_1","title":"Step 1: Download Flutter SDK","text":"<ol> <li>Download the Flutter SDK from flutter.dev</li> <li>Extract the zip file to <code>C:\\src\\flutter</code></li> <li>Add Flutter to your PATH:</li> <li>Search for \"Environment Variables\" in Windows search</li> <li>Click \"Environment Variables\"</li> <li>Under \"User variables\", find \"Path\" and click \"Edit\"</li> <li>Click \"New\" and add <code>C:\\src\\flutter\\bin</code></li> </ol>"},{"location":"setup/flutter-installation/#step-2-install-android-studio","title":"Step 2: Install Android Studio","text":"<ol> <li>Download and install Android Studio</li> <li>Start Android Studio and go through the setup wizard</li> <li>Install the Flutter and Dart plugins:</li> <li>File &gt; Settings &gt; Plugins</li> <li>Search for \"Flutter\" and install</li> <li>Restart Android Studio</li> </ol>"},{"location":"setup/flutter-installation/#step-3-set-up-android-emulator","title":"Step 3: Set up Android Emulator","text":"<ol> <li>Open Android Studio</li> <li>Go to Tools &gt; AVD Manager</li> <li>Click \"Create Virtual Device\"</li> <li>Select a device and system image</li> <li>Click \"Finish\"</li> </ol>"},{"location":"setup/flutter-installation/#linux-installation","title":"Linux Installation","text":""},{"location":"setup/flutter-installation/#step-1-download-flutter-sdk_2","title":"Step 1: Download Flutter SDK","text":"<ol> <li> <p>Download the Flutter SDK:    <pre><code>cd ~/development\nwget https://storage.googleapis.com/flutter_infra_release/releases/stable/linux/flutter_linux_3.35.0-stable.tar.xz\ntar xf flutter_linux_3.35.0-stable.tar.xz\n</code></pre></p> </li> <li> <p>Add Flutter to your PATH:    <pre><code>export PATH=\"$PATH:`pwd`/flutter/bin\"\necho 'export PATH=\"$PATH:$HOME/development/flutter/bin\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p> </li> </ol>"},{"location":"setup/flutter-installation/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<pre><code>sudo apt-get update\nsudo apt-get install curl git unzip xz-utils zip libglu1-mesa\n</code></pre>"},{"location":"setup/flutter-installation/#step-3-install-android-studio","title":"Step 3: Install Android Studio","text":"<ol> <li>Download Android Studio from the official website</li> <li>Extract and run:    <pre><code>sudo tar -xzf android-studio-*.tar.gz -C /opt/\n/opt/android-studio/bin/studio.sh\n</code></pre></li> </ol>"},{"location":"setup/flutter-installation/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"setup/flutter-installation/#install-visual-studio-code-recommended","title":"Install Visual Studio Code (Recommended)","text":"<ol> <li>Download and install VS Code</li> <li>Install Flutter extension:</li> <li>Open VS Code</li> <li>Go to Extensions (Ctrl+Shift+X)</li> <li>Search for \"Flutter\" and install</li> <li>This will also install the Dart extension</li> </ol>"},{"location":"setup/flutter-installation/#configure-vs-code-for-flutter","title":"Configure VS Code for Flutter","text":"<ol> <li>Open Command Palette (Ctrl+Shift+P)</li> <li>Type \"Flutter: New Project\"</li> <li>Select \"Application\"</li> <li>Choose a location and project name</li> </ol>"},{"location":"setup/flutter-installation/#verify-installation","title":"Verify Installation","text":"<p>Run Flutter doctor to check your installation:</p> <pre><code>flutter doctor\n</code></pre> <p>You should see output similar to: <pre><code>Doctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel stable, 3.35.0, on macOS 14.0 23A344 darwin-arm64, locale en-US)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 34.0.0)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 15.0)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2023.1)\n[\u2713] VS Code (version 1.84.0)\n[\u2713] Connected device (3 available)\n[\u2713] Network resources\n</code></pre></p>"},{"location":"setup/flutter-installation/#fix-common-issues","title":"Fix Common Issues","text":"<p>Android License Issues: <pre><code>flutter doctor --android-licenses\n</code></pre></p> <p>iOS Development Setup: <pre><code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nsudo xcodebuild -runFirstLaunch\n</code></pre></p> <p>CocoaPods Issues on macOS: <pre><code>export PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"\nexport GEM_HOME=\"$HOME/.gem/ruby/3.4.0\"\nexport GEM_PATH=\"$GEM_HOME\"\nexport PATH=\"$GEM_HOME/bin:$PATH\"\ngem install cocoapods\n</code></pre></p>"},{"location":"setup/flutter-installation/#create-your-first-flutter-app","title":"Create Your First Flutter App","text":"<p>Test your installation by creating a new Flutter app:</p> <pre><code>flutter create my_first_app\ncd my_first_app\nflutter run\n</code></pre>"},{"location":"setup/flutter-installation/#device-setup","title":"Device Setup","text":""},{"location":"setup/flutter-installation/#ios-device-macos-only","title":"iOS Device (macOS only)","text":"<ol> <li>Connect your iOS device via USB</li> <li>Trust the computer on your device</li> <li>In Xcode, go to Window &gt; Devices and Simulators</li> <li>Select your device and click \"Use for Development\"</li> </ol>"},{"location":"setup/flutter-installation/#android-device","title":"Android Device","text":"<ol> <li>Enable Developer Options on your Android device:</li> <li>Go to Settings &gt; About phone</li> <li>Tap \"Build number\" 7 times</li> <li>Enable USB Debugging:</li> <li>Go to Settings &gt; Developer options</li> <li>Enable \"USB debugging\"</li> <li>Connect your device via USB</li> <li>Accept the USB debugging prompt</li> </ol>"},{"location":"setup/flutter-installation/#updating-flutter","title":"Updating Flutter","text":"<p>Keep Flutter up to date:</p> <pre><code>flutter upgrade\n</code></pre> <p>Check for updates: <pre><code>flutter --version\n</code></pre></p>"},{"location":"setup/flutter-installation/#ide-configuration","title":"IDE Configuration","text":""},{"location":"setup/flutter-installation/#android-studio-setup","title":"Android Studio Setup","text":"<ol> <li>Install Flutter and Dart plugins</li> <li>Configure SDK paths:</li> <li>File &gt; Project Structure &gt; SDKs</li> <li>Add Flutter SDK path</li> <li>Set up emulator:</li> <li>Tools &gt; AVD Manager</li> <li>Create Virtual Device</li> </ol>"},{"location":"setup/flutter-installation/#vs-code-setup","title":"VS Code Setup","text":"<ol> <li>Install extensions:</li> <li>Flutter</li> <li>Dart</li> <li>Flutter Widget Snippets (optional)</li> <li> <p>Awesome Flutter Snippets (optional)</p> </li> <li> <p>Configure settings.json:    <pre><code>{\n  \"dart.flutterSdkPath\": \"/path/to/flutter\",\n  \"dart.previewFlutterUiGuides\": true,\n  \"dart.previewFlutterUiGuidesCustomTracking\": true\n}\n</code></pre></p> </li> </ol>"},{"location":"setup/flutter-installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li> <p>Clone the Instagram Clone Project:    <pre><code>git clone https://github.com/rcdelacruz/flutter_instagram_app.git\ncd flutter_instagram_app\nflutter pub get\n</code></pre></p> </li> <li> <p>Set up Supabase: Follow the Supabase Setup Guide</p> </li> <li> <p>Start Development: Begin with the Self-Paced Training Guide</p> </li> </ol>"},{"location":"setup/flutter-installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setup/flutter-installation/#common-issues","title":"Common Issues","text":"<p>Flutter command not found: - Ensure Flutter is in your PATH - Restart your terminal/IDE</p> <p>Android SDK not found: - Install Android Studio - Run <code>flutter doctor --android-licenses</code></p> <p>iOS build issues: - Update Xcode to latest version - Run <code>pod install</code> in ios/ directory</p> <p>Permission denied errors: - Check file permissions - Use <code>sudo</code> if necessary (not recommended for Flutter SDK)</p>"},{"location":"setup/flutter-installation/#getting-help","title":"Getting Help","text":"<ul> <li>Flutter Documentation</li> <li>Flutter Community</li> <li>Stack Overflow</li> <li>Flutter Discord</li> </ul>"},{"location":"setup/flutter-installation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Flutter Cookbook</li> <li>Flutter Samples</li> <li>Dart Language Tour</li> <li>Material Design Guidelines</li> </ul> <p>Your Flutter development environment is now ready!</p>"},{"location":"setup/package-management/","title":"Flutter Package Management","text":"<p>Comprehensive guide to managing dependencies, packages, and libraries in Flutter projects for production-grade applications.</p>"},{"location":"setup/package-management/#package-management-fundamentals","title":"Package Management Fundamentals","text":""},{"location":"setup/package-management/#pubdev-the-official-package-repository","title":"pub.dev - The Official Package Repository","text":"<p>Flutter uses pub.dev as the official package repository, similar to npm for JavaScript or PyPI for Python.</p> <ul> <li>Official packages: Maintained by the Flutter team</li> <li>Community packages: Maintained by the community</li> <li>Verified publishers: Packages from trusted organizations</li> </ul>"},{"location":"setup/package-management/#pubspecyaml-the-dependency-file","title":"pubspec.yaml - The Dependency File","text":"<p>The <code>pubspec.yaml</code> file is the heart of Flutter package management:</p> <pre><code>name: flutter_instagram_app\ndescription: A production-grade Flutter Instagram clone\nversion: 1.0.0+1\n\nenvironment:\n  sdk: '&gt;=3.5.0 &lt;4.0.0'\n  flutter: \"&gt;=3.35.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # Production dependencies\n  riverpod: ^2.4.0\n  go_router: ^12.0.0\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  # Development-only dependencies\n  flutter_lints: ^3.0.0\n  build_runner: ^2.4.0\n</code></pre>"},{"location":"setup/package-management/#essential-packages-for-instagram-clone","title":"Essential Packages for Instagram Clone","text":""},{"location":"setup/package-management/#state-management","title":"State Management","text":"<pre><code>dependencies:\n  # Riverpod - Modern state management\n  riverpod: ^2.4.0\n  flutter_riverpod: ^2.4.0\n\n  # Alternative: BLoC pattern\n  flutter_bloc: ^8.1.0\n\n  # Alternative: Provider (simpler)\n  provider: ^6.1.0\n</code></pre>"},{"location":"setup/package-management/#navigation","title":"Navigation","text":"<pre><code>dependencies:\n  # Go Router - Declarative routing\n  go_router: ^12.0.0\n\n  # Alternative: Auto Route\n  auto_route: ^7.8.0\n</code></pre>"},{"location":"setup/package-management/#network-api","title":"Network &amp; API","text":"<pre><code>dependencies:\n  # Dio - HTTP client\n  dio: ^5.3.0\n\n  # Supabase - Backend as a Service\n  supabase_flutter: ^2.0.0\n\n  # HTTP - Simple HTTP client\n  http: ^1.1.0\n\n  # Connectivity - Network status\n  connectivity_plus: ^5.0.0\n</code></pre>"},{"location":"setup/package-management/#ui-styling","title":"UI &amp; Styling","text":"<pre><code>dependencies:\n  # Image handling\n  cached_network_image: ^3.3.0\n  image_picker: ^1.0.0\n\n  # SVG support\n  flutter_svg: ^2.0.0\n\n  # Animations\n  lottie: ^2.7.0\n\n  # Screen adaptation\n  flutter_screenutil: ^5.9.0\n\n  # Icons\n  cupertino_icons: ^1.0.0\n  font_awesome_flutter: ^10.6.0\n</code></pre>"},{"location":"setup/package-management/#storage-persistence","title":"Storage &amp; Persistence","text":"<pre><code>dependencies:\n  # Simple key-value storage\n  shared_preferences: ^2.2.0\n\n  # Secure storage\n  flutter_secure_storage: ^9.0.0\n\n  # SQLite database\n  sqflite: ^2.3.0\n\n  # Object box (alternative)\n  objectbox_flutter_libs: ^2.0.0\n</code></pre>"},{"location":"setup/package-management/#development-tools","title":"Development Tools","text":"<pre><code>dev_dependencies:\n  # Testing\n  flutter_test:\n    sdk: flutter\n  mockito: ^5.4.0\n\n  # Code generation\n  build_runner: ^2.4.0\n  json_annotation: ^4.8.0\n  json_serializable: ^6.7.0\n\n  # Linting\n  flutter_lints: ^3.0.0\n  very_good_analysis: ^5.1.0\n\n  # Code coverage\n  coverage: ^1.7.0\n</code></pre>"},{"location":"setup/package-management/#package-installation-commands","title":"Package Installation Commands","text":""},{"location":"setup/package-management/#adding-dependencies","title":"Adding Dependencies","text":"<pre><code># Add a package\nflutter pub add package_name\n\n# Add a dev dependency\nflutter pub add --dev package_name\n\n# Add with specific version\nflutter pub add package_name:^1.0.0\n\n# Add multiple packages\nflutter pub add riverpod go_router dio\n</code></pre>"},{"location":"setup/package-management/#removing-dependencies","title":"Removing Dependencies","text":"<pre><code># Remove a package\nflutter pub remove package_name\n\n# Remove multiple packages\nflutter pub remove package1 package2\n</code></pre>"},{"location":"setup/package-management/#updating-dependencies","title":"Updating Dependencies","text":"<pre><code># Get dependencies\nflutter pub get\n\n# Update all packages\nflutter pub upgrade\n\n# Update specific package\nflutter pub upgrade package_name\n\n# Update with major version changes\nflutter pub upgrade --major-versions\n</code></pre>"},{"location":"setup/package-management/#version-constraints","title":"Version Constraints","text":""},{"location":"setup/package-management/#semantic-versioning","title":"Semantic Versioning","text":"<p>Flutter follows semantic versioning (semver):</p> <pre><code>dependencies:\n  # Caret constraint (recommended)\n  package_name: ^1.2.3  # &gt;=1.2.3 &lt;2.0.0\n\n  # Exact version\n  package_name: 1.2.3\n\n  # Range constraint\n  package_name: '&gt;=1.2.3 &lt;2.0.0'\n\n  # Any version (not recommended)\n  package_name: any\n</code></pre>"},{"location":"setup/package-management/#best-practices-for-versioning","title":"Best Practices for Versioning","text":"<pre><code>dependencies:\n  # Use caret constraints for stability\n  riverpod: ^2.4.0\n\n  # Pin critical packages if needed\n  flutter:\n    sdk: flutter\n\n  # Use git dependencies for forks\n  custom_package:\n    git:\n      url: https://github.com/user/custom_package.git\n      ref: main\n\n  # Use path dependencies for local packages\n  local_package:\n    path: ../local_package\n</code></pre>"},{"location":"setup/package-management/#package-categories","title":"Package Categories","text":""},{"location":"setup/package-management/#ui-components","title":"UI Components","text":"<pre><code>dependencies:\n  # Material Design\n  flutter:\n    sdk: flutter\n\n  # Cupertino (iOS style)\n  cupertino_icons: ^1.0.0\n\n  # Custom UI libraries\n  flutter_staggered_grid_view: ^0.7.0\n  shimmer: ^3.0.0\n  pull_to_refresh: ^2.0.0\n</code></pre>"},{"location":"setup/package-management/#utilities","title":"Utilities","text":"<pre><code>dependencies:\n  # Date/time handling\n  intl: ^0.18.0\n  timeago: ^3.5.0\n\n  # Functional programming\n  dartz: ^0.10.0\n\n  # Logging\n  logger: ^2.0.0\n\n  # UUID generation\n  uuid: ^4.1.0\n</code></pre>"},{"location":"setup/package-management/#platform-integration","title":"Platform Integration","text":"<pre><code>dependencies:\n  # Device info\n  device_info_plus: ^9.1.0\n\n  # Package info\n  package_info_plus: ^4.2.0\n\n  # URL launcher\n  url_launcher: ^6.2.0\n\n  # Share functionality\n  share_plus: ^7.2.0\n\n  # Permissions\n  permission_handler: ^11.0.0\n</code></pre>"},{"location":"setup/package-management/#code-generation","title":"Code Generation","text":""},{"location":"setup/package-management/#setup-for-json-serialization","title":"Setup for JSON Serialization","text":"<pre><code>dependencies:\n  json_annotation: ^4.8.0\n\ndev_dependencies:\n  build_runner: ^2.4.0\n  json_serializable: ^6.7.0\n</code></pre>"},{"location":"setup/package-management/#running-code-generation","title":"Running Code Generation","text":"<pre><code># One-time generation\nflutter packages pub run build_runner build\n\n# Watch for changes\nflutter packages pub run build_runner watch\n\n# Clean and rebuild\nflutter packages pub run build_runner build --delete-conflicting-outputs\n</code></pre>"},{"location":"setup/package-management/#dependency-management-best-practices","title":"Dependency Management Best Practices","text":""},{"location":"setup/package-management/#1-regular-updates","title":"1. Regular Updates","text":"<pre><code># Check for outdated packages\nflutter pub outdated\n\n# Update regularly but test thoroughly\nflutter pub upgrade --dry-run\nflutter pub upgrade\n</code></pre>"},{"location":"setup/package-management/#2-security-considerations","title":"2. Security Considerations","text":"<pre><code># Audit dependencies for security issues\nflutter pub deps\n\n# Check package scores on pub.dev\n# Look for:\n# - Popularity score\n# - Pub points\n# - Likes count\n# - Maintenance status\n</code></pre>"},{"location":"setup/package-management/#3-performance-impact","title":"3. Performance Impact","text":"<pre><code># Prefer smaller, focused packages\ndependencies:\n  # Good: Specific functionality\n  cached_network_image: ^3.3.0\n\n  # Avoid: Large, monolithic packages\n  # unless absolutely necessary\n</code></pre>"},{"location":"setup/package-management/#4-dependency-conflicts","title":"4. Dependency Conflicts","text":"<pre><code># Resolve conflicts\nflutter pub deps\nflutter pub upgrade --major-versions\n\n# Use dependency overrides (last resort)\ndependency_overrides:\n  package_name: ^1.0.0\n</code></pre>"},{"location":"setup/package-management/#package-development","title":"Package Development","text":""},{"location":"setup/package-management/#creating-a-package","title":"Creating a Package","text":"<pre><code># Create a new package\nflutter create --template=package my_package\n\n# Create a plugin (with platform code)\nflutter create --template=plugin my_plugin\n</code></pre>"},{"location":"setup/package-management/#package-structure","title":"Package Structure","text":"<pre><code>my_package/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 my_package.dart      # Main export file\n\u2502   \u2514\u2500\u2500 src/                 # Implementation\n\u251c\u2500\u2500 test/                    # Tests\n\u251c\u2500\u2500 example/                 # Example app\n\u251c\u2500\u2500 pubspec.yaml            # Package metadata\n\u251c\u2500\u2500 README.md               # Documentation\n\u251c\u2500\u2500 CHANGELOG.md            # Version history\n\u2514\u2500\u2500 LICENSE                 # License file\n</code></pre>"},{"location":"setup/package-management/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setup/package-management/#common-issues","title":"Common Issues","text":"<p>Dependency conflicts: <pre><code># Clear pub cache\nflutter pub cache clean\n\n# Delete pubspec.lock and reinstall\nrm pubspec.lock\nflutter pub get\n</code></pre></p> <p>Build failures: <pre><code># Clean build\nflutter clean\nflutter pub get\n\n# Regenerate code\nflutter packages pub run build_runner clean\nflutter packages pub run build_runner build\n</code></pre></p> <p>Version conflicts: <pre><code># Check dependency tree\nflutter pub deps\n\n# Use dependency overrides\ndependency_overrides:\n  conflicting_package: ^1.0.0\n</code></pre></p>"},{"location":"setup/package-management/#production-considerations","title":"Production Considerations","text":""},{"location":"setup/package-management/#1-package-audit","title":"1. Package Audit","text":"<p>Before production: - Review all dependencies - Check for security vulnerabilities - Verify maintenance status - Test thoroughly</p>"},{"location":"setup/package-management/#2-bundle-size-optimization","title":"2. Bundle Size Optimization","text":"<pre><code># Use tree shaking\nflutter build apk --tree-shake-icons\n\n# Analyze bundle size\nflutter build apk --analyze-size\n</code></pre>"},{"location":"setup/package-management/#3-license-compliance","title":"3. License Compliance","text":"<pre><code># Generate license file\nflutter pub deps --json &gt; licenses.json\n</code></pre>"},{"location":"setup/package-management/#next-steps","title":"Next Steps","text":"<p>After setting up package management:</p> <ol> <li>\u2705 Configure essential packages for your project</li> <li>\u2705 Set up code generation if needed</li> <li>\u2705 Implement dependency update workflow</li> <li>\u2705 Proceed to Supabase Setup</li> </ol> <p>Your Flutter package management is now configured for production-grade development!</p>"},{"location":"setup/project-structure/","title":"Flutter Project Structure","text":"<p>Learn how to organize your Flutter project for scalability, maintainability, and team collaboration. This guide presents a progressive approach that starts simple and evolves as your app grows.</p>"},{"location":"setup/project-structure/#architecture-evolution-strategy","title":"Architecture Evolution Strategy","text":""},{"location":"setup/project-structure/#start-simple-scale-smart","title":"Start Simple \u2192 Scale Smart","text":"<ol> <li>Small Projects (&lt; 10 screens): Use Flat Structure</li> <li>Medium Projects (10-30 screens): Introduce Feature Grouping</li> <li>Large Projects (30+ screens): Adopt Clean Architecture</li> </ol>"},{"location":"setup/project-structure/#phase-1-flat-structure-recommended-start","title":"Phase 1: Flat Structure (Recommended Start)","text":"<p>Perfect for: New projects, MVPs, small teams, learning</p> <pre><code>flutter_instagram_app/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 main.dart                       # App entry point\n\u2502   \u251c\u2500\u2500 app.dart                        # App configuration\n\u2502   \u251c\u2500\u2500 screens/                        # App screens\n\u2502   \u2502   \u251c\u2500\u2500 auth/                       # Authentication screens\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 login_screen.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 register_screen.dart\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 forgot_password_screen.dart\n\u2502   \u2502   \u251c\u2500\u2500 home/                       # Home screens\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 home_screen.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 feed_screen.dart\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 profile_screen.dart\n\u2502   \u2502   \u2514\u2500\u2500 shared/                     # Shared screens\n\u2502   \u2502       \u251c\u2500\u2500 splash_screen.dart\n\u2502   \u2502       \u2514\u2500\u2500 error_screen.dart\n\u2502   \u251c\u2500\u2500 widgets/                        # Reusable widgets\n\u2502   \u2502   \u251c\u2500\u2500 common/                     # Common widgets\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 custom_button.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 custom_text_field.dart\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 loading_indicator.dart\n\u2502   \u2502   \u251c\u2500\u2500 cards/                      # Card widgets\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 post_card.dart\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 user_card.dart\n\u2502   \u2502   \u2514\u2500\u2500 forms/                      # Form widgets\n\u2502   \u2502       \u251c\u2500\u2500 login_form.dart\n\u2502   \u2502       \u2514\u2500\u2500 register_form.dart\n\u2502   \u251c\u2500\u2500 models/                         # Data models\n\u2502   \u2502   \u251c\u2500\u2500 user.dart\n\u2502   \u2502   \u251c\u2500\u2500 post.dart\n\u2502   \u2502   \u2514\u2500\u2500 comment.dart\n\u2502   \u251c\u2500\u2500 services/                       # Business logic services\n\u2502   \u2502   \u251c\u2500\u2500 auth_service.dart\n\u2502   \u2502   \u251c\u2500\u2500 api_service.dart\n\u2502   \u2502   \u2514\u2500\u2500 storage_service.dart\n\u2502   \u251c\u2500\u2500 providers/                      # State management\n\u2502   \u2502   \u251c\u2500\u2500 auth_provider.dart\n\u2502   \u2502   \u251c\u2500\u2500 feed_provider.dart\n\u2502   \u2502   \u2514\u2500\u2500 user_provider.dart\n\u2502   \u251c\u2500\u2500 utils/                          # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 constants.dart\n\u2502   \u2502   \u251c\u2500\u2500 helpers.dart\n\u2502   \u2502   \u2514\u2500\u2500 validators.dart\n\u2502   \u2514\u2500\u2500 config/                         # Configuration\n\u2502       \u251c\u2500\u2500 app_config.dart\n\u2502       \u251c\u2500\u2500 theme.dart\n\u2502       \u2514\u2500\u2500 routes.dart\n\u251c\u2500\u2500 assets/                             # Static assets\n\u2502   \u251c\u2500\u2500 images/                         # Image files\n\u2502   \u251c\u2500\u2500 icons/                          # Icon files\n\u2502   \u251c\u2500\u2500 fonts/                          # Custom fonts\n\u2502   \u2514\u2500\u2500 animations/                     # Lottie animations\n\u251c\u2500\u2500 test/                               # Test files\n\u2502   \u251c\u2500\u2500 unit/                           # Unit tests\n\u2502   \u251c\u2500\u2500 widget/                         # Widget tests\n\u2502   \u2514\u2500\u2500 integration/                    # Integration tests\n\u251c\u2500\u2500 docs/                               # Documentation\n\u251c\u2500\u2500 android/                            # Android-specific code\n\u251c\u2500\u2500 ios/                                # iOS-specific code\n\u251c\u2500\u2500 web/                                # Web-specific code\n\u251c\u2500\u2500 pubspec.yaml                        # Dependencies\n\u251c\u2500\u2500 analysis_options.yaml              # Linting rules\n\u2514\u2500\u2500 README.md                           # Project documentation\n</code></pre>"},{"location":"setup/project-structure/#flat-structure-benefits","title":"Flat Structure Benefits","text":"<ul> <li>Simple to understand and navigate</li> <li>Fast development for small teams</li> <li>Easy refactoring when starting out</li> <li>Minimal cognitive overhead</li> <li>Perfect for rapid prototyping</li> </ul>"},{"location":"setup/project-structure/#phase-2-feature-grouping-growing-projects","title":"Phase 2: Feature Grouping (Growing Projects)","text":"<p>Perfect for: 10-30 screens, multiple developers, clear feature boundaries</p> <pre><code>flutter_instagram_app/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 main.dart                       # App entry point\n\u2502   \u251c\u2500\u2500 app.dart                        # App configuration\n\u2502   \u251c\u2500\u2500 features/                       # Feature modules\n\u2502   \u2502   \u251c\u2500\u2500 auth/                       # Authentication feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 screens/                # Auth screens\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login_screen.dart\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 register_screen.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 widgets/                # Auth-specific widgets\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 auth_form.dart\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 social_login_button.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 providers/              # Auth state management\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 auth_provider.dart\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/               # Auth services\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 auth_service.dart\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 models/                 # Auth models\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 user.dart\n\u2502   \u2502   \u251c\u2500\u2500 feed/                       # Feed feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 screens/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 widgets/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 providers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 profile/                    # Profile feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 screens/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 widgets/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 providers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 models/\n\u2502   \u2502   \u2514\u2500\u2500 chat/                       # Chat feature\n\u2502   \u2502       \u251c\u2500\u2500 screens/\n\u2502   \u2502       \u251c\u2500\u2500 widgets/\n\u2502   \u2502       \u251c\u2500\u2500 providers/\n\u2502   \u2502       \u251c\u2500\u2500 services/\n\u2502   \u2502       \u2514\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 shared/                         # Shared across features\n\u2502   \u2502   \u251c\u2500\u2500 widgets/                    # Common widgets\n\u2502   \u2502   \u251c\u2500\u2500 services/                   # Shared services\n\u2502   \u2502   \u251c\u2500\u2500 models/                     # Global models\n\u2502   \u2502   \u251c\u2500\u2500 providers/                  # Global providers\n\u2502   \u2502   \u2514\u2500\u2500 utils/                      # Utility functions\n\u2502   \u251c\u2500\u2500 core/                           # Core functionality\n\u2502   \u2502   \u251c\u2500\u2500 config/                     # App configuration\n\u2502   \u2502   \u251c\u2500\u2500 constants/                  # App constants\n\u2502   \u2502   \u251c\u2500\u2500 theme/                      # App theming\n\u2502   \u2502   \u251c\u2500\u2500 routes/                     # Navigation\n\u2502   \u2502   \u2514\u2500\u2500 errors/                     # Error handling\n\u2502   \u2514\u2500\u2500 generated/                      # Generated files\n\u251c\u2500\u2500 assets/                             # Static assets\n\u251c\u2500\u2500 test/                               # Test files\n\u2514\u2500\u2500 [config files...]                   # Configuration files\n</code></pre>"},{"location":"setup/project-structure/#feature-grouping-benefits","title":"Feature Grouping Benefits","text":"<ul> <li>Clear feature boundaries</li> <li>Easier team collaboration</li> <li>Reduced merge conflicts</li> <li>Better code organization</li> <li>Preparation for clean architecture</li> </ul>"},{"location":"setup/project-structure/#phase-3-clean-architecture-large-projects","title":"Phase 3: Clean Architecture (Large Projects)","text":"<p>Perfect for: 30+ screens, large teams, complex business logic</p> <pre><code>flutter_instagram_app/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 main.dart                       # App entry point\n\u2502   \u251c\u2500\u2500 app.dart                        # App configuration\n\u2502   \u251c\u2500\u2500 features/                       # Feature modules\n\u2502   \u2502   \u251c\u2500\u2500 auth/                       # Authentication feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 presentation/           # UI layer\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 screens/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 widgets/\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 providers/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 domain/                 # Business logic layer\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 usecases/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 data/                   # Data layer\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 datasources/\n\u2502   \u2502   \u251c\u2500\u2500 feed/                       # Feed feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 presentation/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 data/\n\u2502   \u2502   \u2514\u2500\u2500 profile/                    # Profile feature\n\u2502   \u2502       \u251c\u2500\u2500 presentation/\n\u2502   \u2502       \u251c\u2500\u2500 domain/\n\u2502   \u2502       \u2514\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 shared/                         # Shared across features\n\u2502   \u2502   \u251c\u2500\u2500 presentation/               # Shared UI components\n\u2502   \u2502   \u251c\u2500\u2500 domain/                     # Shared business logic\n\u2502   \u2502   \u2514\u2500\u2500 data/                       # Shared data layer\n\u2502   \u251c\u2500\u2500 core/                           # Core functionality\n\u2502   \u2502   \u251c\u2500\u2500 config/                     # App configuration\n\u2502   \u2502   \u251c\u2500\u2500 constants/                  # App constants\n\u2502   \u2502   \u251c\u2500\u2500 theme/                      # App theming\n\u2502   \u2502   \u251c\u2500\u2500 routes/                     # Navigation\n\u2502   \u2502   \u251c\u2500\u2500 network/                    # Network configuration\n\u2502   \u2502   \u251c\u2500\u2500 storage/                    # Local storage\n\u2502   \u2502   \u251c\u2500\u2500 utils/                      # Utility functions\n\u2502   \u2502   \u2514\u2500\u2500 errors/                     # Error handling\n\u2502   \u2514\u2500\u2500 generated/                      # Generated files\n\u251c\u2500\u2500 assets/                             # Static assets\n\u251c\u2500\u2500 test/                               # Test files\n\u2514\u2500\u2500 [config files...]                   # Configuration files\n</code></pre>"},{"location":"setup/project-structure/#clean-architecture-benefits","title":"Clean Architecture Benefits","text":"<ul> <li>Maximum scalability</li> <li>Team independence</li> <li>Clear separation of concerns</li> <li>Easier testing and maintenance</li> <li>Supports complex business logic</li> </ul>"},{"location":"setup/project-structure/#file-naming-conventions","title":"File Naming Conventions","text":""},{"location":"setup/project-structure/#dart-files","title":"Dart Files","text":"<ul> <li>Screens: <code>login_screen.dart</code>, <code>home_screen.dart</code></li> <li>Widgets: <code>custom_button.dart</code>, <code>post_card.dart</code></li> <li>Models: <code>user.dart</code>, <code>post.dart</code></li> <li>Services: <code>auth_service.dart</code>, <code>api_service.dart</code></li> <li>Providers: <code>auth_provider.dart</code>, <code>feed_provider.dart</code></li> <li>Utils: <code>validators.dart</code>, <code>helpers.dart</code></li> </ul>"},{"location":"setup/project-structure/#directories","title":"Directories","text":"<ul> <li>Use snake_case for directory names</li> <li>Group related files together</li> <li>Keep directory names descriptive but concise</li> </ul>"},{"location":"setup/project-structure/#import-organization","title":"Import Organization","text":"<pre><code>// 1. Dart SDK imports\nimport 'dart:async';\nimport 'dart:convert';\n\n// 2. Flutter framework imports\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n// 3. Third-party package imports\nimport 'package:provider/provider.dart';\nimport 'package:http/http.dart' as http;\n\n// 4. Internal imports (absolute paths)\nimport 'package:flutter_instagram_app/features/auth/auth.dart';\nimport 'package:flutter_instagram_app/shared/widgets/widgets.dart';\n\n// 5. Relative imports (same feature)\nimport '../widgets/login_form.dart';\nimport 'register_screen.dart';\n</code></pre>"},{"location":"setup/project-structure/#configuration-files","title":"Configuration Files","text":""},{"location":"setup/project-structure/#pubspecyaml-structure","title":"pubspec.yaml Structure","text":"<pre><code>name: flutter_instagram_app\ndescription: A production-grade Flutter Instagram clone\nversion: 1.0.0+1\n\nenvironment:\n  sdk: '&gt;=3.5.0 &lt;4.0.0'\n  flutter: \"&gt;=3.35.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # State Management\n  riverpod: ^2.4.0\n  flutter_riverpod: ^2.4.0\n\n  # Navigation\n  go_router: ^12.0.0\n\n  # Network &amp; API\n  dio: ^5.3.0\n  supabase_flutter: ^2.0.0\n\n  # UI &amp; Styling\n  cached_network_image: ^3.3.0\n  flutter_svg: ^2.0.0\n\n  # Storage\n  shared_preferences: ^2.2.0\n  flutter_secure_storage: ^9.0.0\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^3.0.0\n  build_runner: ^2.4.0\n\nflutter:\n  uses-material-design: true\n\n  assets:\n    - assets/images/\n    - assets/icons/\n    - assets/animations/\n\n  fonts:\n    - family: CustomFont\n      fonts:\n        - asset: assets/fonts/CustomFont-Regular.ttf\n        - asset: assets/fonts/CustomFont-Bold.ttf\n          weight: 700\n</code></pre>"},{"location":"setup/project-structure/#migration-guide","title":"Migration Guide","text":""},{"location":"setup/project-structure/#phase-1-phase-2-migration","title":"\ud83d\udd04 Phase 1 \u2192 Phase 2 Migration","text":"<ol> <li> <p>Create feature directories:    <pre><code>mkdir -p lib/features/{auth,feed,profile,chat}\n</code></pre></p> </li> <li> <p>Move related files:    <pre><code># Move auth-related files\nmv lib/screens/auth lib/features/auth/screens/\nmv lib/widgets/forms/login_form.dart lib/features/auth/widgets/\n</code></pre></p> </li> <li> <p>Update imports to use new paths</p> </li> <li>Create shared directory for common components</li> </ol>"},{"location":"setup/project-structure/#phase-2-phase-3-migration","title":"\ud83d\udd04 Phase 2 \u2192 Phase 3 Migration","text":"<ol> <li> <p>Create layer directories:    <pre><code>mkdir -p lib/features/auth/{presentation,domain,data}\n</code></pre></p> </li> <li> <p>Separate concerns:</p> </li> <li>Move UI to <code>presentation/</code></li> <li>Move business logic to <code>domain/</code></li> <li> <p>Move data handling to <code>data/</code></p> </li> <li> <p>Update imports and dependencies</p> </li> <li>Implement dependency injection</li> </ol>"},{"location":"setup/project-structure/#best-practices","title":"Best Practices","text":""},{"location":"setup/project-structure/#1-code-organization","title":"1. Code Organization","text":"<ul> <li>One class per file</li> <li>Group related functionality</li> <li>Use barrel exports (index.dart files)</li> <li>Keep files focused and small</li> </ul>"},{"location":"setup/project-structure/#2-state-management","title":"2. State Management","text":"<ul> <li>Choose appropriate state solution for project size</li> <li>Keep state close to where it's used</li> <li>Use immutable state objects</li> <li>Implement proper error handling</li> </ul>"},{"location":"setup/project-structure/#3-testing-structure","title":"3. Testing Structure","text":"<ul> <li>Mirror lib/ structure in test/</li> <li>Write tests for business logic</li> <li>Use widget tests for UI components</li> <li>Implement integration tests for user flows</li> </ul>"},{"location":"setup/project-structure/#decision-matrix","title":"Decision Matrix","text":"Project Size Team Size Complexity Recommended Phase 1-10 screens 1-2 devs Simple Phase 1 (Flat) 10-30 screens 2-5 devs Medium Phase 2 (Feature) 30+ screens 5+ devs Complex Phase 3 (Clean)"},{"location":"setup/project-structure/#next-steps","title":"Next Steps","text":"<ol> <li>Assess your current project using the decision matrix</li> <li>Choose the appropriate phase for your project size and team</li> <li>Set up your project structure following the templates</li> <li>Plan migration path for future growth</li> <li>Proceed to Supabase Setup</li> </ol> <p>Pro Tip: Start simple and evolve progressively. Each phase builds upon the previous one, making migration straightforward when the time comes.</p>"},{"location":"setup/supabase-setup/","title":"Complete Supabase Setup for Flutter","text":"<p>This guide covers the complete setup of Supabase for the Flutter Instagram clone app, including database, authentication, storage, and Row Level Security (RLS) policies.</p>"},{"location":"setup/supabase-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Supabase account (sign up at supabase.com)</li> <li>Flutter development environment set up</li> <li>Basic understanding of SQL and database concepts</li> </ul>"},{"location":"setup/supabase-setup/#1-create-a-new-supabase-project","title":"1. Create a New Supabase Project","text":"<ol> <li>Go to supabase.com and sign in</li> <li>Click \"New project\"</li> <li>Choose your organization</li> <li>Fill in project details:</li> <li>Name: <code>flutter-instagram-app</code> (or your preferred name)</li> <li>Database Password: Generate a strong password and save it</li> <li>Region: Choose the region closest to your users</li> <li>Click \"Create new project\"</li> <li>Wait for the project to be created (takes 1-2 minutes)</li> </ol>"},{"location":"setup/supabase-setup/#2-flutter-package-setup","title":"2. Flutter Package Setup","text":""},{"location":"setup/supabase-setup/#install-supabase-flutter-package","title":"Install Supabase Flutter Package","text":"<pre><code># pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # Supabase\n  supabase_flutter: ^2.0.0\n\n  # Additional packages for Instagram clone\n  image_picker: ^1.0.0\n  cached_network_image: ^3.3.0\n  shared_preferences: ^2.2.0\n  flutter_secure_storage: ^9.0.0\n</code></pre>"},{"location":"setup/supabase-setup/#environment-variables-setup","title":"Environment Variables Setup","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code># .env\nSUPABASE_URL=https://your-project.supabase.co\nSUPABASE_ANON_KEY=your-anon-public-key-here\n</code></pre> <p>Important: Add <code>.env</code> to your <code>.gitignore</code> file!</p>"},{"location":"setup/supabase-setup/#initialize-supabase-in-flutter","title":"Initialize Supabase in Flutter","text":"<pre><code>// lib/core/config/supabase_config.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nclass SupabaseConfig {\n  static late SupabaseClient client;\n\n  static Future&lt;void&gt; initialize() async {\n    await dotenv.load(fileName: \".env\");\n\n    await Supabase.initialize(\n      url: dotenv.env['SUPABASE_URL']!,\n      anonKey: dotenv.env['SUPABASE_ANON_KEY']!,\n      authOptions: const FlutterAuthClientOptions(\n        authFlowType: AuthFlowType.pkce,\n      ),\n      realtimeClientOptions: const RealtimeClientOptions(\n        logLevel: RealtimeLogLevel.info,\n      ),\n      storageOptions: const StorageClientOptions(\n        retryAttempts: 10,\n      ),\n    );\n\n    client = Supabase.instance.client;\n  }\n}\n\n// Usage in main.dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await SupabaseConfig.initialize();\n\n  runApp(const MyApp());\n}\n</code></pre>"},{"location":"setup/supabase-setup/#3-database-schema-setup","title":"3. Database Schema Setup","text":""},{"location":"setup/supabase-setup/#31-create-the-database-tables","title":"3.1 Create the Database Tables","text":"<p>Go to SQL Editor in your Supabase dashboard and run the following SQL:</p> <pre><code>-- Enable UUID extension\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Create profiles table\nCREATE TABLE profiles (\n  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,\n  username TEXT UNIQUE NOT NULL,\n  full_name TEXT,\n  bio TEXT,\n  avatar_url TEXT,\n  website TEXT,\n  is_private BOOLEAN DEFAULT false,\n  followers_count INTEGER DEFAULT 0,\n  following_count INTEGER DEFAULT 0,\n  posts_count INTEGER DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create posts table\nCREATE TABLE posts (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  image_url TEXT NOT NULL,\n  caption TEXT,\n  location TEXT,\n  likes_count INTEGER DEFAULT 0,\n  comments_count INTEGER DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create follows table\nCREATE TABLE follows (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  follower_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  following_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(follower_id, following_id),\n  CHECK (follower_id != following_id)\n);\n\n-- Create likes table\nCREATE TABLE likes (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  post_id UUID REFERENCES posts(id) ON DELETE CASCADE NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id, post_id)\n);\n\n-- Create comments table\nCREATE TABLE comments (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  post_id UUID REFERENCES posts(id) ON DELETE CASCADE NOT NULL,\n  content TEXT NOT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create stories table\nCREATE TABLE stories (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  image_url TEXT NOT NULL,\n  caption TEXT,\n  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '24 hours'),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create notifications table\nCREATE TABLE notifications (\n  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,\n  from_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  type TEXT NOT NULL CHECK (type IN ('like', 'comment', 'follow', 'mention')),\n  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,\n  comment_id UUID REFERENCES comments(id) ON DELETE CASCADE,\n  is_read BOOLEAN DEFAULT false,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n</code></pre>"},{"location":"setup/supabase-setup/#32-create-indexes-for-performance","title":"3.2 Create Indexes for Performance","text":"<pre><code>-- Create indexes for better query performance\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_created_at ON posts(created_at DESC);\nCREATE INDEX idx_follows_follower_id ON follows(follower_id);\nCREATE INDEX idx_follows_following_id ON follows(following_id);\nCREATE INDEX idx_likes_post_id ON likes(post_id);\nCREATE INDEX idx_likes_user_id ON likes(user_id);\nCREATE INDEX idx_comments_post_id ON comments(post_id);\nCREATE INDEX idx_comments_user_id ON comments(user_id);\nCREATE INDEX idx_stories_user_id ON stories(user_id);\nCREATE INDEX idx_stories_expires_at ON stories(expires_at);\nCREATE INDEX idx_notifications_user_id ON notifications(user_id);\nCREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);\n</code></pre>"},{"location":"setup/supabase-setup/#4-row-level-security-rls-setup","title":"4. Row Level Security (RLS) Setup","text":""},{"location":"setup/supabase-setup/#41-enable-rls-on-all-tables","title":"4.1 Enable RLS on All Tables","text":"<pre><code>-- Enable RLS on all tables\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE posts ENABLE ROW LEVEL SECURITY;\nALTER TABLE follows ENABLE ROW LEVEL SECURITY;\nALTER TABLE likes ENABLE ROW LEVEL SECURITY;\nALTER TABLE comments ENABLE ROW LEVEL SECURITY;\nALTER TABLE stories ENABLE ROW LEVEL SECURITY;\nALTER TABLE notifications ENABLE ROW LEVEL SECURITY;\n</code></pre>"},{"location":"setup/supabase-setup/#42-create-rls-policies","title":"4.2 Create RLS Policies","text":"<pre><code>-- Profiles policies\nCREATE POLICY \"Public profiles are viewable by everyone\" ON profiles\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can insert their own profile\" ON profiles\n  FOR INSERT WITH CHECK (auth.uid() = id);\n\nCREATE POLICY \"Users can update their own profile\" ON profiles\n  FOR UPDATE USING (auth.uid() = id);\n\n-- Posts policies\nCREATE POLICY \"Posts are viewable by everyone\" ON posts\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can insert their own posts\" ON posts\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own posts\" ON posts\n  FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own posts\" ON posts\n  FOR DELETE USING (auth.uid() = user_id);\n\n-- Follows policies\nCREATE POLICY \"Follows are viewable by everyone\" ON follows\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can follow others\" ON follows\n  FOR INSERT WITH CHECK (auth.uid() = follower_id);\n\nCREATE POLICY \"Users can unfollow others\" ON follows\n  FOR DELETE USING (auth.uid() = follower_id);\n\n-- Likes policies\nCREATE POLICY \"Likes are viewable by everyone\" ON likes\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can like posts\" ON likes\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can unlike posts\" ON likes\n  FOR DELETE USING (auth.uid() = user_id);\n\n-- Comments policies\nCREATE POLICY \"Comments are viewable by everyone\" ON comments\n  FOR SELECT USING (true);\n\nCREATE POLICY \"Users can insert their own comments\" ON comments\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own comments\" ON comments\n  FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own comments\" ON comments\n  FOR DELETE USING (auth.uid() = user_id);\n\n-- Stories policies\nCREATE POLICY \"Stories are viewable by everyone\" ON stories\n  FOR SELECT USING (expires_at &gt; NOW());\n\nCREATE POLICY \"Users can insert their own stories\" ON stories\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own stories\" ON stories\n  FOR DELETE USING (auth.uid() = user_id);\n\n-- Notifications policies\nCREATE POLICY \"Users can view their own notifications\" ON notifications\n  FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert notifications for others\" ON notifications\n  FOR INSERT WITH CHECK (auth.uid() = from_user_id);\n\nCREATE POLICY \"Users can update their own notifications\" ON notifications\n  FOR UPDATE USING (auth.uid() = user_id);\n</code></pre>"},{"location":"setup/supabase-setup/#5-database-functions-and-triggers","title":"5. Database Functions and Triggers","text":""},{"location":"setup/supabase-setup/#51-auto-update-timestamps","title":"5.1 Auto-update Timestamps","text":"<pre><code>-- Function to update updated_at timestamp\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\n-- Apply to tables with updated_at column\nCREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER update_posts_updated_at BEFORE UPDATE ON posts\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER update_comments_updated_at BEFORE UPDATE ON comments\n    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n</code></pre>"},{"location":"setup/supabase-setup/#52-auto-update-counters","title":"5.2 Auto-update Counters","text":"<pre><code>-- Function to update post counts\nCREATE OR REPLACE FUNCTION update_post_counts()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        -- Update posts count\n        UPDATE profiles SET posts_count = posts_count + 1 WHERE id = NEW.user_id;\n        RETURN NEW;\n    ELSIF TG_OP = 'DELETE' THEN\n        -- Update posts count\n        UPDATE profiles SET posts_count = posts_count - 1 WHERE id = OLD.user_id;\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$ language 'plpgsql';\n\n-- Function to update like counts\nCREATE OR REPLACE FUNCTION update_like_counts()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE posts SET likes_count = likes_count + 1 WHERE id = NEW.post_id;\n        RETURN NEW;\n    ELSIF TG_OP = 'DELETE' THEN\n        UPDATE posts SET likes_count = likes_count - 1 WHERE id = OLD.post_id;\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$ language 'plpgsql';\n\n-- Function to update comment counts\nCREATE OR REPLACE FUNCTION update_comment_counts()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE posts SET comments_count = comments_count + 1 WHERE id = NEW.post_id;\n        RETURN NEW;\n    ELSIF TG_OP = 'DELETE' THEN\n        UPDATE posts SET comments_count = comments_count - 1 WHERE id = OLD.post_id;\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$ language 'plpgsql';\n\n-- Function to update follow counts\nCREATE OR REPLACE FUNCTION update_follow_counts()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE profiles SET followers_count = followers_count + 1 WHERE id = NEW.following_id;\n        UPDATE profiles SET following_count = following_count + 1 WHERE id = NEW.follower_id;\n        RETURN NEW;\n    ELSIF TG_OP = 'DELETE' THEN\n        UPDATE profiles SET followers_count = followers_count - 1 WHERE id = OLD.following_id;\n        UPDATE profiles SET following_count = following_count - 1 WHERE id = OLD.follower_id;\n        RETURN OLD;\n    END IF;\n    RETURN NULL;\nEND;\n$$ language 'plpgsql';\n\n-- Create triggers\nCREATE TRIGGER posts_count_trigger\n    AFTER INSERT OR DELETE ON posts\n    FOR EACH ROW EXECUTE FUNCTION update_post_counts();\n\nCREATE TRIGGER likes_count_trigger\n    AFTER INSERT OR DELETE ON likes\n    FOR EACH ROW EXECUTE FUNCTION update_like_counts();\n\nCREATE TRIGGER comments_count_trigger\n    AFTER INSERT OR DELETE ON comments\n    FOR EACH ROW EXECUTE FUNCTION update_comment_counts();\n\nCREATE TRIGGER follow_counts_trigger\n    AFTER INSERT OR DELETE ON follows\n    FOR EACH ROW EXECUTE FUNCTION update_follow_counts();\n</code></pre>"},{"location":"setup/supabase-setup/#6-storage-setup","title":"6. Storage Setup","text":""},{"location":"setup/supabase-setup/#61-create-storage-buckets","title":"6.1 Create Storage Buckets","text":"<pre><code>-- Create storage buckets\nINSERT INTO storage.buckets (id, name, public) VALUES\n('avatars', 'avatars', true),\n('posts', 'posts', true),\n('stories', 'stories', true);\n</code></pre>"},{"location":"setup/supabase-setup/#62-storage-policies","title":"6.2 Storage Policies","text":"<pre><code>-- Avatar storage policies\nCREATE POLICY \"Avatar images are publicly accessible\" ON storage.objects\n  FOR SELECT USING (bucket_id = 'avatars');\n\nCREATE POLICY \"Users can upload their own avatar\" ON storage.objects\n  FOR INSERT WITH CHECK (\n    bucket_id = 'avatars' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can update their own avatar\" ON storage.objects\n  FOR UPDATE USING (\n    bucket_id = 'avatars' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can delete their own avatar\" ON storage.objects\n  FOR DELETE USING (\n    bucket_id = 'avatars' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\n-- Post images storage policies\nCREATE POLICY \"Post images are publicly accessible\" ON storage.objects\n  FOR SELECT USING (bucket_id = 'posts');\n\nCREATE POLICY \"Users can upload post images\" ON storage.objects\n  FOR INSERT WITH CHECK (\n    bucket_id = 'posts' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can delete their own post images\" ON storage.objects\n  FOR DELETE USING (\n    bucket_id = 'posts' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\n-- Story images storage policies\nCREATE POLICY \"Story images are publicly accessible\" ON storage.objects\n  FOR SELECT USING (bucket_id = 'stories');\n\nCREATE POLICY \"Users can upload story images\" ON storage.objects\n  FOR INSERT WITH CHECK (\n    bucket_id = 'stories' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can delete their own story images\" ON storage.objects\n  FOR DELETE USING (\n    bucket_id = 'stories' AND\n    auth.uid()::text = (storage.foldername(name))[1]\n  );\n</code></pre>"},{"location":"setup/supabase-setup/#7-authentication-setup","title":"7. Authentication Setup","text":""},{"location":"setup/supabase-setup/#71-configure-auth-settings","title":"7.1 Configure Auth Settings","text":"<ol> <li>Go to Authentication \u2192 Settings in your Supabase dashboard</li> <li>Configure the following:</li> </ol> <p>Site URL: <code>com.instagramapp.flutter://login-callback</code> (for mobile) Redirect URLs: - <code>com.instagramapp.flutter://login-callback</code> - <code>http://localhost:3000</code> (for web development)</p>"},{"location":"setup/supabase-setup/#72-enable-social-providers-optional","title":"7.2 Enable Social Providers (Optional)","text":"<p>Configure social authentication providers: - Google OAuth - Apple Sign In - GitHub OAuth</p>"},{"location":"setup/supabase-setup/#next-steps","title":"Next Steps","text":"<p>After completing this setup:</p> <ol> <li>\u2705 Test database connection from Flutter app</li> <li>\u2705 Implement authentication flow</li> <li>\u2705 Test file uploads to storage</li> <li>\u2705 Proceed to Supabase Usage</li> </ol> <p>Your Supabase backend is now ready for the Flutter Instagram clone app!</p>"},{"location":"setup/supabase-storage-setup/","title":"Supabase Storage Setup","text":"<p>Comprehensive guide to setting up and using Supabase Storage for file uploads, downloads, and management in Flutter applications.</p>"},{"location":"setup/supabase-storage-setup/#overview","title":"Overview","text":"<p>Supabase Storage provides a scalable file storage solution with built-in security, image transformations, and CDN delivery. This guide covers setup, configuration, and implementation patterns.</p>"},{"location":"setup/supabase-storage-setup/#storage-configuration","title":"Storage Configuration","text":""},{"location":"setup/supabase-storage-setup/#1-bucket-setup","title":"1. Bucket Setup","text":"<pre><code>-- Create storage buckets\nINSERT INTO storage.buckets (id, name, public) VALUES \n  ('avatars', 'avatars', true),\n  ('posts', 'posts', true),\n  ('private-files', 'private-files', false);\n\n-- Set up Row Level Security policies\nCREATE POLICY \"Avatar images are publicly accessible\" ON storage.objects\n  FOR SELECT USING (bucket_id = 'avatars');\n\nCREATE POLICY \"Users can upload their own avatar\" ON storage.objects\n  FOR INSERT WITH CHECK (\n    bucket_id = 'avatars' \n    AND auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can update their own avatar\" ON storage.objects\n  FOR UPDATE USING (\n    bucket_id = 'avatars' \n    AND auth.uid()::text = (storage.foldername(name))[1]\n  );\n\nCREATE POLICY \"Users can delete their own avatar\" ON storage.objects\n  FOR DELETE USING (\n    bucket_id = 'avatars' \n    AND auth.uid()::text = (storage.foldername(name))[1]\n  );\n\n-- Post images policies\nCREATE POLICY \"Post images are publicly accessible\" ON storage.objects\n  FOR SELECT USING (bucket_id = 'posts');\n\nCREATE POLICY \"Authenticated users can upload post images\" ON storage.objects\n  FOR INSERT WITH CHECK (\n    bucket_id = 'posts' \n    AND auth.role() = 'authenticated'\n  );\n\n-- Private files policies\nCREATE POLICY \"Users can access their own private files\" ON storage.objects\n  FOR ALL USING (\n    bucket_id = 'private-files' \n    AND auth.uid()::text = (storage.foldername(name))[1]\n  );\n</code></pre>"},{"location":"setup/supabase-storage-setup/#2-storage-service-implementation","title":"2. Storage Service Implementation","text":"<pre><code>// lib/services/storage_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:path/path.dart' as path;\n\nclass StorageService {\n  final SupabaseClient _supabase = Supabase.instance.client;\n\n  // Upload avatar image\n  Future&lt;String&gt; uploadAvatar(File imageFile, String userId) async {\n    try {\n      final fileExt = path.extension(imageFile.path);\n      final fileName = '$userId/avatar$fileExt';\n\n      await _supabase.storage\n          .from('avatars')\n          .upload(fileName, imageFile, fileOptions: const FileOptions(\n            cacheControl: '3600',\n            upsert: true,\n          ));\n\n      return _supabase.storage\n          .from('avatars')\n          .getPublicUrl(fileName);\n    } catch (error) {\n      throw StorageException('Failed to upload avatar: $error');\n    }\n  }\n\n  // Upload post image\n  Future&lt;String&gt; uploadPostImage(File imageFile) async {\n    try {\n      final fileExt = path.extension(imageFile.path);\n      final fileName = '${DateTime.now().millisecondsSinceEpoch}$fileExt';\n      final userId = _supabase.auth.currentUser?.id;\n\n      if (userId == null) throw Exception('User not authenticated');\n\n      final filePath = '$userId/$fileName';\n\n      await _supabase.storage\n          .from('posts')\n          .upload(filePath, imageFile, fileOptions: const FileOptions(\n            cacheControl: '3600',\n          ));\n\n      return _supabase.storage\n          .from('posts')\n          .getPublicUrl(filePath);\n    } catch (error) {\n      throw StorageException('Failed to upload post image: $error');\n    }\n  }\n\n  // Upload multiple images\n  Future&lt;List&lt;String&gt;&gt; uploadMultipleImages(List&lt;File&gt; imageFiles, String folder) async {\n    final uploadTasks = imageFiles.map((file) =&gt; uploadPostImage(file));\n    return await Future.wait(uploadTasks);\n  }\n\n  // Download file\n  Future&lt;Uint8List&gt; downloadFile(String bucket, String path) async {\n    try {\n      return await _supabase.storage\n          .from(bucket)\n          .download(path);\n    } catch (error) {\n      throw StorageException('Failed to download file: $error');\n    }\n  }\n\n  // Delete file\n  Future&lt;void&gt; deleteFile(String bucket, String path) async {\n    try {\n      await _supabase.storage\n          .from(bucket)\n          .remove([path]);\n    } catch (error) {\n      throw StorageException('Failed to delete file: $error');\n    }\n  }\n\n  // Get file URL with transformations\n  String getImageUrl(String bucket, String path, {\n    int? width,\n    int? height,\n    String? format,\n    int? quality,\n  }) {\n    var url = _supabase.storage.from(bucket).getPublicUrl(path);\n\n    final transformations = &lt;String&gt;[];\n\n    if (width != null) transformations.add('width=$width');\n    if (height != null) transformations.add('height=$height');\n    if (format != null) transformations.add('format=$format');\n    if (quality != null) transformations.add('quality=$quality');\n\n    if (transformations.isNotEmpty) {\n      url += '?${transformations.join('&amp;')}';\n    }\n\n    return url;\n  }\n\n  // List files in bucket\n  Future&lt;List&lt;FileObject&gt;&gt; listFiles(String bucket, {String? folder}) async {\n    try {\n      return await _supabase.storage\n          .from(bucket)\n          .list(path: folder);\n    } catch (error) {\n      throw StorageException('Failed to list files: $error');\n    }\n  }\n}\n\nclass StorageException implements Exception {\n  final String message;\n  StorageException(this.message);\n\n  @override\n  String toString() =&gt; 'StorageException: $message';\n}\n</code></pre>"},{"location":"setup/supabase-storage-setup/#image-upload-components","title":"Image Upload Components","text":""},{"location":"setup/supabase-storage-setup/#1-image-picker-widget","title":"1. Image Picker Widget","text":"<pre><code>// lib/widgets/image_picker_widget.dart\nclass ImagePickerWidget extends StatefulWidget {\n  final Function(File) onImageSelected;\n  final String? initialImageUrl;\n  final double size;\n  final bool isCircular;\n\n  const ImagePickerWidget({\n    Key? key,\n    required this.onImageSelected,\n    this.initialImageUrl,\n    this.size = 100,\n    this.isCircular = false,\n  }) : super(key: key);\n\n  @override\n  _ImagePickerWidgetState createState() =&gt; _ImagePickerWidgetState();\n}\n\nclass _ImagePickerWidgetState extends State&lt;ImagePickerWidget&gt; {\n  File? _selectedImage;\n  final ImagePicker _picker = ImagePicker();\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: _showImageSourceDialog,\n      child: Container(\n        width: widget.size,\n        height: widget.size,\n        decoration: BoxDecoration(\n          shape: widget.isCircular ? BoxShape.circle : BoxShape.rectangle,\n          borderRadius: widget.isCircular ? null : BorderRadius.circular(8),\n          border: Border.all(color: Colors.grey[300]!),\n          color: Colors.grey[100],\n        ),\n        child: _buildImageContent(),\n      ),\n    );\n  }\n\n  Widget _buildImageContent() {\n    if (_selectedImage != null) {\n      return ClipRRect(\n        borderRadius: widget.isCircular \n            ? BorderRadius.circular(widget.size / 2)\n            : BorderRadius.circular(8),\n        child: Image.file(\n          _selectedImage!,\n          width: widget.size,\n          height: widget.size,\n          fit: BoxFit.cover,\n        ),\n      );\n    }\n\n    if (widget.initialImageUrl != null) {\n      return ClipRRect(\n        borderRadius: widget.isCircular \n            ? BorderRadius.circular(widget.size / 2)\n            : BorderRadius.circular(8),\n        child: Image.network(\n          widget.initialImageUrl!,\n          width: widget.size,\n          height: widget.size,\n          fit: BoxFit.cover,\n          errorBuilder: (context, error, stackTrace) {\n            return _buildPlaceholder();\n          },\n        ),\n      );\n    }\n\n    return _buildPlaceholder();\n  }\n\n  Widget _buildPlaceholder() {\n    return Icon(\n      Icons.add_photo_alternate,\n      size: widget.size * 0.4,\n      color: Colors.grey[400],\n    );\n  }\n\n  void _showImageSourceDialog() {\n    showModalBottomSheet(\n      context: context,\n      builder: (context) =&gt; SafeArea(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            ListTile(\n              leading: const Icon(Icons.photo_camera),\n              title: const Text('Camera'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.camera);\n              },\n            ),\n            ListTile(\n              leading: const Icon(Icons.photo_library),\n              title: const Text('Gallery'),\n              onTap: () {\n                Navigator.pop(context);\n                _pickImage(ImageSource.gallery);\n              },\n            ),\n            if (_selectedImage != null || widget.initialImageUrl != null)\n              ListTile(\n                leading: const Icon(Icons.delete),\n                title: const Text('Remove'),\n                onTap: () {\n                  Navigator.pop(context);\n                  setState(() {\n                    _selectedImage = null;\n                  });\n                },\n              ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Future&lt;void&gt; _pickImage(ImageSource source) async {\n    try {\n      final XFile? image = await _picker.pickImage(\n        source: source,\n        maxWidth: 1024,\n        maxHeight: 1024,\n        imageQuality: 85,\n      );\n\n      if (image != null) {\n        final file = File(image.path);\n        setState(() {\n          _selectedImage = file;\n        });\n        widget.onImageSelected(file);\n      }\n    } catch (error) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Failed to pick image: $error')),\n      );\n    }\n  }\n}\n</code></pre>"},{"location":"setup/supabase-storage-setup/#2-multiple-image-picker","title":"2. Multiple Image Picker","text":"<pre><code>// lib/widgets/multiple_image_picker.dart\nclass MultipleImagePicker extends StatefulWidget {\n  final Function(List&lt;File&gt;) onImagesSelected;\n  final int maxImages;\n  final List&lt;String&gt;? initialImageUrls;\n\n  const MultipleImagePicker({\n    Key? key,\n    required this.onImagesSelected,\n    this.maxImages = 5,\n    this.initialImageUrls,\n  }) : super(key: key);\n\n  @override\n  _MultipleImagePickerState createState() =&gt; _MultipleImagePickerState();\n}\n\nclass _MultipleImagePickerState extends State&lt;MultipleImagePicker&gt; {\n  List&lt;File&gt; _selectedImages = [];\n  final ImagePicker _picker = ImagePicker();\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(\n          'Images (${_selectedImages.length}/${widget.maxImages})',\n          style: Theme.of(context).textTheme.titleMedium,\n        ),\n        const SizedBox(height: 8),\n        SizedBox(\n          height: 100,\n          child: ListView.builder(\n            scrollDirection: Axis.horizontal,\n            itemCount: _selectedImages.length + 1,\n            itemBuilder: (context, index) {\n              if (index == _selectedImages.length) {\n                return _buildAddButton();\n              }\n              return _buildImageItem(index);\n            },\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildAddButton() {\n    if (_selectedImages.length &gt;= widget.maxImages) {\n      return const SizedBox.shrink();\n    }\n\n    return GestureDetector(\n      onTap: _pickImages,\n      child: Container(\n        width: 100,\n        height: 100,\n        margin: const EdgeInsets.only(right: 8),\n        decoration: BoxDecoration(\n          border: Border.all(color: Colors.grey[300]!),\n          borderRadius: BorderRadius.circular(8),\n          color: Colors.grey[100],\n        ),\n        child: Icon(\n          Icons.add_photo_alternate,\n          size: 40,\n          color: Colors.grey[400],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildImageItem(int index) {\n    return Container(\n      width: 100,\n      height: 100,\n      margin: const EdgeInsets.only(right: 8),\n      child: Stack(\n        children: [\n          ClipRRect(\n            borderRadius: BorderRadius.circular(8),\n            child: Image.file(\n              _selectedImages[index],\n              width: 100,\n              height: 100,\n              fit: BoxFit.cover,\n            ),\n          ),\n          Positioned(\n            top: 4,\n            right: 4,\n            child: GestureDetector(\n              onTap: () =&gt; _removeImage(index),\n              child: Container(\n                padding: const EdgeInsets.all(4),\n                decoration: const BoxDecoration(\n                  color: Colors.red,\n                  shape: BoxShape.circle,\n                ),\n                child: const Icon(\n                  Icons.close,\n                  size: 16,\n                  color: Colors.white,\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Future&lt;void&gt; _pickImages() async {\n    try {\n      final List&lt;XFile&gt; images = await _picker.pickMultiImage(\n        maxWidth: 1024,\n        maxHeight: 1024,\n        imageQuality: 85,\n      );\n\n      final remainingSlots = widget.maxImages - _selectedImages.length;\n      final imagesToAdd = images.take(remainingSlots);\n\n      final newFiles = imagesToAdd.map((image) =&gt; File(image.path)).toList();\n\n      setState(() {\n        _selectedImages.addAll(newFiles);\n      });\n\n      widget.onImagesSelected(_selectedImages);\n    } catch (error) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Failed to pick images: $error')),\n      );\n    }\n  }\n\n  void _removeImage(int index) {\n    setState(() {\n      _selectedImages.removeAt(index);\n    });\n    widget.onImagesSelected(_selectedImages);\n  }\n}\n</code></pre>"},{"location":"setup/supabase-storage-setup/#upload-progress-and-management","title":"Upload Progress and Management","text":""},{"location":"setup/supabase-storage-setup/#1-upload-progress-widget","title":"1. Upload Progress Widget","text":"<pre><code>// lib/widgets/upload_progress_widget.dart\nclass UploadProgressWidget extends StatefulWidget {\n  final File file;\n  final String bucket;\n  final Function(String) onUploadComplete;\n  final Function(String) onUploadError;\n\n  const UploadProgressWidget({\n    Key? key,\n    required this.file,\n    required this.bucket,\n    required this.onUploadComplete,\n    required this.onUploadError,\n  }) : super(key: key);\n\n  @override\n  _UploadProgressWidgetState createState() =&gt; _UploadProgressWidgetState();\n}\n\nclass _UploadProgressWidgetState extends State&lt;UploadProgressWidget&gt; {\n  double _progress = 0.0;\n  bool _isUploading = false;\n  String? _error;\n\n  @override\n  void initState() {\n    super.initState();\n    _startUpload();\n  }\n\n  Future&lt;void&gt; _startUpload() async {\n    setState(() {\n      _isUploading = true;\n      _error = null;\n    });\n\n    try {\n      final storageService = GetIt.instance&lt;StorageService&gt;();\n\n      // Simulate progress updates\n      for (int i = 0; i &lt;= 100; i += 10) {\n        await Future.delayed(const Duration(milliseconds: 100));\n        if (mounted) {\n          setState(() {\n            _progress = i / 100;\n          });\n        }\n      }\n\n      final url = await storageService.uploadPostImage(widget.file);\n\n      setState(() {\n        _isUploading = false;\n        _progress = 1.0;\n      });\n\n      widget.onUploadComplete(url);\n    } catch (error) {\n      setState(() {\n        _isUploading = false;\n        _error = error.toString();\n      });\n\n      widget.onUploadError(error.toString());\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.all(16),\n      decoration: BoxDecoration(\n        border: Border.all(color: Colors.grey[300]!),\n        borderRadius: BorderRadius.circular(8),\n      ),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Row(\n            children: [\n              ClipRRect(\n                borderRadius: BorderRadius.circular(4),\n                child: Image.file(\n                  widget.file,\n                  width: 50,\n                  height: 50,\n                  fit: BoxFit.cover,\n                ),\n              ),\n              const SizedBox(width: 12),\n              Expanded(\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    Text(\n                      path.basename(widget.file.path),\n                      style: const TextStyle(fontWeight: FontWeight.medium),\n                    ),\n                    const SizedBox(height: 4),\n                    if (_error != null)\n                      Text(\n                        _error!,\n                        style: const TextStyle(color: Colors.red, fontSize: 12),\n                      )\n                    else if (_isUploading)\n                      Text(\n                        'Uploading... ${(_progress * 100).toInt()}%',\n                        style: const TextStyle(fontSize: 12),\n                      )\n                    else\n                      const Text(\n                        'Upload complete',\n                        style: TextStyle(color: Colors.green, fontSize: 12),\n                      ),\n                  ],\n                ),\n              ),\n            ],\n          ),\n          if (_isUploading) ...[\n            const SizedBox(height: 8),\n            LinearProgressIndicator(value: _progress),\n          ],\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"setup/supabase-storage-setup/#2-upload-manager-service","title":"2. Upload Manager Service","text":"<pre><code>// lib/services/upload_manager.dart\nclass UploadManager {\n  final Map&lt;String, UploadTask&gt; _activeTasks = {};\n  final StreamController&lt;Map&lt;String, UploadTask&gt;&gt; _controller = \n      StreamController&lt;Map&lt;String, UploadTask&gt;&gt;.broadcast();\n\n  Stream&lt;Map&lt;String, UploadTask&gt;&gt; get tasksStream =&gt; _controller.stream;\n\n  String startUpload(File file, String bucket, {String? folder}) {\n    final taskId = DateTime.now().millisecondsSinceEpoch.toString();\n    final task = UploadTask(\n      id: taskId,\n      file: file,\n      bucket: bucket,\n      folder: folder,\n    );\n\n    _activeTasks[taskId] = task;\n    _controller.add(Map.from(_activeTasks));\n\n    _performUpload(task);\n\n    return taskId;\n  }\n\n  Future&lt;void&gt; _performUpload(UploadTask task) async {\n    try {\n      task.status = UploadStatus.uploading;\n      _controller.add(Map.from(_activeTasks));\n\n      final storageService = GetIt.instance&lt;StorageService&gt;();\n      final url = await storageService.uploadPostImage(task.file);\n\n      task.status = UploadStatus.completed;\n      task.url = url;\n      task.progress = 1.0;\n\n    } catch (error) {\n      task.status = UploadStatus.failed;\n      task.error = error.toString();\n    }\n\n    _controller.add(Map.from(_activeTasks));\n\n    // Remove completed/failed tasks after delay\n    Timer(const Duration(seconds: 3), () {\n      _activeTasks.remove(task.id);\n      _controller.add(Map.from(_activeTasks));\n    });\n  }\n\n  void cancelUpload(String taskId) {\n    final task = _activeTasks[taskId];\n    if (task != null) {\n      task.status = UploadStatus.cancelled;\n      _activeTasks.remove(taskId);\n      _controller.add(Map.from(_activeTasks));\n    }\n  }\n\n  void dispose() {\n    _controller.close();\n  }\n}\n\nclass UploadTask {\n  final String id;\n  final File file;\n  final String bucket;\n  final String? folder;\n\n  UploadStatus status = UploadStatus.pending;\n  double progress = 0.0;\n  String? url;\n  String? error;\n\n  UploadTask({\n    required this.id,\n    required this.file,\n    required this.bucket,\n    this.folder,\n  });\n}\n\nenum UploadStatus {\n  pending,\n  uploading,\n  completed,\n  failed,\n  cancelled,\n}\n</code></pre>"},{"location":"setup/supabase-storage-setup/#image-optimization","title":"Image Optimization","text":""},{"location":"setup/supabase-storage-setup/#1-image-compression","title":"1. Image Compression","text":"<pre><code>// lib/utils/image_utils.dart\nimport 'package:flutter_image_compress/flutter_image_compress.dart';\n\nclass ImageUtils {\n  static Future&lt;File?&gt; compressImage(File file, {\n    int quality = 85,\n    int maxWidth = 1024,\n    int maxHeight = 1024,\n  }) async {\n    try {\n      final compressedFile = await FlutterImageCompress.compressAndGetFile(\n        file.absolute.path,\n        '${file.path}_compressed.jpg',\n        quality: quality,\n        minWidth: maxWidth,\n        minHeight: maxHeight,\n        format: CompressFormat.jpeg,\n      );\n\n      return compressedFile != null ? File(compressedFile.path) : null;\n    } catch (error) {\n      print('Image compression failed: $error');\n      return file; // Return original if compression fails\n    }\n  }\n\n  static Future&lt;Uint8List?&gt; resizeImage(Uint8List imageBytes, {\n    int? width,\n    int? height,\n  }) async {\n    try {\n      return await FlutterImageCompress.compressWithList(\n        imageBytes,\n        minWidth: width ?? 300,\n        minHeight: height ?? 300,\n        quality: 85,\n      );\n    } catch (error) {\n      print('Image resize failed: $error');\n      return imageBytes;\n    }\n  }\n}\n</code></pre> <p>Supabase Storage provides a robust file management solution. Implement proper security policies, optimize images before upload, and provide clear feedback during upload processes.</p>"},{"location":"setup/supabase-usage/","title":"Supabase Usage in Flutter","text":"<p>Comprehensive guide to using Supabase in Flutter applications, covering authentication, database operations, storage, and real-time features.</p>"},{"location":"setup/supabase-usage/#authentication","title":"Authentication","text":""},{"location":"setup/supabase-usage/#1-authentication-service","title":"1. Authentication Service","text":"<pre><code>// lib/core/services/auth_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass AuthService {\n  final SupabaseClient _client = Supabase.instance.client;\n\n  // Get current user\n  User? get currentUser =&gt; _client.auth.currentUser;\n\n  // Get auth state stream\n  Stream&lt;AuthState&gt; get authStateChanges =&gt; _client.auth.onAuthStateChange;\n\n  // Sign up with email and password\n  Future&lt;AuthResponse&gt; signUp({\n    required String email,\n    required String password,\n    required String username,\n    required String fullName,\n  }) async {\n    final response = await _client.auth.signUp(\n      email: email,\n      password: password,\n      data: {\n        'username': username,\n        'full_name': fullName,\n      },\n    );\n\n    if (response.user != null) {\n      // Create profile after successful signup\n      await _createProfile(\n        userId: response.user!.id,\n        username: username,\n        fullName: fullName,\n      );\n    }\n\n    return response;\n  }\n\n  // Sign in with email and password\n  Future&lt;AuthResponse&gt; signIn({\n    required String email,\n    required String password,\n  }) async {\n    return await _client.auth.signInWithPassword(\n      email: email,\n      password: password,\n    );\n  }\n\n  // Sign in with Google\n  Future&lt;bool&gt; signInWithGoogle() async {\n    try {\n      await _client.auth.signInWithOAuth(\n        OAuthProvider.google,\n        redirectTo: 'com.instagramapp.flutter://login-callback',\n      );\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Sign out\n  Future&lt;void&gt; signOut() async {\n    await _client.auth.signOut();\n  }\n\n  // Reset password\n  Future&lt;void&gt; resetPassword(String email) async {\n    await _client.auth.resetPasswordForEmail(email);\n  }\n\n  // Create user profile\n  Future&lt;void&gt; _createProfile({\n    required String userId,\n    required String username,\n    required String fullName,\n  }) async {\n    await _client.from('profiles').insert({\n      'id': userId,\n      'username': username,\n      'full_name': fullName,\n    });\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#2-authentication-provider-riverpod","title":"2. Authentication Provider (Riverpod)","text":"<pre><code>// lib/features/auth/providers/auth_provider.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nfinal authServiceProvider = Provider&lt;AuthService&gt;((ref) =&gt; AuthService());\n\nfinal authStateProvider = StreamProvider&lt;AuthState&gt;((ref) {\n  final authService = ref.read(authServiceProvider);\n  return authService.authStateChanges;\n});\n\nfinal currentUserProvider = Provider&lt;User?&gt;((ref) {\n  final authState = ref.watch(authStateProvider);\n  return authState.when(\n    data: (state) =&gt; state.session?.user,\n    loading: () =&gt; null,\n    error: (_, __) =&gt; null,\n  );\n});\n\n// Auth state notifier for complex auth operations\nclass AuthNotifier extends StateNotifier&lt;AsyncValue&lt;User?&gt;&gt; {\n  final AuthService _authService;\n\n  AuthNotifier(this._authService) : super(const AsyncValue.loading()) {\n    _init();\n  }\n\n  void _init() {\n    state = AsyncValue.data(_authService.currentUser);\n  }\n\n  Future&lt;void&gt; signUp({\n    required String email,\n    required String password,\n    required String username,\n    required String fullName,\n  }) async {\n    state = const AsyncValue.loading();\n\n    try {\n      final response = await _authService.signUp(\n        email: email,\n        password: password,\n        username: username,\n        fullName: fullName,\n      );\n\n      if (response.user != null) {\n        state = AsyncValue.data(response.user);\n      } else {\n        state = AsyncValue.error('Sign up failed', StackTrace.current);\n      }\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n\n  Future&lt;void&gt; signIn({\n    required String email,\n    required String password,\n  }) async {\n    state = const AsyncValue.loading();\n\n    try {\n      final response = await _authService.signIn(\n        email: email,\n        password: password,\n      );\n\n      if (response.user != null) {\n        state = AsyncValue.data(response.user);\n      } else {\n        state = AsyncValue.error('Sign in failed', StackTrace.current);\n      }\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n\n  Future&lt;void&gt; signOut() async {\n    try {\n      await _authService.signOut();\n      state = const AsyncValue.data(null);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n}\n\nfinal authNotifierProvider = StateNotifierProvider&lt;AuthNotifier, AsyncValue&lt;User?&gt;&gt;((ref) {\n  final authService = ref.read(authServiceProvider);\n  return AuthNotifier(authService);\n});\n</code></pre>"},{"location":"setup/supabase-usage/#database-operations","title":"Database Operations","text":""},{"location":"setup/supabase-usage/#1-post-service","title":"1. Post Service","text":"<pre><code>// lib/features/feed/services/post_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass PostService {\n  final SupabaseClient _client = Supabase.instance.client;\n\n  // Get feed posts\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getFeedPosts({\n    int limit = 20,\n    int offset = 0,\n  }) async {\n    final response = await _client\n        .from('posts')\n        .select('''\n          *,\n          profiles:user_id (\n            username,\n            avatar_url,\n            full_name\n          ),\n          likes (\n            user_id\n          ),\n          comments (\n            id,\n            content,\n            created_at,\n            profiles:user_id (\n              username,\n              avatar_url\n            )\n          )\n        ''')\n        .order('created_at', ascending: false)\n        .range(offset, offset + limit - 1);\n\n    return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n  }\n\n  // Create a new post\n  Future&lt;Map&lt;String, dynamic&gt;&gt; createPost({\n    required String imageUrl,\n    required String caption,\n    String? location,\n  }) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    final response = await _client\n        .from('posts')\n        .insert({\n          'user_id': userId,\n          'image_url': imageUrl,\n          'caption': caption,\n          'location': location,\n        })\n        .select()\n        .single();\n\n    return response;\n  }\n\n  // Like a post\n  Future&lt;void&gt; likePost(String postId) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    await _client.from('likes').insert({\n      'user_id': userId,\n      'post_id': postId,\n    });\n  }\n\n  // Unlike a post\n  Future&lt;void&gt; unlikePost(String postId) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    await _client\n        .from('likes')\n        .delete()\n        .eq('user_id', userId)\n        .eq('post_id', postId);\n  }\n\n  // Add comment to post\n  Future&lt;Map&lt;String, dynamic&gt;&gt; addComment({\n    required String postId,\n    required String content,\n  }) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    final response = await _client\n        .from('comments')\n        .insert({\n          'user_id': userId,\n          'post_id': postId,\n          'content': content,\n        })\n        .select('''\n          *,\n          profiles:user_id (\n            username,\n            avatar_url\n          )\n        ''')\n        .single();\n\n    return response;\n  }\n\n  // Delete post\n  Future&lt;void&gt; deletePost(String postId) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    await _client\n        .from('posts')\n        .delete()\n        .eq('id', postId)\n        .eq('user_id', userId);\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#2-user-service","title":"2. User Service","text":"<pre><code>// lib/features/profile/services/user_service.dart\nclass UserService {\n  final SupabaseClient _client = Supabase.instance.client;\n\n  // Get user profile\n  Future&lt;Map&lt;String, dynamic&gt;?&gt; getUserProfile(String userId) async {\n    final response = await _client\n        .from('profiles')\n        .select()\n        .eq('id', userId)\n        .maybeSingle();\n\n    return response;\n  }\n\n  // Update user profile\n  Future&lt;Map&lt;String, dynamic&gt;&gt; updateProfile({\n    required String userId,\n    String? username,\n    String? fullName,\n    String? bio,\n    String? website,\n    String? avatarUrl,\n  }) async {\n    final updates = &lt;String, dynamic&gt;{};\n\n    if (username != null) updates['username'] = username;\n    if (fullName != null) updates['full_name'] = fullName;\n    if (bio != null) updates['bio'] = bio;\n    if (website != null) updates['website'] = website;\n    if (avatarUrl != null) updates['avatar_url'] = avatarUrl;\n\n    updates['updated_at'] = DateTime.now().toIso8601String();\n\n    final response = await _client\n        .from('profiles')\n        .update(updates)\n        .eq('id', userId)\n        .select()\n        .single();\n\n    return response;\n  }\n\n  // Follow user\n  Future&lt;void&gt; followUser(String userId) async {\n    final currentUserId = _client.auth.currentUser?.id;\n    if (currentUserId == null) throw Exception('User not authenticated');\n\n    await _client.from('follows').insert({\n      'follower_id': currentUserId,\n      'following_id': userId,\n    });\n  }\n\n  // Unfollow user\n  Future&lt;void&gt; unfollowUser(String userId) async {\n    final currentUserId = _client.auth.currentUser?.id;\n    if (currentUserId == null) throw Exception('User not authenticated');\n\n    await _client\n        .from('follows')\n        .delete()\n        .eq('follower_id', currentUserId)\n        .eq('following_id', userId);\n  }\n\n  // Check if following user\n  Future&lt;bool&gt; isFollowing(String userId) async {\n    final currentUserId = _client.auth.currentUser?.id;\n    if (currentUserId == null) return false;\n\n    final response = await _client\n        .from('follows')\n        .select()\n        .eq('follower_id', currentUserId)\n        .eq('following_id', userId)\n        .maybeSingle();\n\n    return response != null;\n  }\n\n  // Get user's followers\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getFollowers(String userId) async {\n    final response = await _client\n        .from('follows')\n        .select('''\n          profiles:follower_id (\n            id,\n            username,\n            full_name,\n            avatar_url\n          )\n        ''')\n        .eq('following_id', userId);\n\n    return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n  }\n\n  // Get user's following\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getFollowing(String userId) async {\n    final response = await _client\n        .from('follows')\n        .select('''\n          profiles:following_id (\n            id,\n            username,\n            full_name,\n            avatar_url\n          )\n        ''')\n        .eq('follower_id', userId);\n\n    return List&lt;Map&lt;String, dynamic&gt;&gt;.from(response);\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#storage-operations","title":"Storage Operations","text":""},{"location":"setup/supabase-usage/#1-storage-service","title":"1. Storage Service","text":"<pre><code>// lib/core/services/storage_service.dart\nimport 'dart:io';\nimport 'package:supabase_flutter/supabase_flutter.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:path/path.dart' as path;\n\nclass StorageService {\n  final SupabaseClient _client = Supabase.instance.client;\n\n  // Upload avatar image\n  Future&lt;String&gt; uploadAvatar(XFile imageFile) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    final bytes = await imageFile.readAsBytes();\n    final fileExt = path.extension(imageFile.name);\n    final fileName = '$userId/avatar$fileExt';\n\n    await _client.storage.from('avatars').uploadBinary(\n      fileName,\n      bytes,\n      fileOptions: const FileOptions(\n        cacheControl: '3600',\n        upsert: true,\n      ),\n    );\n\n    return _client.storage.from('avatars').getPublicUrl(fileName);\n  }\n\n  // Upload post image\n  Future&lt;String&gt; uploadPostImage(XFile imageFile) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    final bytes = await imageFile.readAsBytes();\n    final fileExt = path.extension(imageFile.name);\n    final fileName = '$userId/${DateTime.now().millisecondsSinceEpoch}$fileExt';\n\n    await _client.storage.from('posts').uploadBinary(\n      fileName,\n      bytes,\n      fileOptions: const FileOptions(\n        cacheControl: '3600',\n        upsert: false,\n      ),\n    );\n\n    return _client.storage.from('posts').getPublicUrl(fileName);\n  }\n\n  // Upload story image\n  Future&lt;String&gt; uploadStoryImage(XFile imageFile) async {\n    final userId = _client.auth.currentUser?.id;\n    if (userId == null) throw Exception('User not authenticated');\n\n    final bytes = await imageFile.readAsBytes();\n    final fileExt = path.extension(imageFile.name);\n    final fileName = '$userId/story_${DateTime.now().millisecondsSinceEpoch}$fileExt';\n\n    await _client.storage.from('stories').uploadBinary(\n      fileName,\n      bytes,\n      fileOptions: const FileOptions(\n        cacheControl: '3600',\n        upsert: false,\n      ),\n    );\n\n    return _client.storage.from('stories').getPublicUrl(fileName);\n  }\n\n  // Delete file from storage\n  Future&lt;void&gt; deleteFile(String bucket, String fileName) async {\n    await _client.storage.from(bucket).remove([fileName]);\n  }\n\n  // Get file URL\n  String getPublicUrl(String bucket, String fileName) {\n    return _client.storage.from(bucket).getPublicUrl(fileName);\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#real-time-features","title":"Real-time Features","text":""},{"location":"setup/supabase-usage/#1-real-time-service","title":"1. Real-time Service","text":"<pre><code>// lib/core/services/realtime_service.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass RealtimeService {\n  final SupabaseClient _client = Supabase.instance.client;\n  RealtimeChannel? _channel;\n\n  // Subscribe to post changes\n  void subscribeToPostChanges({\n    required Function(Map&lt;String, dynamic&gt;) onInsert,\n    required Function(Map&lt;String, dynamic&gt;) onUpdate,\n    required Function(Map&lt;String, dynamic&gt;) onDelete,\n  }) {\n    _channel = _client\n        .channel('posts_changes')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onInsert(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.update,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onUpdate(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.delete,\n          schema: 'public',\n          table: 'posts',\n          callback: (payload) =&gt; onDelete(payload.oldRecord),\n        )\n        .subscribe();\n  }\n\n  // Subscribe to likes changes for a specific post\n  void subscribeToLikesChanges({\n    required String postId,\n    required Function(Map&lt;String, dynamic&gt;) onLike,\n    required Function(Map&lt;String, dynamic&gt;) onUnlike,\n  }) {\n    _channel = _client\n        .channel('likes_changes_$postId')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'likes',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onLike(payload.newRecord),\n        )\n        .onPostgresChanges(\n          event: PostgresChangeEvent.delete,\n          schema: 'public',\n          table: 'likes',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onUnlike(payload.oldRecord),\n        )\n        .subscribe();\n  }\n\n  // Subscribe to comments changes for a specific post\n  void subscribeToCommentsChanges({\n    required String postId,\n    required Function(Map&lt;String, dynamic&gt;) onNewComment,\n  }) {\n    _channel = _client\n        .channel('comments_changes_$postId')\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'comments',\n          filter: PostgresChangeFilter(\n            type: PostgresChangeFilterType.eq,\n            column: 'post_id',\n            value: postId,\n          ),\n          callback: (payload) =&gt; onNewComment(payload.newRecord),\n        )\n        .subscribe();\n  }\n\n  // Unsubscribe from changes\n  void unsubscribe() {\n    _channel?.unsubscribe();\n    _channel = null;\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#error-handling","title":"Error Handling","text":""},{"location":"setup/supabase-usage/#1-supabase-error-handler","title":"1. Supabase Error Handler","text":"<pre><code>// lib/core/utils/supabase_error_handler.dart\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass SupabaseErrorHandler {\n  static String getErrorMessage(Object error) {\n    if (error is PostgrestException) {\n      switch (error.code) {\n        case '23505':\n          return 'This item already exists';\n        case '23503':\n          return 'Referenced item does not exist';\n        case '42501':\n          return 'Permission denied';\n        default:\n          return error.message;\n      }\n    } else if (error is AuthException) {\n      switch (error.message) {\n        case 'Invalid login credentials':\n          return 'Invalid email or password';\n        case 'Email not confirmed':\n          return 'Please check your email and confirm your account';\n        case 'User already registered':\n          return 'An account with this email already exists';\n        default:\n          return error.message;\n      }\n    } else if (error is StorageException) {\n      switch (error.statusCode) {\n        case '413':\n          return 'File too large';\n        case '415':\n          return 'Unsupported file type';\n        default:\n          return error.message;\n      }\n    }\n\n    return 'An unexpected error occurred';\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#best-practices","title":"Best Practices","text":""},{"location":"setup/supabase-usage/#1-connection-management","title":"1. Connection Management","text":"<pre><code>// Check connection before operations\nFuture&lt;bool&gt; isConnected() async {\n  try {\n    await Supabase.instance.client.from('profiles').select('id').limit(1);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#2-offline-support","title":"2. Offline Support","text":"<pre><code>// Cache data locally for offline support\nclass CacheService {\n  static const String _postsKey = 'cached_posts';\n\n  static Future&lt;void&gt; cachePosts(List&lt;Map&lt;String, dynamic&gt;&gt; posts) async {\n    final prefs = await SharedPreferences.getInstance();\n    final jsonString = jsonEncode(posts);\n    await prefs.setString(_postsKey, jsonString);\n  }\n\n  static Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getCachedPosts() async {\n    final prefs = await SharedPreferences.getInstance();\n    final jsonString = prefs.getString(_postsKey);\n    if (jsonString != null) {\n      final List&lt;dynamic&gt; jsonList = jsonDecode(jsonString);\n      return jsonList.cast&lt;Map&lt;String, dynamic&gt;&gt;();\n    }\n    return [];\n  }\n}\n</code></pre>"},{"location":"setup/supabase-usage/#3-performance-optimization","title":"3. Performance Optimization","text":"<pre><code>// Use pagination for large datasets\nFuture&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getPaginatedPosts({\n  int page = 0,\n  int pageSize = 20,\n}) async {\n  final offset = page * pageSize;\n\n  return await _client\n      .from('posts')\n      .select()\n      .range(offset, offset + pageSize - 1)\n      .order('created_at', ascending: false);\n}\n\n// Use select to limit returned fields\nFuture&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getPostsMinimal() async {\n  return await _client\n      .from('posts')\n      .select('id, image_url, likes_count, comments_count')\n      .order('created_at', ascending: false);\n}\n</code></pre>"},{"location":"setup/supabase-usage/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Implement authentication flow in your Flutter app</li> <li>\u2705 Set up database operations for your features</li> <li>\u2705 Configure storage for image uploads</li> <li>\u2705 Add real-time features for better UX</li> <li>\u2705 Proceed to UI/UX Documentation</li> </ol> <p>Your Supabase integration is now ready for production use!</p>"},{"location":"testing/testing-guide/","title":"Flutter Testing Guide","text":"<p>Comprehensive testing strategy for Flutter applications covering unit tests, widget tests, integration tests, and testing best practices.</p>"},{"location":"testing/testing-guide/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>    /\\\n   /  \\    E2E Tests (Few)\n  /____\\\n /      \\   Integration Tests (Some)\n/________\\\n\\        /  Widget Tests (Many)\n \\______/\n  \\    /    Unit Tests (Most)\n   \\__/\n</code></pre>"},{"location":"testing/testing-guide/#1-unit-tests","title":"1. Unit Tests","text":"<p>Test individual functions, methods, and classes in isolation.</p>"},{"location":"testing/testing-guide/#example-testing-a-service","title":"Example: Testing a Service","text":"<pre><code>// test/services/auth_service_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:mockito/annotations.dart';\n\nimport 'package:flutter_instagram_app/core/services/auth_service.dart';\n\n@GenerateMocks([SupabaseClient])\nimport 'auth_service_test.mocks.dart';\n\nvoid main() {\n  group('AuthService', () {\n    late AuthService authService;\n    late MockSupabaseClient mockClient;\n\n    setUp(() {\n      mockClient = MockSupabaseClient();\n      authService = AuthService(client: mockClient);\n    });\n\n    test('should sign in user successfully', () async {\n      // Arrange\n      const email = 'test@example.com';\n      const password = 'password123';\n      final mockResponse = AuthResponse(\n        user: User(id: '123', email: email),\n        session: Session(accessToken: 'token'),\n      );\n\n      when(mockClient.auth.signInWithPassword(\n        email: email,\n        password: password,\n      )).thenAnswer((_) async =&gt; mockResponse);\n\n      // Act\n      final result = await authService.signIn(\n        email: email,\n        password: password,\n      );\n\n      // Assert\n      expect(result.user?.email, equals(email));\n      verify(mockClient.auth.signInWithPassword(\n        email: email,\n        password: password,\n      )).called(1);\n    });\n\n    test('should throw exception on sign in failure', () async {\n      // Arrange\n      when(mockClient.auth.signInWithPassword(\n        email: anyNamed('email'),\n        password: anyNamed('password'),\n      )).thenThrow(AuthException('Invalid credentials'));\n\n      // Act &amp; Assert\n      expect(\n        () =&gt; authService.signIn(\n          email: 'test@example.com',\n          password: 'wrong_password',\n        ),\n        throwsA(isA&lt;AuthException&gt;()),\n      );\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#testing-providers-riverpod","title":"Testing Providers (Riverpod)","text":"<pre><code>// test/providers/auth_provider_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  group('AuthProvider', () {\n    test('should start with loading state', () {\n      final container = ProviderContainer();\n      addTearDown(container.dispose);\n\n      final authState = container.read(authNotifierProvider);\n      expect(authState, isA&lt;AsyncLoading&gt;());\n    });\n\n    test('should update state on successful sign in', () async {\n      final container = ProviderContainer(\n        overrides: [\n          authServiceProvider.overrideWithValue(MockAuthService()),\n        ],\n      );\n      addTearDown(container.dispose);\n\n      final notifier = container.read(authNotifierProvider.notifier);\n\n      await notifier.signIn(\n        email: 'test@example.com',\n        password: 'password123',\n      );\n\n      final state = container.read(authNotifierProvider);\n      expect(state, isA&lt;AsyncData&gt;());\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#2-widget-tests","title":"2. Widget Tests","text":"<p>Test individual widgets and their interactions.</p>"},{"location":"testing/testing-guide/#example-testing-a-custom-widget","title":"Example: Testing a Custom Widget","text":"<pre><code>// test/widgets/app_button_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nimport 'package:flutter_instagram_app/shared/widgets/buttons/app_button.dart';\n\nvoid main() {\n  group('AppButton', () {\n    testWidgets('should display text correctly', (tester) async {\n      const buttonText = 'Test Button';\n\n      await tester.pumpWidget(\n        const MaterialApp(\n          home: Scaffold(\n            body: AppButton(text: buttonText),\n          ),\n        ),\n      );\n\n      expect(find.text(buttonText), findsOneWidget);\n    });\n\n    testWidgets('should call onPressed when tapped', (tester) async {\n      bool wasPressed = false;\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: Scaffold(\n            body: AppButton(\n              text: 'Test Button',\n              onPressed: () =&gt; wasPressed = true,\n            ),\n          ),\n        ),\n      );\n\n      await tester.tap(find.byType(AppButton));\n      expect(wasPressed, isTrue);\n    });\n\n    testWidgets('should show loading indicator when isLoading is true', (tester) async {\n      await tester.pumpWidget(\n        const MaterialApp(\n          home: Scaffold(\n            body: AppButton(\n              text: 'Test Button',\n              isLoading: true,\n            ),\n          ),\n        ),\n      );\n\n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n      expect(find.text('Test Button'), findsNothing);\n    });\n\n    testWidgets('should be disabled when onPressed is null', (tester) async {\n      await tester.pumpWidget(\n        const MaterialApp(\n          home: Scaffold(\n            body: AppButton(\n              text: 'Test Button',\n              onPressed: null,\n            ),\n          ),\n        ),\n      );\n\n      final button = tester.widget&lt;ElevatedButton&gt;(find.byType(ElevatedButton));\n      expect(button.onPressed, isNull);\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#testing-with-providers","title":"Testing with Providers","text":"<pre><code>// test/screens/home_screen_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  group('HomeScreen', () {\n    testWidgets('should display posts when loaded', (tester) async {\n      final mockPosts = [\n        Post(id: '1', caption: 'Test post 1'),\n        Post(id: '2', caption: 'Test post 2'),\n      ];\n\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            postsProvider.overrideWith((ref) =&gt; AsyncData(mockPosts)),\n          ],\n          child: const MaterialApp(\n            home: HomeScreen(),\n          ),\n        ),\n      );\n\n      expect(find.text('Test post 1'), findsOneWidget);\n      expect(find.text('Test post 2'), findsOneWidget);\n    });\n\n    testWidgets('should display loading indicator when loading', (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            postsProvider.overrideWith((ref) =&gt; const AsyncLoading()),\n          ],\n          child: const MaterialApp(\n            home: HomeScreen(),\n          ),\n        ),\n      );\n\n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#3-integration-tests","title":"3. Integration Tests","text":"<p>Test complete user flows and app behavior.</p>"},{"location":"testing/testing-guide/#example-authentication-flow","title":"Example: Authentication Flow","text":"<pre><code>// integration_test/auth_flow_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\n\nimport 'package:flutter_instagram_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('Authentication Flow', () {\n    testWidgets('should complete sign up flow', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to sign up\n      await tester.tap(find.text('Sign Up'));\n      await tester.pumpAndSettle();\n\n      // Fill form\n      await tester.enterText(find.byKey(const Key('email_field')), 'test@example.com');\n      await tester.enterText(find.byKey(const Key('password_field')), 'password123');\n      await tester.enterText(find.byKey(const Key('username_field')), 'testuser');\n\n      // Submit form\n      await tester.tap(find.text('Create Account'));\n      await tester.pumpAndSettle();\n\n      // Verify success\n      expect(find.text('Welcome'), findsOneWidget);\n    });\n\n    testWidgets('should complete sign in flow', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to sign in\n      await tester.tap(find.text('Sign In'));\n      await tester.pumpAndSettle();\n\n      // Fill credentials\n      await tester.enterText(find.byKey(const Key('email_field')), 'test@example.com');\n      await tester.enterText(find.byKey(const Key('password_field')), 'password123');\n\n      // Submit\n      await tester.tap(find.text('Sign In'));\n      await tester.pumpAndSettle();\n\n      // Verify home screen\n      expect(find.byKey(const Key('home_screen')), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#4-golden-tests","title":"4. Golden Tests","text":"<p>Test visual appearance of widgets.</p> <pre><code>// test/golden/button_golden_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('AppButton Golden Tests', () {\n    testWidgets('primary button golden test', (tester) async {\n      await tester.pumpWidget(\n        MaterialApp(\n          home: Scaffold(\n            body: Center(\n              child: AppButton(\n                text: 'Primary Button',\n                type: AppButtonType.primary,\n                onPressed: () {},\n              ),\n            ),\n          ),\n        ),\n      );\n\n      await expectLater(\n        find.byType(AppButton),\n        matchesGoldenFile('golden/primary_button.png'),\n      );\n    });\n\n    testWidgets('loading button golden test', (tester) async {\n      await tester.pumpWidget(\n        const MaterialApp(\n          home: Scaffold(\n            body: Center(\n              child: AppButton(\n                text: 'Loading Button',\n                isLoading: true,\n              ),\n            ),\n          ),\n        ),\n      );\n\n      await expectLater(\n        find.byType(AppButton),\n        matchesGoldenFile('golden/loading_button.png'),\n      );\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#5-performance-tests","title":"5. Performance Tests","text":"<p>Test app performance and memory usage.</p> <pre><code>// test/performance/scroll_performance_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('Performance Tests', () {\n    testWidgets('should scroll smoothly through large list', (tester) async {\n      final items = List.generate(1000, (index) =&gt; 'Item $index');\n\n      await tester.pumpWidget(\n        MaterialApp(\n          home: Scaffold(\n            body: ListView.builder(\n              itemCount: items.length,\n              itemBuilder: (context, index) =&gt; ListTile(\n                title: Text(items[index]),\n              ),\n            ),\n          ),\n        ),\n      );\n\n      // Measure scroll performance\n      await tester.timedDrag(\n        find.byType(ListView),\n        const Offset(0, -500),\n        const Duration(milliseconds: 300),\n      );\n\n      await tester.pumpAndSettle();\n\n      // Verify no frame drops\n      expect(tester.binding.hasScheduledFrame, isFalse);\n    });\n  });\n}\n</code></pre>"},{"location":"testing/testing-guide/#test-utilities","title":"Test Utilities","text":""},{"location":"testing/testing-guide/#custom-matchers","title":"Custom Matchers","text":"<pre><code>// test/utils/custom_matchers.dart\nimport 'package:flutter_test/flutter_test.dart';\n\nMatcher hasErrorText(String text) =&gt; _HasErrorText(text);\n\nclass _HasErrorText extends Matcher {\n  final String expectedText;\n\n  _HasErrorText(this.expectedText);\n\n  @override\n  bool matches(item, Map matchState) {\n    if (item is! Widget) return false;\n    // Implementation to check error text\n    return true;\n  }\n\n  @override\n  Description describe(Description description) =&gt;\n      description.add('has error text \"$expectedText\"');\n}\n</code></pre>"},{"location":"testing/testing-guide/#test-helpers","title":"Test Helpers","text":"<pre><code>// test/utils/test_helpers.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass TestHelpers {\n  static Widget wrapWithMaterialApp(Widget child) {\n    return MaterialApp(home: Scaffold(body: child));\n  }\n\n  static Widget wrapWithProviders(\n    Widget child, {\n    List&lt;Override&gt; overrides = const [],\n  }) {\n    return ProviderScope(\n      overrides: overrides,\n      child: wrapWithMaterialApp(child),\n    );\n  }\n\n  static Future&lt;void&gt; enterTextAndSettle(\n    WidgetTester tester,\n    Finder finder,\n    String text,\n  ) async {\n    await tester.enterText(finder, text);\n    await tester.pumpAndSettle();\n  }\n\n  static Future&lt;void&gt; tapAndSettle(\n    WidgetTester tester,\n    Finder finder,\n  ) async {\n    await tester.tap(finder);\n    await tester.pumpAndSettle();\n  }\n}\n</code></pre>"},{"location":"testing/testing-guide/#running-tests","title":"Running Tests","text":""},{"location":"testing/testing-guide/#commands","title":"Commands","text":"<pre><code># Run all tests\nflutter test\n\n# Run specific test file\nflutter test test/services/auth_service_test.dart\n\n# Run tests with coverage\nflutter test --coverage\n\n# Run integration tests\nflutter test integration_test/\n\n# Run tests in watch mode\nflutter test --watch\n\n# Generate coverage report\ngenhtml coverage/lcov.info -o coverage/html\n</code></pre>"},{"location":"testing/testing-guide/#test-configuration","title":"Test Configuration","text":"<pre><code># test/flutter_test_config.dart\nimport 'dart:async';\nimport 'package:flutter_test/flutter_test.dart';\n\nFuture&lt;void&gt; testExecutable(FutureOr&lt;void&gt; Function() testMain) async {\n  setUpAll(() {\n    // Global test setup\n  });\n\n  tearDownAll(() {\n    // Global test cleanup\n  });\n\n  await testMain();\n}\n</code></pre>"},{"location":"testing/testing-guide/#best-practices","title":"Best Practices","text":"<ol> <li>Follow AAA Pattern: Arrange, Act, Assert</li> <li>Use descriptive test names: Describe what the test does</li> <li>Test one thing at a time: Keep tests focused</li> <li>Use mocks for external dependencies: Isolate units under test</li> <li>Clean up resources: Dispose controllers and streams</li> <li>Test edge cases: Handle error scenarios</li> <li>Keep tests fast: Avoid unnecessary delays</li> <li>Use golden tests for UI: Catch visual regressions</li> </ol>"},{"location":"testing/testing-guide/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Set up your testing environment</li> <li>\u2705 Write unit tests for your services and providers</li> <li>\u2705 Create widget tests for your custom components</li> <li>\u2705 Add integration tests for critical user flows</li> <li>\u2705 Proceed to Deployment Documentation</li> </ol> <p>Your Flutter testing strategy is now ready for comprehensive test coverage!</p>"},{"location":"tools/code-quality/","title":"Code Quality","text":"<p>Comprehensive guide to maintaining high code quality in Flutter applications through linting, formatting, and best practices.</p>"},{"location":"tools/code-quality/#overview","title":"Overview","text":"<p>Code quality is essential for maintainable, scalable Flutter applications. This guide covers static analysis, formatting, linting rules, and quality metrics.</p>"},{"location":"tools/code-quality/#static-analysis-configuration","title":"Static Analysis Configuration","text":""},{"location":"tools/code-quality/#1-analysis-options","title":"1. Analysis Options","text":"<pre><code># analysis_options.yaml\ninclude: package:flutter_lints/flutter.yaml\n\nanalyzer:\n  exclude:\n    - \"**/*.g.dart\"\n    - \"**/*.freezed.dart\"\n    - \"build/**\"\n    - \"lib/generated/**\"\n\n  strong-mode:\n    implicit-casts: false\n    implicit-dynamic: false\n\n  errors:\n    invalid_annotation_target: ignore\n    missing_required_param: error\n    missing_return: error\n    todo: ignore\n\nlinter:\n  rules:\n    # Error rules\n    - avoid_empty_else\n    - avoid_print\n    - avoid_relative_lib_imports\n    - avoid_returning_null_for_future\n    - avoid_slow_async_io\n    - avoid_types_as_parameter_names\n    - cancel_subscriptions\n    - close_sinks\n    - comment_references\n    - control_flow_in_finally\n    - empty_statements\n    - hash_and_equals\n    - invariant_booleans\n    - iterable_contains_unrelated_type\n    - list_remove_unrelated_type\n    - literal_only_boolean_expressions\n    - no_adjacent_strings_in_list\n    - no_duplicate_case_values\n    - prefer_void_to_null\n    - test_types_in_equals\n    - throw_in_finally\n    - unnecessary_statements\n    - unrelated_type_equality_checks\n    - valid_regexps\n\n    # Style rules\n    - always_declare_return_types\n    - always_put_control_body_on_new_line\n    - always_put_required_named_parameters_first\n    - always_require_non_null_named_parameters\n    - annotate_overrides\n    - avoid_annotating_with_dynamic\n    - avoid_bool_literals_in_conditional_expressions\n    - avoid_catches_without_on_clauses\n    - avoid_catching_errors\n    - avoid_double_and_int_checks\n    - avoid_field_initializers_in_const_classes\n    - avoid_function_literals_in_foreach_calls\n    - avoid_implementing_value_types\n    - avoid_init_to_null\n    - avoid_null_checks_in_equality_operators\n    - avoid_positional_boolean_parameters\n    - avoid_private_typedef_functions\n    - avoid_redundant_argument_values\n    - avoid_renaming_method_parameters\n    - avoid_return_types_on_setters\n    - avoid_returning_null\n    - avoid_returning_null_for_void\n    - avoid_setters_without_getters\n    - avoid_shadowing_type_parameters\n    - avoid_single_cascade_in_expression_statements\n    - avoid_unnecessary_containers\n    - avoid_unused_constructor_parameters\n    - avoid_void_async\n    - await_only_futures\n    - camel_case_extensions\n    - camel_case_types\n    - cascade_invocations\n    - constant_identifier_names\n    - curly_braces_in_flow_control_structures\n    - directives_ordering\n    - empty_catches\n    - empty_constructor_bodies\n    - file_names\n    - flutter_style_todos\n    - implementation_imports\n    - join_return_with_assignment\n    - leading_newlines_in_multiline_strings\n    - library_names\n    - library_prefixes\n    - lines_longer_than_80_chars\n    - missing_whitespace_between_adjacent_strings\n    - no_runtimeType_toString\n    - non_constant_identifier_names\n    - null_closures\n    - omit_local_variable_types\n    - one_member_abstracts\n    - only_throw_errors\n    - overridden_fields\n    - package_api_docs\n    - package_prefixed_library_names\n    - parameter_assignments\n    - prefer_adjacent_string_concatenation\n    - prefer_asserts_in_initializer_lists\n    - prefer_asserts_with_message\n    - prefer_collection_literals\n    - prefer_conditional_assignment\n    - prefer_const_constructors\n    - prefer_const_constructors_in_immutables\n    - prefer_const_declarations\n    - prefer_const_literals_to_create_immutables\n    - prefer_constructors_over_static_methods\n    - prefer_contains\n    - prefer_equal_for_default_values\n    - prefer_expression_function_bodies\n    - prefer_final_fields\n    - prefer_final_in_for_each\n    - prefer_final_locals\n    - prefer_for_elements_to_map_fromIterable\n    - prefer_foreach\n    - prefer_function_declarations_over_variables\n    - prefer_generic_function_type_aliases\n    - prefer_if_elements_to_conditional_expressions\n    - prefer_if_null_operators\n    - prefer_initializing_formals\n    - prefer_inlined_adds\n    - prefer_int_literals\n    - prefer_interpolation_to_compose_strings\n    - prefer_is_empty\n    - prefer_is_not_empty\n    - prefer_is_not_operator\n    - prefer_iterable_whereType\n    - prefer_null_aware_operators\n    - prefer_relative_imports\n    - prefer_single_quotes\n    - prefer_spread_collections\n    - prefer_typing_uninitialized_variables\n    - provide_deprecation_message\n    - public_member_api_docs\n    - recursive_getters\n    - slash_for_doc_comments\n    - sort_child_properties_last\n    - sort_constructors_first\n    - sort_pub_dependencies\n    - sort_unnamed_constructors_first\n    - type_annotate_public_apis\n    - type_init_formals\n    - unawaited_futures\n    - unnecessary_await_in_return\n    - unnecessary_brace_in_string_interps\n    - unnecessary_const\n    - unnecessary_getters_setters\n    - unnecessary_lambdas\n    - unnecessary_new\n    - unnecessary_null_aware_assignments\n    - unnecessary_null_in_if_null_operators\n    - unnecessary_overrides\n    - unnecessary_parenthesis\n    - unnecessary_raw_strings\n    - unnecessary_string_escapes\n    - unnecessary_string_interpolations\n    - unnecessary_this\n    - use_full_hex_values_for_flutter_colors\n    - use_function_type_syntax_for_parameters\n    - use_rethrow_when_possible\n    - use_setters_to_change_properties\n    - use_string_buffers\n    - use_to_and_as_if_applicable\n    - void_checks\n</code></pre>"},{"location":"tools/code-quality/#2-custom-lint-rules","title":"2. Custom Lint Rules","text":"<pre><code>// lib/analysis/custom_lint_rules.dart\nimport 'package:analyzer/dart/analysis/results.dart';\nimport 'package:analyzer/dart/ast/ast.dart';\nimport 'package:analyzer/dart/ast/visitor.dart';\nimport 'package:custom_lint_builder/custom_lint_builder.dart';\n\nclass NoHardcodedStringsRule extends DartLintRule {\n  const NoHardcodedStringsRule() : super(code: _code);\n\n  static const _code = LintCode(\n    name: 'no_hardcoded_strings',\n    problemMessage: 'Avoid hardcoded strings. Use localization instead.',\n    errorSeverity: ErrorSeverity.WARNING,\n  );\n\n  @override\n  void run(\n    CustomLintResolver resolver,\n    ErrorReporter reporter,\n    CustomLintContext context,\n  ) {\n    context.registry.addStringLiteral((node) {\n      if (_isHardcodedString(node)) {\n        reporter.reportErrorForNode(code, node);\n      }\n    });\n  }\n\n  bool _isHardcodedString(StringLiteral node) {\n    // Check if string is user-facing text\n    final value = node.stringValue;\n    if (value == null || value.length &lt; 3) return false;\n\n    // Skip if it's a key or technical string\n    if (value.contains('_') || value.contains('.')) return false;\n\n    // Check if it contains user-facing text\n    return RegExp(r'^[A-Z][a-z\\s]+').hasMatch(value);\n  }\n}\n</code></pre>"},{"location":"tools/code-quality/#code-formatting","title":"Code Formatting","text":""},{"location":"tools/code-quality/#1-dart-format-configuration","title":"1. Dart Format Configuration","text":"<pre><code># .dart_tool/dart_format_options.yaml\nline_length: 80\nindent: 2\n</code></pre>"},{"location":"tools/code-quality/#2-format-scripts","title":"2. Format Scripts","text":"<pre><code>#!/bin/bash\n# scripts/format.sh\n\necho \"\ud83c\udfa8 Formatting Dart code...\"\n\n# Format all Dart files\ndart format lib/ test/ --set-exit-if-changed\n\n# Check if formatting was applied\nif [ $? -eq 0 ]; then\n    echo \"\u2705 Code is properly formatted\"\nelse\n    echo \"\u274c Code formatting issues found\"\n    echo \"Run 'dart format lib/ test/' to fix formatting\"\n    exit 1\nfi\n</code></pre>"},{"location":"tools/code-quality/#3-ide-configuration","title":"3. IDE Configuration","text":"<pre><code>// .vscode/settings.json\n{\n  \"dart.lineLength\": 80,\n  \"dart.insertArgumentPlaceholders\": false,\n  \"dart.showTodos\": true,\n  \"dart.runPubGetOnPubspecChanges\": true,\n  \"dart.previewFlutterUiGuides\": true,\n  \"dart.previewFlutterUiGuidesCustomTracking\": true,\n  \"editor.formatOnSave\": true,\n  \"editor.formatOnType\": true,\n  \"editor.rulers\": [80],\n  \"files.trimTrailingWhitespace\": true,\n  \"files.insertFinalNewline\": true,\n  \"files.trimFinalNewlines\": true\n}\n</code></pre>"},{"location":"tools/code-quality/#code-metrics","title":"Code Metrics","text":""},{"location":"tools/code-quality/#1-complexity-analysis","title":"1. Complexity Analysis","text":"<pre><code>// lib/analysis/complexity_analyzer.dart\nclass ComplexityAnalyzer {\n  static void analyzeFile(String filePath) {\n    final file = File(filePath);\n    final content = file.readAsStringSync();\n\n    final lines = content.split('\\n');\n    final codeLines = lines.where((line) =&gt; \n      line.trim().isNotEmpty &amp;&amp; \n      !line.trim().startsWith('//') &amp;&amp;\n      !line.trim().startsWith('/*')\n    ).length;\n\n    final methods = RegExp(r'\\w+\\s*\\([^)]*\\)\\s*{').allMatches(content).length;\n    final classes = RegExp(r'class\\s+\\w+').allMatches(content).length;\n\n    print('File: $filePath');\n    print('Lines of code: $codeLines');\n    print('Methods: $methods');\n    print('Classes: $classes');\n\n    if (codeLines &gt; 500) {\n      print('\u26a0\ufe0f  File is too large (&gt;500 lines)');\n    }\n\n    if (methods &gt; 20) {\n      print('\u26a0\ufe0f  Too many methods in file (&gt;20)');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/code-quality/#2-test-coverage-analysis","title":"2. Test Coverage Analysis","text":"<pre><code>#!/bin/bash\n# scripts/coverage-analysis.sh\n\necho \"\ud83d\udcca Analyzing test coverage...\"\n\n# Run tests with coverage\nflutter test --coverage\n\n# Generate coverage report\ngenhtml coverage/lcov.info -o coverage/html\n\n# Extract coverage percentage\nCOVERAGE=$(lcov --summary coverage/lcov.info | grep \"lines\" | awk '{print $2}' | sed 's/%//')\n\necho \"Current coverage: $COVERAGE%\"\n\n# Check coverage threshold\nTHRESHOLD=80\nif (( $(echo \"$COVERAGE &lt; $THRESHOLD\" | bc -l) )); then\n    echo \"\u274c Coverage below threshold ($THRESHOLD%)\"\n    exit 1\nelse\n    echo \"\u2705 Coverage meets threshold\"\nfi\n</code></pre>"},{"location":"tools/code-quality/#documentation-standards","title":"Documentation Standards","text":""},{"location":"tools/code-quality/#1-documentation-comments","title":"1. Documentation Comments","text":"<pre><code>// lib/models/user.dart\n\n/// Represents a user in the application.\n/// \n/// This class contains all user-related information including\n/// authentication details and profile data.\n/// \n/// Example:\n/// ```dart\n/// final user = User(\n///   id: '123',\n///   email: 'user@example.com',\n///   name: 'John Doe',\n/// );\n/// ```\nclass User {\n  /// The unique identifier for the user.\n  final String id;\n\n  /// The user's email address.\n  /// \n  /// Must be a valid email format and unique across the system.\n  final String email;\n\n  /// The user's display name.\n  /// \n  /// Can be null if the user hasn't set a display name.\n  final String? name;\n\n  /// Creates a new [User] instance.\n  /// \n  /// The [id] and [email] parameters are required.\n  /// The [name] parameter is optional.\n  const User({\n    required this.id,\n    required this.email,\n    this.name,\n  });\n\n  /// Creates a [User] from a JSON map.\n  /// \n  /// Throws [FormatException] if the JSON is invalid.\n  factory User.fromJson(Map&lt;String, dynamic&gt; json) {\n    return User(\n      id: json['id'] as String,\n      email: json['email'] as String,\n      name: json['name'] as String?,\n    );\n  }\n\n  /// Converts this [User] to a JSON map.\n  Map&lt;String, dynamic&gt; toJson() {\n    return {\n      'id': id,\n      'email': email,\n      'name': name,\n    };\n  }\n}\n</code></pre>"},{"location":"tools/code-quality/#2-readme-standards","title":"2. README Standards","text":"<pre><code># Feature Name\n\nBrief description of what this feature does.\n\n## Usage\n\n```dart\n// Example usage\nfinal feature = FeatureName();\nawait feature.doSomething();\n</code></pre>"},{"location":"tools/code-quality/#api-reference","title":"API Reference","text":""},{"location":"tools/code-quality/#methods","title":"Methods","text":""},{"location":"tools/code-quality/#dosomething","title":"<code>doSomething()</code>","text":"<p>Description of what this method does.</p> <p>Parameters: - <code>param1</code> (String): Description of parameter - <code>param2</code> (int, optional): Description of optional parameter</p> <p>Returns: - <code>Future&lt;bool&gt;</code>: Description of return value</p> <p>Throws: - <code>Exception</code>: When something goes wrong</p>"},{"location":"tools/code-quality/#testing","title":"Testing","text":"<p><pre><code>flutter test test/features/feature_name_test.dart\n</code></pre> <pre><code>## Quality Gates\n\n### 1. Pre-commit Hooks\n\n```bash\n#!/bin/bash\n# .git/hooks/pre-commit\n\necho \"\ud83d\udd0d Running pre-commit quality checks...\"\n\n# Check formatting\ndart format lib/ test/ --set-exit-if-changed\nif [ $? -ne 0 ]; then\n    echo \"\u274c Code formatting failed\"\n    exit 1\nfi\n\n# Run static analysis\nflutter analyze\nif [ $? -ne 0 ]; then\n    echo \"\u274c Static analysis failed\"\n    exit 1\nfi\n\n# Run tests\nflutter test\nif [ $? -ne 0 ]; then\n    echo \"\u274c Tests failed\"\n    exit 1\nfi\n\necho \"\u2705 All quality checks passed\"\n</code></pre></p>"},{"location":"tools/code-quality/#2-cicd-quality-checks","title":"2. CI/CD Quality Checks","text":"<pre><code># .github/workflows/quality.yml\nname: Code Quality\n\non: [push, pull_request]\n\njobs:\n  quality:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: subosito/flutter-action@v2\n\n      - name: Install dependencies\n        run: flutter pub get\n\n      - name: Check formatting\n        run: dart format lib/ test/ --set-exit-if-changed\n\n      - name: Analyze code\n        run: flutter analyze\n\n      - name: Run tests\n        run: flutter test --coverage\n\n      - name: Check coverage\n        run: |\n          COVERAGE=$(lcov --summary coverage/lcov.info | grep \"lines\" | awk '{print $2}' | sed 's/%//')\n          if (( $(echo \"$COVERAGE &lt; 80\" | bc -l) )); then\n            echo \"Coverage below 80%: $COVERAGE%\"\n            exit 1\n          fi\n</code></pre>"},{"location":"tools/code-quality/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"tools/code-quality/#1-review-checklist","title":"1. Review Checklist","text":"<pre><code>## Code Review Checklist\n\n### Functionality\n- [ ] Code does what it's supposed to do\n- [ ] Edge cases are handled\n- [ ] Error handling is appropriate\n\n### Code Quality\n- [ ] Code follows project conventions\n- [ ] No code duplication\n- [ ] Functions are small and focused\n- [ ] Variable names are descriptive\n\n### Performance\n- [ ] No obvious performance issues\n- [ ] Efficient algorithms used\n- [ ] Memory usage is reasonable\n\n### Testing\n- [ ] Tests cover new functionality\n- [ ] Tests are meaningful and not just for coverage\n- [ ] Integration tests for complex features\n\n### Documentation\n- [ ] Public APIs are documented\n- [ ] Complex logic is explained\n- [ ] README updated if needed\n\n### Security\n- [ ] No sensitive data exposed\n- [ ] Input validation is present\n- [ ] Authentication/authorization checked\n</code></pre>"},{"location":"tools/code-quality/#2-review-tools","title":"2. Review Tools","text":"<pre><code>// lib/tools/review_helper.dart\nclass ReviewHelper {\n  /// Checks if a class is too large\n  static bool isClassTooLarge(String classContent) {\n    final lines = classContent.split('\\n').length;\n    return lines &gt; 300;\n  }\n\n  /// Checks if a method is too complex\n  static bool isMethodTooComplex(String methodContent) {\n    final cyclomaticComplexity = _calculateCyclomaticComplexity(methodContent);\n    return cyclomaticComplexity &gt; 10;\n  }\n\n  /// Checks for potential code smells\n  static List&lt;String&gt; findCodeSmells(String code) {\n    final smells = &lt;String&gt;[];\n\n    if (code.contains('TODO')) {\n      smells.add('Contains TODO comments');\n    }\n\n    if (RegExp(r'catch\\s*\\(\\s*\\w+\\s*\\)\\s*\\{\\s*\\}').hasMatch(code)) {\n      smells.add('Empty catch blocks');\n    }\n\n    if (code.split('\\n').any((line) =&gt; line.length &gt; 120)) {\n      smells.add('Lines longer than 120 characters');\n    }\n\n    return smells;\n  }\n\n  static int _calculateCyclomaticComplexity(String code) {\n    // Simplified complexity calculation\n    final keywords = ['if', 'else', 'while', 'for', 'switch', 'case', 'catch'];\n    int complexity = 1; // Base complexity\n\n    for (final keyword in keywords) {\n      complexity += RegExp('\\\\b$keyword\\\\b').allMatches(code).length;\n    }\n\n    return complexity;\n  }\n}\n</code></pre>"},{"location":"tools/code-quality/#automated-quality-tools","title":"Automated Quality Tools","text":""},{"location":"tools/code-quality/#1-quality-dashboard","title":"1. Quality Dashboard","text":"<pre><code>// lib/tools/quality_dashboard.dart\nclass QualityMetrics {\n  final double testCoverage;\n  final int lintIssues;\n  final int codeSmells;\n  final double maintainabilityIndex;\n\n  const QualityMetrics({\n    required this.testCoverage,\n    required this.lintIssues,\n    required this.codeSmells,\n    required this.maintainabilityIndex,\n  });\n\n  bool get isHealthy =&gt; \n    testCoverage &gt;= 80 &amp;&amp;\n    lintIssues == 0 &amp;&amp;\n    codeSmells &lt; 5 &amp;&amp;\n    maintainabilityIndex &gt;= 70;\n}\n</code></pre>"},{"location":"tools/code-quality/#2-quality-reports","title":"2. Quality Reports","text":"<pre><code>#!/bin/bash\n# scripts/quality-report.sh\n\necho \"\ud83d\udcca Generating quality report...\"\n\n# Create report directory\nmkdir -p reports\n\n# Generate coverage report\nflutter test --coverage\ngenhtml coverage/lcov.info -o reports/coverage\n\n# Run static analysis\nflutter analyze &gt; reports/analysis.txt 2&gt;&amp;1\n\n# Generate metrics\necho \"Quality Report - $(date)\" &gt; reports/quality-summary.txt\necho \"================================\" &gt;&gt; reports/quality-summary.txt\n\n# Coverage\nCOVERAGE=$(lcov --summary coverage/lcov.info | grep \"lines\" | awk '{print $2}')\necho \"Test Coverage: $COVERAGE\" &gt;&gt; reports/quality-summary.txt\n\n# Analysis issues\nISSUES=$(flutter analyze 2&gt;&amp;1 | grep -c \"info \u2022\")\necho \"Analysis Issues: $ISSUES\" &gt;&gt; reports/quality-summary.txt\n\necho \"\u2705 Quality report generated in reports/\"\n</code></pre> <p>Code quality is an ongoing process that requires consistent effort and the right tools. Establish quality standards early and enforce them through automation.</p>"},{"location":"tools/debugging/","title":"Debugging Guide","text":"<p>Comprehensive guide to debugging Flutter applications using various tools and techniques.</p>"},{"location":"tools/debugging/#overview","title":"Overview","text":"<p>Effective debugging is crucial for Flutter development. This guide covers debugging tools, techniques, and best practices for identifying and fixing issues in your Flutter app.</p>"},{"location":"tools/debugging/#flutter-inspector","title":"Flutter Inspector","text":""},{"location":"tools/debugging/#1-widget-inspector","title":"1. Widget Inspector","text":"<p>The Flutter Inspector helps visualize the widget tree and debug layout issues.</p> <pre><code>// Enable inspector in debug mode\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Enable debug banner in debug mode\n      debugShowCheckedModeBanner: true,\n      home: HomeScreen(),\n    );\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-layout-explorer","title":"2. Layout Explorer","text":"<p>Use the Layout Explorer to understand widget constraints and sizing.</p> <pre><code>// Add debug information to widgets\nclass DebugContainer extends StatelessWidget {\n  final Widget child;\n  final String debugLabel;\n\n  const DebugContainer({\n    Key? key,\n    required this.child,\n    required this.debugLabel,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // Add debug properties\n      child: child,\n    );\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(StringProperty('debugLabel', debugLabel));\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#debug-console","title":"Debug Console","text":""},{"location":"tools/debugging/#1-print-debugging","title":"1. Print Debugging","text":"<pre><code>// Basic print statements\nvoid debugFunction() {\n  print('Debug: Function called');\n  print('Debug: Variable value = $variableValue');\n}\n\n// Conditional debugging\nvoid conditionalDebug() {\n  if (kDebugMode) {\n    print('This only prints in debug mode');\n  }\n}\n\n// Debug with stack trace\nvoid debugWithStackTrace() {\n  debugPrint('Error occurred');\n  debugPrintStack(label: 'Stack trace:');\n}\n</code></pre>"},{"location":"tools/debugging/#2-logger-package","title":"2. Logger Package","text":"<pre><code>// lib/utils/logger.dart\nimport 'package:logger/logger.dart';\n\nclass AppLogger {\n  static final Logger _logger = Logger(\n    printer: PrettyPrinter(\n      methodCount: 2,\n      errorMethodCount: 8,\n      lineLength: 120,\n      colors: true,\n      printEmojis: true,\n      printTime: true,\n    ),\n  );\n\n  static void debug(String message) {\n    _logger.d(message);\n  }\n\n  static void info(String message) {\n    _logger.i(message);\n  }\n\n  static void warning(String message) {\n    _logger.w(message);\n  }\n\n  static void error(String message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.e(message, error, stackTrace);\n  }\n}\n\n// Usage\nAppLogger.debug('User logged in');\nAppLogger.error('API call failed', error, stackTrace);\n</code></pre>"},{"location":"tools/debugging/#breakpoints-and-debugging","title":"Breakpoints and Debugging","text":""},{"location":"tools/debugging/#1-setting-breakpoints","title":"1. Setting Breakpoints","text":"<pre><code>// lib/services/user_service.dart\nclass UserService {\n  Future&lt;User&gt; getUser(String id) async {\n    // Set breakpoint here\n    debugger(); // Programmatic breakpoint\n\n    try {\n      final response = await apiClient.get('/users/$id');\n\n      // Set breakpoint here to inspect response\n      final user = User.fromJson(response.data);\n      return user;\n    } catch (e) {\n      // Set breakpoint here to debug errors\n      throw Exception('Failed to get user: $e');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-conditional-breakpoints","title":"2. Conditional Breakpoints","text":"<pre><code>// Break only when specific conditions are met\nvoid processItems(List&lt;Item&gt; items) {\n  for (int i = 0; i &lt; items.length; i++) {\n    final item = items[i];\n\n    // Conditional breakpoint: break when item.id == 'specific-id'\n    if (item.id == 'specific-id') {\n      debugger(); // This will only break for specific item\n    }\n\n    processItem(item);\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#performance-debugging","title":"Performance Debugging","text":""},{"location":"tools/debugging/#1-performance-overlay","title":"1. Performance Overlay","text":"<pre><code>// Enable performance overlay\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Show performance overlay in debug mode\n      showPerformanceOverlay: kDebugMode,\n      home: HomeScreen(),\n    );\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-timeline-debugging","title":"2. Timeline Debugging","text":"<pre><code>// lib/utils/performance_utils.dart\nimport 'dart:developer' as developer;\n\nclass PerformanceUtils {\n  static void timeFunction(String name, Function function) {\n    final stopwatch = Stopwatch()..start();\n\n    developer.Timeline.startSync(name);\n    try {\n      function();\n    } finally {\n      developer.Timeline.finishSync();\n      stopwatch.stop();\n\n      if (kDebugMode) {\n        print('$name took ${stopwatch.elapsedMilliseconds}ms');\n      }\n    }\n  }\n\n  static Future&lt;T&gt; timeAsyncFunction&lt;T&gt;(String name, Future&lt;T&gt; Function() function) async {\n    final stopwatch = Stopwatch()..start();\n\n    developer.Timeline.startSync(name);\n    try {\n      return await function();\n    } finally {\n      developer.Timeline.finishSync();\n      stopwatch.stop();\n\n      if (kDebugMode) {\n        print('$name took ${stopwatch.elapsedMilliseconds}ms');\n      }\n    }\n  }\n}\n\n// Usage\nPerformanceUtils.timeFunction('Heavy Calculation', () {\n  // Heavy computation here\n});\n\nfinal result = await PerformanceUtils.timeAsyncFunction('API Call', () async {\n  return await apiClient.getData();\n});\n</code></pre>"},{"location":"tools/debugging/#3-memory-debugging","title":"3. Memory Debugging","text":"<pre><code>// lib/utils/memory_utils.dart\nimport 'dart:developer' as developer;\n\nclass MemoryUtils {\n  static void logMemoryUsage(String label) {\n    if (kDebugMode) {\n      final info = developer.Service.getIsolateID(Isolate.current);\n      print('Memory usage at $label: ${info}');\n    }\n  }\n\n  static void trackObjectCreation&lt;T&gt;(T object, String name) {\n    if (kDebugMode) {\n      print('Created $name: ${object.runtimeType}');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#network-debugging","title":"Network Debugging","text":""},{"location":"tools/debugging/#1-http-interceptors","title":"1. HTTP Interceptors","text":"<pre><code>// lib/services/debug_interceptor.dart\nclass DebugInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    if (kDebugMode) {\n      print('REQUEST[${options.method}] =&gt; PATH: ${options.path}');\n      print('Headers: ${options.headers}');\n      print('Data: ${options.data}');\n    }\n    super.onRequest(options, handler);\n  }\n\n  @override\n  void onResponse(Response response, ResponseInterceptorHandler handler) {\n    if (kDebugMode) {\n      print('RESPONSE[${response.statusCode}] =&gt; PATH: ${response.requestOptions.path}');\n      print('Data: ${response.data}');\n    }\n    super.onResponse(response, handler);\n  }\n\n  @override\n  void onError(DioError err, ErrorInterceptorHandler handler) {\n    if (kDebugMode) {\n      print('ERROR[${err.response?.statusCode}] =&gt; PATH: ${err.requestOptions.path}');\n      print('Message: ${err.message}');\n    }\n    super.onError(err, handler);\n  }\n}\n\n// Add to Dio instance\nfinal dio = Dio();\nif (kDebugMode) {\n  dio.interceptors.add(DebugInterceptor());\n}\n</code></pre>"},{"location":"tools/debugging/#2-network-inspector","title":"2. Network Inspector","text":"<pre><code>// lib/utils/network_inspector.dart\nclass NetworkInspector {\n  static void logRequest(String method, String url, Map&lt;String, dynamic&gt;? data) {\n    if (kDebugMode) {\n      print('\ud83c\udf10 $method $url');\n      if (data != null) {\n        print('\ud83d\udce4 Request Data: ${jsonEncode(data)}');\n      }\n    }\n  }\n\n  static void logResponse(int statusCode, String url, dynamic data) {\n    if (kDebugMode) {\n      final emoji = statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 ? '\u2705' : '\u274c';\n      print('$emoji Response [$statusCode] $url');\n      print('\ud83d\udce5 Response Data: ${jsonEncode(data)}');\n    }\n  }\n\n  static void logError(String url, dynamic error) {\n    if (kDebugMode) {\n      print('\ud83d\udea8 Network Error: $url');\n      print('Error: $error');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#state-debugging","title":"State Debugging","text":""},{"location":"tools/debugging/#1-riverpod-debugging","title":"1. Riverpod Debugging","text":"<pre><code>// lib/providers/debug_observer.dart\nclass DebugProviderObserver extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    if (kDebugMode) {\n      print('Provider ${provider.name ?? provider.runtimeType} updated');\n      print('Previous: $previousValue');\n      print('New: $newValue');\n    }\n  }\n\n  @override\n  void didDisposeProvider(ProviderBase provider, ProviderContainer container) {\n    if (kDebugMode) {\n      print('Provider ${provider.name ?? provider.runtimeType} disposed');\n    }\n  }\n}\n\n// Add to ProviderScope\nProviderScope(\n  observers: [DebugProviderObserver()],\n  child: MyApp(),\n)\n</code></pre>"},{"location":"tools/debugging/#2-bloc-debugging","title":"2. BLoC Debugging","text":"<pre><code>// lib/blocs/debug_bloc_observer.dart\nclass DebugBlocObserver extends BlocObserver {\n  @override\n  void onCreate(BlocBase bloc) {\n    super.onCreate(bloc);\n    if (kDebugMode) {\n      print('BLoC Created: ${bloc.runtimeType}');\n    }\n  }\n\n  @override\n  void onEvent(BlocBase bloc, Object? event) {\n    super.onEvent(bloc, event);\n    if (kDebugMode) {\n      print('BLoC Event: ${bloc.runtimeType} - $event');\n    }\n  }\n\n  @override\n  void onTransition(BlocBase bloc, Transition transition) {\n    super.onTransition(bloc, transition);\n    if (kDebugMode) {\n      print('BLoC Transition: ${bloc.runtimeType}');\n      print('Current State: ${transition.currentState}');\n      print('Event: ${transition.event}');\n      print('Next State: ${transition.nextState}');\n    }\n  }\n\n  @override\n  void onError(BlocBase bloc, Object error, StackTrace stackTrace) {\n    super.onError(bloc, error, stackTrace);\n    if (kDebugMode) {\n      print('BLoC Error: ${bloc.runtimeType} - $error');\n      print('Stack Trace: $stackTrace');\n    }\n  }\n}\n\n// Set global observer\nvoid main() {\n  Bloc.observer = DebugBlocObserver();\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"tools/debugging/#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"tools/debugging/#1-global-error-handling","title":"1. Global Error Handling","text":"<pre><code>// lib/utils/error_handler.dart\nclass ErrorHandler {\n  static void initialize() {\n    // Catch Flutter framework errors\n    FlutterError.onError = (FlutterErrorDetails details) {\n      if (kDebugMode) {\n        FlutterError.presentError(details);\n      } else {\n        // Log to crash reporting service\n        FirebaseCrashlytics.instance.recordFlutterFatalError(details);\n      }\n    };\n\n    // Catch async errors\n    PlatformDispatcher.instance.onError = (error, stack) {\n      if (kDebugMode) {\n        print('Async Error: $error');\n        print('Stack Trace: $stack');\n      } else {\n        FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);\n      }\n      return true;\n    };\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-custom-error-widget","title":"2. Custom Error Widget","text":"<pre><code>// lib/widgets/debug_error_widget.dart\nclass DebugErrorWidget extends StatelessWidget {\n  final FlutterErrorDetails errorDetails;\n\n  const DebugErrorWidget({\n    Key? key,\n    required this.errorDetails,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Container(\n        color: Colors.red.shade100,\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(Icons.error, size: 48, color: Colors.red),\n            SizedBox(height: 16),\n            Text(\n              'An error occurred',\n              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n            ),\n            SizedBox(height: 8),\n            if (kDebugMode) ...[\n              Text(\n                errorDetails.exception.toString(),\n                style: TextStyle(fontSize: 14),\n                textAlign: TextAlign.center,\n              ),\n              SizedBox(height: 8),\n              Expanded(\n                child: SingleChildScrollView(\n                  child: Text(\n                    errorDetails.stack.toString(),\n                    style: TextStyle(fontSize: 12, fontFamily: 'monospace'),\n                  ),\n                ),\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Set custom error widget\nvoid main() {\n  ErrorWidget.builder = (FlutterErrorDetails details) {\n    return DebugErrorWidget(errorDetails: details);\n  };\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"tools/debugging/#platform-specific-debugging","title":"Platform-Specific Debugging","text":""},{"location":"tools/debugging/#1-ios-debugging","title":"1. iOS Debugging","text":"<pre><code>// lib/utils/ios_debug.dart\nclass IOSDebug {\n  static void enableDebugLogging() {\n    if (Platform.isIOS &amp;&amp; kDebugMode) {\n      // Enable iOS-specific debugging\n      print('iOS Debug mode enabled');\n    }\n  }\n\n  static void logViewControllerLifecycle(String event) {\n    if (Platform.isIOS &amp;&amp; kDebugMode) {\n      print('iOS ViewController: $event');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-android-debugging","title":"2. Android Debugging","text":"<pre><code>// lib/utils/android_debug.dart\nclass AndroidDebug {\n  static void enableDebugLogging() {\n    if (Platform.isAndroid &amp;&amp; kDebugMode) {\n      // Enable Android-specific debugging\n      print('Android Debug mode enabled');\n    }\n  }\n\n  static void logActivityLifecycle(String event) {\n    if (Platform.isAndroid &amp;&amp; kDebugMode) {\n      print('Android Activity: $event');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#debug-tools-and-commands","title":"Debug Tools and Commands","text":""},{"location":"tools/debugging/#1-flutter-commands","title":"1. Flutter Commands","text":"<pre><code># Debug build\nflutter run --debug\n\n# Profile build\nflutter run --profile\n\n# Enable verbose logging\nflutter run --verbose\n\n# Debug specific device\nflutter run -d &lt;device-id&gt;\n\n# Hot reload\nr\n\n# Hot restart\nR\n\n# Debug inspector\nw\n\n# Performance overlay\nP\n</code></pre>"},{"location":"tools/debugging/#2-debug-utilities","title":"2. Debug Utilities","text":"<pre><code>// lib/utils/debug_utils.dart\nclass DebugUtils {\n  static void dumpWidget(Widget widget) {\n    if (kDebugMode) {\n      debugDumpApp();\n    }\n  }\n\n  static void dumpRenderTree() {\n    if (kDebugMode) {\n      debugDumpRenderTree();\n    }\n  }\n\n  static void dumpLayerTree() {\n    if (kDebugMode) {\n      debugDumpLayerTree();\n    }\n  }\n\n  static void printWidgetTree(BuildContext context) {\n    if (kDebugMode) {\n      context.visitAncestorElements((element) {\n        print('Widget: ${element.widget.runtimeType}');\n        return true;\n      });\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#best-practices","title":"Best Practices","text":""},{"location":"tools/debugging/#1-debug-configuration","title":"1. Debug Configuration","text":"<pre><code>// lib/config/debug_config.dart\nclass DebugConfig {\n  static const bool enableNetworkLogging = true;\n  static const bool enableStateLogging = true;\n  static const bool enablePerformanceLogging = false;\n\n  static bool get isDebugMode =&gt; kDebugMode;\n\n  static void log(String message, {String? tag}) {\n    if (isDebugMode) {\n      final prefix = tag != null ? '[$tag] ' : '';\n      print('$prefix$message');\n    }\n  }\n}\n</code></pre>"},{"location":"tools/debugging/#2-conditional-debugging","title":"2. Conditional Debugging","text":"<pre><code>// Only include debug code in debug builds\nif (kDebugMode) {\n  // Debug-only code\n  print('Debug information');\n  debugger();\n}\n\n// Use assert for debug-only checks\nassert(() {\n  print('This only runs in debug mode');\n  return true;\n}());\n</code></pre> <p>Effective debugging requires the right tools and techniques. Use the Flutter Inspector for UI issues, breakpoints for logic problems, and logging for understanding app flow.</p>"},{"location":"tools/development-scripts/","title":"Development Scripts","text":"<p>Collection of useful scripts and automation tools for Flutter development workflow.</p>"},{"location":"tools/development-scripts/#overview","title":"Overview","text":"<p>Development scripts automate repetitive tasks, improve productivity, and ensure consistency across the development team. This guide covers essential scripts for Flutter projects.</p>"},{"location":"tools/development-scripts/#build-scripts","title":"Build Scripts","text":""},{"location":"tools/development-scripts/#1-build-automation","title":"1. Build Automation","text":"<pre><code>#!/bin/bash\n# scripts/build.sh\n\nset -e\n\necho \"\ud83d\ude80 Starting Flutter build process...\"\n\n# Clean previous builds\necho \"\ud83e\uddf9 Cleaning previous builds...\"\nflutter clean\nflutter pub get\n\n# Run code generation\necho \"\ud83d\udd27 Running code generation...\"\nflutter packages pub run build_runner build --delete-conflicting-outputs\n\n# Run tests\necho \"\ud83e\uddea Running tests...\"\nflutter test\n\n# Build for different platforms\necho \"\ud83d\udcf1 Building for platforms...\"\n\n# Android\necho \"Building Android APK...\"\nflutter build apk --release\n\necho \"Building Android App Bundle...\"\nflutter build appbundle --release\n\n# iOS (only on macOS)\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n    echo \"Building iOS...\"\n    flutter build ios --release --no-codesign\nfi\n\n# Web\necho \"Building Web...\"\nflutter build web --release\n\necho \"\u2705 Build process completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-development-build","title":"2. Development Build","text":"<pre><code>#!/bin/bash\n# scripts/dev-build.sh\n\necho \"\ud83d\udd27 Development build starting...\"\n\n# Install dependencies\nflutter pub get\n\n# Generate code\nflutter packages pub run build_runner build\n\n# Run in debug mode\nflutter run --debug\n\necho \"\u2705 Development build ready!\"\n</code></pre>"},{"location":"tools/development-scripts/#testing-scripts","title":"Testing Scripts","text":""},{"location":"tools/development-scripts/#1-comprehensive-test-runner","title":"1. Comprehensive Test Runner","text":"<pre><code>#!/bin/bash\n# scripts/test.sh\n\nset -e\n\necho \"\ud83e\uddea Running comprehensive test suite...\"\n\n# Unit tests\necho \"Running unit tests...\"\nflutter test test/unit/ --coverage\n\n# Widget tests\necho \"Running widget tests...\"\nflutter test test/widget/\n\n# Integration tests\necho \"Running integration tests...\"\nflutter test integration_test/\n\n# Generate coverage report\necho \"Generating coverage report...\"\ngenhtml coverage/lcov.info -o coverage/html\n\necho \"\u2705 All tests completed!\"\necho \"\ud83d\udcca Coverage report available at coverage/html/index.html\"\n</code></pre>"},{"location":"tools/development-scripts/#2-quick-test-script","title":"2. Quick Test Script","text":"<pre><code>#!/bin/bash\n# scripts/quick-test.sh\n\n# Run only unit tests for quick feedback\nflutter test test/unit/ --reporter=compact\n\necho \"\u2705 Quick tests completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#code-quality-scripts","title":"Code Quality Scripts","text":""},{"location":"tools/development-scripts/#1-linting-and-formatting","title":"1. Linting and Formatting","text":"<pre><code>#!/bin/bash\n# scripts/lint.sh\n\necho \"\ud83d\udd0d Running code quality checks...\"\n\n# Format code\necho \"Formatting code...\"\ndart format lib/ test/ --set-exit-if-changed\n\n# Analyze code\necho \"Analyzing code...\"\nflutter analyze\n\n# Check for unused dependencies\necho \"Checking for unused dependencies...\"\nflutter pub deps\n\necho \"\u2705 Code quality checks completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-pre-commit-hook","title":"2. Pre-commit Hook","text":"<pre><code>#!/bin/bash\n# scripts/pre-commit.sh\n\necho \"\ud83d\udd12 Running pre-commit checks...\"\n\n# Format code\ndart format lib/ test/ --set-exit-if-changed\nif [ $? -ne 0 ]; then\n    echo \"\u274c Code formatting failed\"\n    exit 1\nfi\n\n# Analyze code\nflutter analyze\nif [ $? -ne 0 ]; then\n    echo \"\u274c Code analysis failed\"\n    exit 1\nfi\n\n# Run quick tests\nflutter test test/unit/ --reporter=compact\nif [ $? -ne 0 ]; then\n    echo \"\u274c Tests failed\"\n    exit 1\nfi\n\necho \"\u2705 Pre-commit checks passed!\"\n</code></pre>"},{"location":"tools/development-scripts/#asset-management-scripts","title":"Asset Management Scripts","text":""},{"location":"tools/development-scripts/#1-asset-generation","title":"1. Asset Generation","text":"<pre><code>#!/bin/bash\n# scripts/generate-assets.sh\n\necho \"\ud83c\udfa8 Generating app assets...\"\n\n# Generate app icons\nflutter pub run flutter_launcher_icons:main\n\n# Generate splash screens\nflutter pub run flutter_native_splash:create\n\n# Generate localization files\nflutter gen-l10n\n\necho \"\u2705 Assets generated successfully!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-image-optimization","title":"2. Image Optimization","text":"<pre><code>#!/bin/bash\n# scripts/optimize-images.sh\n\necho \"\ud83d\uddbc\ufe0f Optimizing images...\"\n\n# Find and optimize PNG files\nfind assets/images -name \"*.png\" -exec pngquant --force --ext .png {} \\;\n\n# Find and optimize JPEG files\nfind assets/images -name \"*.jpg\" -exec jpegoptim --max=85 {} \\;\n\necho \"\u2705 Image optimization completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#database-scripts","title":"Database Scripts","text":""},{"location":"tools/development-scripts/#1-database-migration","title":"1. Database Migration","text":"<pre><code>#!/bin/bash\n# scripts/migrate-db.sh\n\necho \"\ud83d\uddc4\ufe0f Running database migrations...\"\n\n# Run Supabase migrations\nsupabase db reset\n\n# Seed database with test data\nsupabase db seed\n\necho \"\u2705 Database migration completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-database-backup","title":"2. Database Backup","text":"<pre><code>#!/bin/bash\n# scripts/backup-db.sh\n\nBACKUP_DIR=\"backups\"\nTIMESTAMP=$(date +\"%Y%m%d_%H%M%S\")\nBACKUP_FILE=\"$BACKUP_DIR/db_backup_$TIMESTAMP.sql\"\n\necho \"\ud83d\udcbe Creating database backup...\"\n\nmkdir -p $BACKUP_DIR\n\n# Create backup\nsupabase db dump &gt; $BACKUP_FILE\n\necho \"\u2705 Database backup created: $BACKUP_FILE\"\n</code></pre>"},{"location":"tools/development-scripts/#deployment-scripts","title":"Deployment Scripts","text":""},{"location":"tools/development-scripts/#1-production-deployment","title":"1. Production Deployment","text":"<pre><code>#!/bin/bash\n# scripts/deploy-prod.sh\n\nset -e\n\necho \"\ud83d\ude80 Starting production deployment...\"\n\n# Ensure we're on main branch\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\nif [ \"$BRANCH\" != \"main\" ]; then\n    echo \"\u274c Must be on main branch for production deployment\"\n    exit 1\nfi\n\n# Ensure working directory is clean\nif [ -n \"$(git status --porcelain)\" ]; then\n    echo \"\u274c Working directory must be clean\"\n    exit 1\nfi\n\n# Run tests\n./scripts/test.sh\n\n# Build production assets\n./scripts/build.sh\n\n# Deploy to app stores (placeholder)\necho \"\ud83d\udcf1 Deploying to app stores...\"\n# Add actual deployment commands here\n\necho \"\u2705 Production deployment completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-staging-deployment","title":"2. Staging Deployment","text":"<pre><code>#!/bin/bash\n# scripts/deploy-staging.sh\n\necho \"\ud83c\udfad Deploying to staging...\"\n\n# Build for staging\nflutter build web --dart-define=ENVIRONMENT=staging\n\n# Deploy to staging server\n# Add your staging deployment commands here\n\necho \"\u2705 Staging deployment completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#development-utilities","title":"Development Utilities","text":""},{"location":"tools/development-scripts/#1-project-setup","title":"1. Project Setup","text":"<pre><code>#!/bin/bash\n# scripts/setup.sh\n\necho \"\u2699\ufe0f Setting up Flutter project...\"\n\n# Install Flutter dependencies\nflutter pub get\n\n# Install development tools\ndart pub global activate flutter_gen\ndart pub global activate build_runner\n\n# Generate initial code\nflutter packages pub run build_runner build\n\n# Setup git hooks\ncp scripts/pre-commit.sh .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit\n\n# Create necessary directories\nmkdir -p coverage\nmkdir -p logs\nmkdir -p backups\n\necho \"\u2705 Project setup completed!\"\necho \"\ud83c\udf89 You're ready to start developing!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-clean-reset","title":"2. Clean Reset","text":"<pre><code>#!/bin/bash\n# scripts/clean-reset.sh\n\necho \"\ud83e\uddf9 Performing clean reset...\"\n\n# Flutter clean\nflutter clean\n\n# Remove generated files\nrm -rf .dart_tool/\nrm -rf build/\nrm -rf coverage/\n\n# Remove pub cache\nflutter pub cache repair\n\n# Reinstall dependencies\nflutter pub get\n\n# Regenerate code\nflutter packages pub run build_runner build --delete-conflicting-outputs\n\necho \"\u2705 Clean reset completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#monitoring-scripts","title":"Monitoring Scripts","text":""},{"location":"tools/development-scripts/#1-performance-monitoring","title":"1. Performance Monitoring","text":"<pre><code>#!/bin/bash\n# scripts/monitor-performance.sh\n\necho \"\ud83d\udcca Running performance monitoring...\"\n\n# Build profile version\nflutter build apk --profile\n\n# Run performance tests\nflutter drive --target=test_driver/performance_test.dart --profile\n\necho \"\u2705 Performance monitoring completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-bundle-size-analysis","title":"2. Bundle Size Analysis","text":"<pre><code>#!/bin/bash\n# scripts/analyze-bundle.sh\n\necho \"\ud83d\udce6 Analyzing bundle size...\"\n\n# Build release version\nflutter build apk --analyze-size\n\n# Generate size analysis\nflutter build apk --target-platform android-arm64 --analyze-size\n\necho \"\u2705 Bundle size analysis completed!\"\n</code></pre>"},{"location":"tools/development-scripts/#git-workflow-scripts","title":"Git Workflow Scripts","text":""},{"location":"tools/development-scripts/#1-feature-branch-creation","title":"1. Feature Branch Creation","text":"<pre><code>#!/bin/bash\n# scripts/create-feature.sh\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: ./scripts/create-feature.sh &lt;feature-name&gt;\"\n    exit 1\nfi\n\nFEATURE_NAME=$1\nBRANCH_NAME=\"feature/$FEATURE_NAME\"\n\necho \"\ud83c\udf3f Creating feature branch: $BRANCH_NAME\"\n\n# Create and switch to feature branch\ngit checkout -b $BRANCH_NAME\n\n# Push branch to remote\ngit push -u origin $BRANCH_NAME\n\necho \"\u2705 Feature branch created and pushed!\"\n</code></pre>"},{"location":"tools/development-scripts/#2-release-preparation","title":"2. Release Preparation","text":"<pre><code>#!/bin/bash\n# scripts/prepare-release.sh\n\nif [ -z \"$1\" ]; then\n    echo \"Usage: ./scripts/prepare-release.sh &lt;version&gt;\"\n    exit 1\nfi\n\nVERSION=$1\n\necho \"\ud83c\udff7\ufe0f Preparing release $VERSION...\"\n\n# Update version in pubspec.yaml\nsed -i \"s/version: .*/version: $VERSION/\" pubspec.yaml\n\n# Run tests\n./scripts/test.sh\n\n# Build release\n./scripts/build.sh\n\n# Create git tag\ngit add pubspec.yaml\ngit commit -m \"Bump version to $VERSION\"\ngit tag -a \"v$VERSION\" -m \"Release version $VERSION\"\n\necho \"\u2705 Release $VERSION prepared!\"\necho \"\ud83d\udcdd Don't forget to push: git push origin main --tags\"\n</code></pre>"},{"location":"tools/development-scripts/#makefile-integration","title":"Makefile Integration","text":"<pre><code># Makefile\n\n.PHONY: setup build test clean deploy\n\nsetup:\n    @./scripts/setup.sh\n\nbuild:\n    @./scripts/build.sh\n\ntest:\n    @./scripts/test.sh\n\nclean:\n    @./scripts/clean-reset.sh\n\nlint:\n    @./scripts/lint.sh\n\ndeploy-staging:\n    @./scripts/deploy-staging.sh\n\ndeploy-prod:\n    @./scripts/deploy-prod.sh\n\ndev:\n    @./scripts/dev-build.sh\n\nassets:\n    @./scripts/generate-assets.sh\n\nhelp:\n    @echo \"Available commands:\"\n    @echo \"  setup         - Set up the project\"\n    @echo \"  build         - Build the application\"\n    @echo \"  test          - Run all tests\"\n    @echo \"  clean         - Clean and reset project\"\n    @echo \"  lint          - Run linting and formatting\"\n    @echo \"  deploy-staging - Deploy to staging\"\n    @echo \"  deploy-prod   - Deploy to production\"\n    @echo \"  dev           - Start development build\"\n    @echo \"  assets        - Generate app assets\"\n</code></pre>"},{"location":"tools/development-scripts/#packagejson-scripts-for-web-developers","title":"Package.json Scripts (for web developers)","text":"<pre><code>{\n  \"scripts\": {\n    \"setup\": \"./scripts/setup.sh\",\n    \"build\": \"./scripts/build.sh\",\n    \"test\": \"./scripts/test.sh\",\n    \"dev\": \"./scripts/dev-build.sh\",\n    \"clean\": \"./scripts/clean-reset.sh\",\n    \"lint\": \"./scripts/lint.sh\",\n    \"deploy:staging\": \"./scripts/deploy-staging.sh\",\n    \"deploy:prod\": \"./scripts/deploy-prod.sh\"\n  }\n}\n</code></pre>"},{"location":"tools/development-scripts/#script-management-best-practices","title":"Script Management Best Practices","text":""},{"location":"tools/development-scripts/#1-script-organization","title":"1. Script Organization","text":"<pre><code>scripts/\n\u251c\u2500\u2500 build.sh\n\u251c\u2500\u2500 test.sh\n\u251c\u2500\u2500 deploy-prod.sh\n\u251c\u2500\u2500 deploy-staging.sh\n\u251c\u2500\u2500 setup.sh\n\u251c\u2500\u2500 clean-reset.sh\n\u251c\u2500\u2500 lint.sh\n\u251c\u2500\u2500 pre-commit.sh\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 common.sh\n\u2502   \u2514\u2500\u2500 colors.sh\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"tools/development-scripts/#2-common-utilities","title":"2. Common Utilities","text":"<pre><code># scripts/utils/common.sh\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Logging functions\nlog_info() {\n    echo -e \"${BLUE}\u2139\ufe0f  $1${NC}\"\n}\n\nlog_success() {\n    echo -e \"${GREEN}\u2705 $1${NC}\"\n}\n\nlog_warning() {\n    echo -e \"${YELLOW}\u26a0\ufe0f  $1${NC}\"\n}\n\nlog_error() {\n    echo -e \"${RED}\u274c $1${NC}\"\n}\n\n# Check if command exists\ncommand_exists() {\n    command -v \"$1\" &gt;/dev/null 2&gt;&amp;1\n}\n\n# Check Flutter installation\ncheck_flutter() {\n    if ! command_exists flutter; then\n        log_error \"Flutter is not installed\"\n        exit 1\n    fi\n}\n</code></pre> <p>Development scripts are essential for maintaining a productive Flutter development workflow. Start with basic build and test scripts, then expand based on your team's needs.</p>"},{"location":"tools/performance/","title":"Performance Optimization","text":"<p>Comprehensive guide to optimizing Flutter application performance for smooth user experiences.</p>"},{"location":"tools/performance/#overview","title":"Overview","text":"<p>Performance optimization is crucial for creating responsive Flutter applications. This guide covers profiling tools, optimization techniques, and best practices for maintaining high performance.</p>"},{"location":"tools/performance/#performance-profiling","title":"Performance Profiling","text":""},{"location":"tools/performance/#1-flutter-performance-tools","title":"1. Flutter Performance Tools","text":"<pre><code>// lib/utils/performance_monitor.dart\nimport 'dart:developer' as developer;\n\nclass PerformanceMonitor {\n  static void startTrace(String name) {\n    developer.Timeline.startSync(name);\n  }\n\n  static void endTrace() {\n    developer.Timeline.finishSync();\n  }\n\n  static Future&lt;T&gt; traceAsync&lt;T&gt;(String name, Future&lt;T&gt; Function() operation) async {\n    developer.Timeline.startSync(name);\n    try {\n      return await operation();\n    } finally {\n      developer.Timeline.finishSync();\n    }\n  }\n\n  static T traceSync&lt;T&gt;(String name, T Function() operation) {\n    developer.Timeline.startSync(name);\n    try {\n      return operation();\n    } finally {\n      developer.Timeline.finishSync();\n    }\n  }\n}\n\n// Usage\nfinal result = await PerformanceMonitor.traceAsync('API Call', () async {\n  return await apiClient.getData();\n});\n</code></pre>"},{"location":"tools/performance/#2-performance-overlay","title":"2. Performance Overlay","text":"<pre><code>// lib/main.dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // Enable performance overlay in debug mode\n      showPerformanceOverlay: kDebugMode,\n      // Show semantic debugger\n      showSemanticsDebugger: false,\n      home: HomeScreen(),\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#3-memory-profiling","title":"3. Memory Profiling","text":"<pre><code>// lib/utils/memory_profiler.dart\nimport 'dart:developer' as developer;\n\nclass MemoryProfiler {\n  static void logMemoryUsage(String label) {\n    if (kDebugMode) {\n      developer.postEvent('memory_usage', {\n        'label': label,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n      });\n    }\n  }\n\n  static void trackAllocation(String objectType) {\n    if (kDebugMode) {\n      developer.postEvent('object_allocation', {\n        'type': objectType,\n        'timestamp': DateTime.now().millisecondsSinceEpoch,\n      });\n    }\n  }\n}\n</code></pre>"},{"location":"tools/performance/#widget-performance","title":"Widget Performance","text":""},{"location":"tools/performance/#1-efficient-widget-building","title":"1. Efficient Widget Building","text":"<pre><code>// lib/widgets/optimized_list_item.dart\nclass OptimizedListItem extends StatelessWidget {\n  final String title;\n  final String subtitle;\n  final VoidCallback onTap;\n\n  const OptimizedListItem({\n    Key? key,\n    required this.title,\n    required this.subtitle,\n    required this.onTap,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: ListTile(\n        title: Text(title),\n        subtitle: Text(subtitle),\n        onTap: onTap,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-const-constructors","title":"2. Const Constructors","text":"<pre><code>// lib/widgets/performance_optimized_widgets.dart\nclass OptimizedContainer extends StatelessWidget {\n  final Widget child;\n  final Color? color;\n  final EdgeInsets? padding;\n\n  // Use const constructor\n  const OptimizedContainer({\n    Key? key,\n    required this.child,\n    this.color,\n    this.padding,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: color,\n      padding: padding,\n      child: child,\n    );\n  }\n}\n\n// Usage with const\nconst OptimizedContainer(\n  color: Colors.blue,\n  padding: EdgeInsets.all(16.0),\n  child: Text('Optimized Widget'),\n)\n</code></pre>"},{"location":"tools/performance/#3-widget-separation","title":"3. Widget Separation","text":"<pre><code>// lib/widgets/separated_widgets.dart\nclass ExpensiveWidget extends StatelessWidget {\n  const ExpensiveWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Expensive widget that doesn't need to rebuild\n    return Container(\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: [Colors.blue, Colors.purple],\n        ),\n      ),\n      child: const Text('Expensive Content'),\n    );\n  }\n}\n\nclass ParentWidget extends StatefulWidget {\n  @override\n  _ParentWidgetState createState() =&gt; _ParentWidgetState();\n}\n\nclass _ParentWidgetState extends State&lt;ParentWidget&gt; {\n  int counter = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text('Counter: $counter'),\n        ElevatedButton(\n          onPressed: () =&gt; setState(() =&gt; counter++),\n          child: Text('Increment'),\n        ),\n        // Separate expensive widget to avoid rebuilds\n        const ExpensiveWidget(),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#list-performance","title":"List Performance","text":""},{"location":"tools/performance/#1-efficient-list-building","title":"1. Efficient List Building","text":"<pre><code>// lib/widgets/optimized_list.dart\nclass OptimizedList extends StatelessWidget {\n  final List&lt;String&gt; items;\n\n  const OptimizedList({Key? key, required this.items}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      // Use itemExtent for fixed-height items\n      itemExtent: 60.0,\n      itemCount: items.length,\n      itemBuilder: (context, index) {\n        final item = items[index];\n        return RepaintBoundary(\n          child: ListTile(\n            key: ValueKey(item),\n            title: Text(item),\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-lazy-loading","title":"2. Lazy Loading","text":"<pre><code>// lib/widgets/lazy_list.dart\nclass LazyList extends StatefulWidget {\n  @override\n  _LazyListState createState() =&gt; _LazyListState();\n}\n\nclass _LazyListState extends State&lt;LazyList&gt; {\n  final List&lt;String&gt; items = [];\n  bool isLoading = false;\n  final ScrollController scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    loadInitialItems();\n    scrollController.addListener(onScroll);\n  }\n\n  void loadInitialItems() {\n    setState(() {\n      items.addAll(List.generate(20, (index) =&gt; 'Item $index'));\n    });\n  }\n\n  void onScroll() {\n    if (scrollController.position.pixels &gt;= \n        scrollController.position.maxScrollExtent - 200) {\n      loadMoreItems();\n    }\n  }\n\n  Future&lt;void&gt; loadMoreItems() async {\n    if (isLoading) return;\n\n    setState(() =&gt; isLoading = true);\n\n    // Simulate network delay\n    await Future.delayed(Duration(seconds: 1));\n\n    setState(() {\n      final startIndex = items.length;\n      items.addAll(List.generate(20, (index) =&gt; 'Item ${startIndex + index}'));\n      isLoading = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      controller: scrollController,\n      itemCount: items.length + (isLoading ? 1 : 0),\n      itemBuilder: (context, index) {\n        if (index == items.length) {\n          return const Center(child: CircularProgressIndicator());\n        }\n\n        return ListTile(\n          title: Text(items[index]),\n        );\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    scrollController.dispose();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"tools/performance/#3-virtual-scrolling","title":"3. Virtual Scrolling","text":"<pre><code>// lib/widgets/virtual_scroll_list.dart\nclass VirtualScrollList extends StatelessWidget {\n  final List&lt;String&gt; items;\n  final double itemHeight;\n\n  const VirtualScrollList({\n    Key? key,\n    required this.items,\n    this.itemHeight = 60.0,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemExtent: itemHeight,\n      itemCount: items.length,\n      cacheExtent: itemHeight * 10, // Cache 10 items\n      itemBuilder: (context, index) {\n        return RepaintBoundary(\n          child: Container(\n            height: itemHeight,\n            child: ListTile(\n              title: Text(items[index]),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#image-performance","title":"Image Performance","text":""},{"location":"tools/performance/#1-image-optimization","title":"1. Image Optimization","text":"<pre><code>// lib/widgets/optimized_image.dart\nclass OptimizedImage extends StatelessWidget {\n  final String imageUrl;\n  final double? width;\n  final double? height;\n  final BoxFit fit;\n\n  const OptimizedImage({\n    Key? key,\n    required this.imageUrl,\n    this.width,\n    this.height,\n    this.fit = BoxFit.cover,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Image.network(\n      imageUrl,\n      width: width,\n      height: height,\n      fit: fit,\n      // Use caching\n      cacheWidth: width?.round(),\n      cacheHeight: height?.round(),\n      // Loading and error builders\n      loadingBuilder: (context, child, loadingProgress) {\n        if (loadingProgress == null) return child;\n        return SizedBox(\n          width: width,\n          height: height,\n          child: Center(\n            child: CircularProgressIndicator(\n              value: loadingProgress.expectedTotalBytes != null\n                  ? loadingProgress.cumulativeBytesLoaded /\n                      loadingProgress.expectedTotalBytes!\n                  : null,\n            ),\n          ),\n        );\n      },\n      errorBuilder: (context, error, stackTrace) {\n        return Container(\n          width: width,\n          height: height,\n          color: Colors.grey[300],\n          child: Icon(Icons.error),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-image-caching","title":"2. Image Caching","text":"<pre><code>// lib/services/image_cache_service.dart\nclass ImageCacheService {\n  static final Map&lt;String, ui.Image&gt; _cache = {};\n\n  static Future&lt;ui.Image?&gt; getCachedImage(String url) async {\n    if (_cache.containsKey(url)) {\n      return _cache[url];\n    }\n\n    try {\n      final response = await http.get(Uri.parse(url));\n      final bytes = response.bodyBytes;\n      final codec = await ui.instantiateImageCodec(bytes);\n      final frame = await codec.getNextFrame();\n\n      _cache[url] = frame.image;\n      return frame.image;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  static void clearCache() {\n    _cache.clear();\n  }\n\n  static void removeCachedImage(String url) {\n    _cache.remove(url);\n  }\n}\n</code></pre>"},{"location":"tools/performance/#animation-performance","title":"Animation Performance","text":""},{"location":"tools/performance/#1-efficient-animations","title":"1. Efficient Animations","text":"<pre><code>// lib/widgets/optimized_animation.dart\nclass OptimizedAnimation extends StatefulWidget {\n  @override\n  _OptimizedAnimationState createState() =&gt; _OptimizedAnimationState();\n}\n\nclass _OptimizedAnimationState extends State&lt;OptimizedAnimation&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController controller;\n  late Animation&lt;double&gt; animation;\n\n  @override\n  void initState() {\n    super.initState();\n    controller = AnimationController(\n      duration: Duration(milliseconds: 300),\n      vsync: this,\n    );\n\n    animation = Tween&lt;double&gt;(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(parent: controller, curve: Curves.easeInOut),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: AnimatedBuilder(\n        animation: animation,\n        builder: (context, child) {\n          return Transform.scale(\n            scale: animation.value,\n            child: child,\n          );\n        },\n        // Use child parameter to avoid rebuilding static content\n        child: Container(\n          width: 100,\n          height: 100,\n          color: Colors.blue,\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-animation-optimization","title":"2. Animation Optimization","text":"<pre><code>// lib/utils/animation_utils.dart\nclass AnimationUtils {\n  // Use Transform instead of changing widget properties\n  static Widget createOptimizedTransition({\n    required Widget child,\n    required Animation&lt;double&gt; animation,\n  }) {\n    return AnimatedBuilder(\n      animation: animation,\n      builder: (context, _) {\n        return Transform.translate(\n          offset: Offset(animation.value * 100, 0),\n          child: child,\n        );\n      },\n      child: child,\n    );\n  }\n\n  // Batch animations to reduce rebuilds\n  static Widget createBatchedAnimation({\n    required Widget child,\n    required Animation&lt;double&gt; scaleAnimation,\n    required Animation&lt;double&gt; opacityAnimation,\n  }) {\n    return AnimatedBuilder(\n      animation: Listenable.merge([scaleAnimation, opacityAnimation]),\n      builder: (context, _) {\n        return Transform.scale(\n          scale: scaleAnimation.value,\n          child: Opacity(\n            opacity: opacityAnimation.value,\n            child: child,\n          ),\n        );\n      },\n      child: child,\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#state-management-performance","title":"State Management Performance","text":""},{"location":"tools/performance/#1-efficient-state-updates","title":"1. Efficient State Updates","text":"<pre><code>// lib/providers/optimized_provider.dart\nclass OptimizedProvider extends ChangeNotifier {\n  List&lt;String&gt; _items = [];\n  bool _isLoading = false;\n\n  List&lt;String&gt; get items =&gt; List.unmodifiable(_items);\n  bool get isLoading =&gt; _isLoading;\n\n  // Batch updates to reduce notifications\n  void updateItems(List&lt;String&gt; newItems) {\n    _items = newItems;\n    _isLoading = false;\n    // Single notification for multiple changes\n    notifyListeners();\n  }\n\n  // Use specific update methods\n  void addItem(String item) {\n    _items.add(item);\n    notifyListeners();\n  }\n\n  void removeItem(int index) {\n    if (index &gt;= 0 &amp;&amp; index &lt; _items.length) {\n      _items.removeAt(index);\n      notifyListeners();\n    }\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-selective-rebuilds","title":"2. Selective Rebuilds","text":"<pre><code>// lib/widgets/selective_rebuild.dart\nclass SelectiveRebuildWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        // Only rebuild when counter changes\n        Consumer&lt;CounterProvider&gt;(\n          builder: (context, counter, child) {\n            return Text('Counter: ${counter.value}');\n          },\n        ),\n        // Static widget that never rebuilds\n        const StaticWidget(),\n        // Only rebuild when user changes\n        Selector&lt;UserProvider, String&gt;(\n          selector: (context, userProvider) =&gt; userProvider.user.name,\n          builder: (context, userName, child) {\n            return Text('User: $userName');\n          },\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#network-performance","title":"Network Performance","text":""},{"location":"tools/performance/#1-request-optimization","title":"1. Request Optimization","text":"<pre><code>// lib/services/optimized_api_client.dart\nclass OptimizedApiClient {\n  final Dio _dio;\n  final Map&lt;String, dynamic&gt; _cache = {};\n\n  OptimizedApiClient() : _dio = Dio() {\n    _dio.interceptors.add(InterceptorsWrapper(\n      onRequest: (options, handler) {\n        // Add caching headers\n        options.headers['Cache-Control'] = 'max-age=300';\n        handler.next(options);\n      },\n    ));\n  }\n\n  Future&lt;T&gt; get&lt;T&gt;(\n    String path, {\n    bool useCache = true,\n    Duration cacheDuration = const Duration(minutes: 5),\n  }) async {\n    final cacheKey = path;\n\n    if (useCache &amp;&amp; _cache.containsKey(cacheKey)) {\n      final cachedData = _cache[cacheKey];\n      if (DateTime.now().difference(cachedData['timestamp']) &lt; cacheDuration) {\n        return cachedData['data'] as T;\n      }\n    }\n\n    final response = await _dio.get(path);\n\n    if (useCache) {\n      _cache[cacheKey] = {\n        'data': response.data,\n        'timestamp': DateTime.now(),\n      };\n    }\n\n    return response.data as T;\n  }\n}\n</code></pre>"},{"location":"tools/performance/#2-image-loading-optimization","title":"2. Image Loading Optimization","text":"<pre><code>// lib/widgets/progressive_image.dart\nclass ProgressiveImage extends StatefulWidget {\n  final String imageUrl;\n  final String? thumbnailUrl;\n\n  const ProgressiveImage({\n    Key? key,\n    required this.imageUrl,\n    this.thumbnailUrl,\n  }) : super(key: key);\n\n  @override\n  _ProgressiveImageState createState() =&gt; _ProgressiveImageState();\n}\n\nclass _ProgressiveImageState extends State&lt;ProgressiveImage&gt; {\n  bool _isFullImageLoaded = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        // Show thumbnail first\n        if (widget.thumbnailUrl != null)\n          Image.network(\n            widget.thumbnailUrl!,\n            fit: BoxFit.cover,\n          ),\n        // Load full image\n        Image.network(\n          widget.imageUrl,\n          fit: BoxFit.cover,\n          loadingBuilder: (context, child, loadingProgress) {\n            if (loadingProgress == null) {\n              _isFullImageLoaded = true;\n              return child;\n            }\n            return Container();\n          },\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"tools/performance/#performance-testing","title":"Performance Testing","text":""},{"location":"tools/performance/#1-performance-benchmarks","title":"1. Performance Benchmarks","text":"<pre><code>// test/performance/widget_performance_test.dart\nvoid main() {\n  group('Widget Performance Tests', () {\n    testWidgets('list scrolling performance', (tester) async {\n      final items = List.generate(1000, (index) =&gt; 'Item $index');\n\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(\n          body: OptimizedList(items: items),\n        ),\n      ));\n\n      // Measure scroll performance\n      final stopwatch = Stopwatch()..start();\n\n      await tester.fling(\n        find.byType(ListView),\n        const Offset(0, -500),\n        1000,\n      );\n\n      await tester.pumpAndSettle();\n      stopwatch.stop();\n\n      expect(stopwatch.elapsedMilliseconds, lessThan(100));\n    });\n  });\n}\n</code></pre>"},{"location":"tools/performance/#2-memory-leak-detection","title":"2. Memory Leak Detection","text":"<pre><code>// test/performance/memory_test.dart\nvoid main() {\n  group('Memory Tests', () {\n    test('should not leak memory', () async {\n      final initialMemory = _getMemoryUsage();\n\n      // Create and dispose widgets multiple times\n      for (int i = 0; i &lt; 100; i++) {\n        final widget = ExpensiveWidget();\n        // Simulate widget lifecycle\n        await Future.delayed(Duration.zero);\n      }\n\n      // Force garbage collection\n      await Future.delayed(Duration(seconds: 1));\n\n      final finalMemory = _getMemoryUsage();\n      final memoryIncrease = finalMemory - initialMemory;\n\n      expect(memoryIncrease, lessThan(1024 * 1024)); // Less than 1MB\n    });\n  });\n}\n\nint _getMemoryUsage() {\n  // Platform-specific memory usage implementation\n  return 0; // Placeholder\n}\n</code></pre> <p>Performance optimization is an ongoing process. Profile regularly, optimize bottlenecks, and always measure the impact of your optimizations.</p>"},{"location":"tools/testing/","title":"Testing Guide","text":"<p>Comprehensive testing strategies for Flutter applications including unit tests, widget tests, integration tests, and golden tests.</p>"},{"location":"tools/testing/#overview","title":"Overview","text":"<p>Testing is crucial for maintaining code quality and preventing regressions. Flutter provides excellent testing tools and frameworks for comprehensive test coverage.</p>"},{"location":"tools/testing/#test-types","title":"Test Types","text":""},{"location":"tools/testing/#1-unit-tests","title":"1. Unit Tests","text":"<p>Test individual functions, methods, and classes in isolation.</p> <pre><code>// test/unit/user_service_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:mockito/annotations.dart';\n\n@GenerateMocks([ApiClient])\nimport 'user_service_test.mocks.dart';\n\nvoid main() {\n  group('UserService Tests', () {\n    late UserService userService;\n    late MockApiClient mockApiClient;\n\n    setUp(() {\n      mockApiClient = MockApiClient();\n      userService = UserService(apiClient: mockApiClient);\n    });\n\n    test('should return user when API call is successful', () async {\n      // Arrange\n      final userData = {'id': '1', 'name': 'John Doe', 'email': 'john@example.com'};\n      when(mockApiClient.get('/users/1')).thenAnswer((_) async =&gt; userData);\n\n      // Act\n      final user = await userService.getUser('1');\n\n      // Assert\n      expect(user.id, '1');\n      expect(user.name, 'John Doe');\n      expect(user.email, 'john@example.com');\n      verify(mockApiClient.get('/users/1')).called(1);\n    });\n\n    test('should throw exception when API call fails', () async {\n      // Arrange\n      when(mockApiClient.get('/users/1')).thenThrow(Exception('Network error'));\n\n      // Act &amp; Assert\n      expect(() =&gt; userService.getUser('1'), throwsException);\n    });\n  });\n}\n</code></pre>"},{"location":"tools/testing/#2-widget-tests","title":"2. Widget Tests","text":"<p>Test individual widgets and their interactions.</p> <pre><code>// test/widget/login_form_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('LoginForm Widget Tests', () {\n    testWidgets('should show validation error for empty email', (tester) async {\n      // Arrange\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(body: LoginForm()),\n      ));\n\n      // Act\n      await tester.tap(find.byType(ElevatedButton));\n      await tester.pump();\n\n      // Assert\n      expect(find.text('Email is required'), findsOneWidget);\n    });\n\n    testWidgets('should call onSubmit when form is valid', (tester) async {\n      // Arrange\n      bool submitted = false;\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(\n          body: LoginForm(\n            onSubmit: (email, password) =&gt; submitted = true,\n          ),\n        ),\n      ));\n\n      // Act\n      await tester.enterText(find.byKey(Key('email_field')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password_field')), 'password123');\n      await tester.tap(find.byType(ElevatedButton));\n      await tester.pump();\n\n      // Assert\n      expect(submitted, isTrue);\n    });\n\n    testWidgets('should show loading indicator when submitting', (tester) async {\n      // Arrange\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(\n          body: LoginForm(\n            onSubmit: (email, password) async {\n              await Future.delayed(Duration(seconds: 1));\n            },\n          ),\n        ),\n      ));\n\n      // Act\n      await tester.enterText(find.byKey(Key('email_field')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password_field')), 'password123');\n      await tester.tap(find.byType(ElevatedButton));\n      await tester.pump();\n\n      // Assert\n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"tools/testing/#3-integration-tests","title":"3. Integration Tests","text":"<p>Test complete user flows and app behavior.</p> <pre><code>// integration_test/app_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:myapp/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('App Integration Tests', () {\n    testWidgets('complete login flow', (tester) async {\n      // Start the app\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to login screen\n      await tester.tap(find.text('Login'));\n      await tester.pumpAndSettle();\n\n      // Enter credentials\n      await tester.enterText(find.byKey(Key('email_field')), 'test@example.com');\n      await tester.enterText(find.byKey(Key('password_field')), 'password123');\n\n      // Submit form\n      await tester.tap(find.text('Sign In'));\n      await tester.pumpAndSettle();\n\n      // Verify successful login\n      expect(find.text('Welcome'), findsOneWidget);\n    });\n\n    testWidgets('create and delete post flow', (tester) async {\n      // Assuming user is already logged in\n      app.main();\n      await tester.pumpAndSettle();\n\n      // Navigate to create post\n      await tester.tap(find.byIcon(Icons.add));\n      await tester.pumpAndSettle();\n\n      // Create post\n      await tester.enterText(find.byKey(Key('post_content')), 'Test post content');\n      await tester.tap(find.text('Post'));\n      await tester.pumpAndSettle();\n\n      // Verify post appears in feed\n      expect(find.text('Test post content'), findsOneWidget);\n\n      // Delete post\n      await tester.tap(find.byIcon(Icons.more_vert));\n      await tester.pumpAndSettle();\n      await tester.tap(find.text('Delete'));\n      await tester.pumpAndSettle();\n      await tester.tap(find.text('Confirm'));\n      await tester.pumpAndSettle();\n\n      // Verify post is deleted\n      expect(find.text('Test post content'), findsNothing);\n    });\n  });\n}\n</code></pre>"},{"location":"tools/testing/#4-golden-tests","title":"4. Golden Tests","text":"<p>Test widget appearance and layout.</p> <pre><code>// test/golden/button_golden_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('Button Golden Tests', () {\n    testWidgets('primary button golden test', (tester) async {\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(\n          body: Center(\n            child: ElevatedButton(\n              onPressed: () {},\n              child: Text('Primary Button'),\n            ),\n          ),\n        ),\n      ));\n\n      await expectLater(\n        find.byType(ElevatedButton),\n        matchesGoldenFile('golden/primary_button.png'),\n      );\n    });\n\n    testWidgets('button states golden test', (tester) async {\n      await tester.pumpWidget(MaterialApp(\n        home: Scaffold(\n          body: Column(\n            children: [\n              ElevatedButton(\n                onPressed: () {},\n                child: Text('Enabled'),\n              ),\n              ElevatedButton(\n                onPressed: null,\n                child: Text('Disabled'),\n              ),\n            ],\n          ),\n        ),\n      ));\n\n      await expectLater(\n        find.byType(Scaffold),\n        matchesGoldenFile('golden/button_states.png'),\n      );\n    });\n  });\n}\n</code></pre>"},{"location":"tools/testing/#testing-patterns","title":"Testing Patterns","text":""},{"location":"tools/testing/#1-test-utilities","title":"1. Test Utilities","text":"<pre><code>// test/utils/test_utils.dart\nclass TestUtils {\n  static Widget wrapWithMaterialApp(Widget widget) {\n    return MaterialApp(\n      home: Scaffold(body: widget),\n    );\n  }\n\n  static Widget wrapWithProviders(Widget widget) {\n    return MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) =&gt; MockUserProvider()),\n        ChangeNotifierProvider(create: (_) =&gt; MockThemeProvider()),\n      ],\n      child: wrapWithMaterialApp(widget),\n    );\n  }\n\n  static Future&lt;void&gt; enterTextAndSettle(\n    WidgetTester tester,\n    Finder finder,\n    String text,\n  ) async {\n    await tester.enterText(finder, text);\n    await tester.pumpAndSettle();\n  }\n\n  static Future&lt;void&gt; tapAndSettle(\n    WidgetTester tester,\n    Finder finder,\n  ) async {\n    await tester.tap(finder);\n    await tester.pumpAndSettle();\n  }\n}\n</code></pre>"},{"location":"tools/testing/#2-custom-matchers","title":"2. Custom Matchers","text":"<pre><code>// test/matchers/custom_matchers.dart\nMatcher hasTextStyle(TextStyle expectedStyle) {\n  return _HasTextStyle(expectedStyle);\n}\n\nclass _HasTextStyle extends Matcher {\n  final TextStyle expectedStyle;\n\n  _HasTextStyle(this.expectedStyle);\n\n  @override\n  bool matches(dynamic item, Map matchState) {\n    if (item is! Text) return false;\n\n    final actualStyle = item.style;\n    return actualStyle?.fontSize == expectedStyle.fontSize &amp;&amp;\n           actualStyle?.fontWeight == expectedStyle.fontWeight &amp;&amp;\n           actualStyle?.color == expectedStyle.color;\n  }\n\n  @override\n  Description describe(Description description) {\n    return description.add('has text style $expectedStyle');\n  }\n}\n\n// Usage\nexpect(find.text('Hello'), hasTextStyle(TextStyle(fontSize: 16)));\n</code></pre>"},{"location":"tools/testing/#3-page-object-model","title":"3. Page Object Model","text":"<pre><code>// test/page_objects/login_page.dart\nclass LoginPageObject {\n  final WidgetTester tester;\n\n  LoginPageObject(this.tester);\n\n  Finder get emailField =&gt; find.byKey(Key('email_field'));\n  Finder get passwordField =&gt; find.byKey(Key('password_field'));\n  Finder get loginButton =&gt; find.text('Sign In');\n  Finder get errorMessage =&gt; find.byKey(Key('error_message'));\n\n  Future&lt;void&gt; enterEmail(String email) async {\n    await tester.enterText(emailField, email);\n  }\n\n  Future&lt;void&gt; enterPassword(String password) async {\n    await tester.enterText(passwordField, password);\n  }\n\n  Future&lt;void&gt; tapLogin() async {\n    await tester.tap(loginButton);\n    await tester.pumpAndSettle();\n  }\n\n  Future&lt;void&gt; login(String email, String password) async {\n    await enterEmail(email);\n    await enterPassword(password);\n    await tapLogin();\n  }\n\n  bool get hasErrorMessage =&gt; tester.any(errorMessage);\n}\n\n// Usage in tests\ntestWidgets('login with invalid credentials', (tester) async {\n  await tester.pumpWidget(MyApp());\n\n  final loginPage = LoginPageObject(tester);\n  await loginPage.login('invalid@email.com', 'wrongpassword');\n\n  expect(loginPage.hasErrorMessage, isTrue);\n});\n</code></pre>"},{"location":"tools/testing/#testing-state-management","title":"Testing State Management","text":""},{"location":"tools/testing/#1-testing-riverpod-providers","title":"1. Testing Riverpod Providers","text":"<pre><code>// test/providers/user_provider_test.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('UserProvider Tests', () {\n    test('should load user data', () async {\n      final container = ProviderContainer(\n        overrides: [\n          userRepositoryProvider.overrideWithValue(MockUserRepository()),\n        ],\n      );\n\n      final userNotifier = container.read(userProvider.notifier);\n      await userNotifier.loadUser('123');\n\n      final user = container.read(userProvider);\n      expect(user.value?.id, '123');\n    });\n\n    test('should handle loading states', () async {\n      final container = ProviderContainer();\n\n      // Initial state should be loading\n      expect(container.read(userProvider), const AsyncValue.loading());\n\n      // After loading\n      final userNotifier = container.read(userProvider.notifier);\n      await userNotifier.loadUser('123');\n\n      final user = container.read(userProvider);\n      expect(user.hasValue, isTrue);\n    });\n  });\n}\n</code></pre>"},{"location":"tools/testing/#2-testing-bloc","title":"2. Testing BLoC","text":"<pre><code>// test/blocs/auth_bloc_test.dart\nimport 'package:bloc_test/bloc_test.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('AuthBloc Tests', () {\n    late AuthBloc authBloc;\n    late MockAuthRepository mockAuthRepository;\n\n    setUp(() {\n      mockAuthRepository = MockAuthRepository();\n      authBloc = AuthBloc(authRepository: mockAuthRepository);\n    });\n\n    tearDown(() {\n      authBloc.close();\n    });\n\n    blocTest&lt;AuthBloc, AuthState&gt;(\n      'emits [AuthLoading, AuthAuthenticated] when login succeeds',\n      build: () {\n        when(() =&gt; mockAuthRepository.login(any(), any()))\n            .thenAnswer((_) async =&gt; User(id: '1', email: 'test@example.com'));\n        return authBloc;\n      },\n      act: (bloc) =&gt; bloc.add(AuthLoginRequested('test@example.com', 'password')),\n      expect: () =&gt; [\n        AuthLoading(),\n        AuthAuthenticated(User(id: '1', email: 'test@example.com')),\n      ],\n    );\n\n    blocTest&lt;AuthBloc, AuthState&gt;(\n      'emits [AuthLoading, AuthError] when login fails',\n      build: () {\n        when(() =&gt; mockAuthRepository.login(any(), any()))\n            .thenThrow(Exception('Login failed'));\n        return authBloc;\n      },\n      act: (bloc) =&gt; bloc.add(AuthLoginRequested('test@example.com', 'password')),\n      expect: () =&gt; [\n        AuthLoading(),\n        AuthError('Login failed'),\n      ],\n    );\n  });\n}\n</code></pre>"},{"location":"tools/testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"tools/testing/#1-test-organization","title":"1. Test Organization","text":"<pre><code>// test/test_config.dart\nclass TestConfig {\n  static void setupTests() {\n    // Global test setup\n    setUpAll(() {\n      // Initialize test environment\n    });\n\n    tearDownAll(() {\n      // Cleanup after all tests\n    });\n  }\n}\n\n// Use groups to organize related tests\ngroup('User Management', () {\n  group('User Creation', () {\n    test('should create user with valid data', () {});\n    test('should reject invalid email', () {});\n  });\n\n  group('User Authentication', () {\n    test('should authenticate with correct credentials', () {});\n    test('should reject invalid credentials', () {});\n  });\n});\n</code></pre>"},{"location":"tools/testing/#2-test-data-management","title":"2. Test Data Management","text":"<pre><code>// test/fixtures/test_data.dart\nclass TestData {\n  static const validUser = User(\n    id: '1',\n    email: 'test@example.com',\n    name: 'Test User',\n  );\n\n  static const invalidUser = User(\n    id: '',\n    email: 'invalid-email',\n    name: '',\n  );\n\n  static List&lt;Post&gt; get samplePosts =&gt; [\n    Post(id: '1', content: 'First post', userId: '1'),\n    Post(id: '2', content: 'Second post', userId: '1'),\n  ];\n}\n</code></pre>"},{"location":"tools/testing/#3-mock-management","title":"3. Mock Management","text":"<pre><code>// test/mocks/mock_services.dart\nclass MockUserService extends Mock implements UserService {}\nclass MockApiClient extends Mock implements ApiClient {}\nclass MockStorageService extends Mock implements StorageService {}\n\n// Create a mock factory\nclass MockFactory {\n  static MockUserService createUserService() {\n    final mock = MockUserService();\n    when(mock.getCurrentUser()).thenReturn(TestData.validUser);\n    return mock;\n  }\n}\n</code></pre>"},{"location":"tools/testing/#test-coverage","title":"Test Coverage","text":""},{"location":"tools/testing/#1-coverage-configuration","title":"1. Coverage Configuration","text":"<pre><code># test/coverage_config.yaml\ncoverage:\n  exclude:\n    - '**/*.g.dart'\n    - '**/*.freezed.dart'\n    - '**/main.dart'\n    - 'lib/generated/**'\n</code></pre>"},{"location":"tools/testing/#2-running-coverage","title":"2. Running Coverage","text":"<pre><code># Generate coverage report\nflutter test --coverage\n\n# Generate HTML report\ngenhtml coverage/lcov.info -o coverage/html\n\n# View coverage\nopen coverage/html/index.html\n</code></pre>"},{"location":"tools/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"tools/testing/#1-github-actions","title":"1. GitHub Actions","text":"<pre><code># .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: subosito/flutter-action@v2\n      - run: flutter pub get\n      - run: flutter analyze\n      - run: flutter test --coverage\n      - run: flutter test integration_test/\n</code></pre>"},{"location":"tools/testing/#2-test-scripts","title":"2. Test Scripts","text":"<pre><code>#!/bin/bash\n# scripts/run_tests.sh\n\necho \"Running unit tests...\"\nflutter test\n\necho \"Running widget tests...\"\nflutter test test/widget/\n\necho \"Running integration tests...\"\nflutter test integration_test/\n\necho \"Generating coverage report...\"\nflutter test --coverage\ngenhtml coverage/lcov.info -o coverage/html\n\necho \"Tests completed!\"\n</code></pre> <p>Testing is an investment in code quality and developer confidence. Start with unit tests for business logic, add widget tests for UI components, and use integration tests for critical user flows.</p>"},{"location":"training/project-ideas/","title":"Flutter Project Ideas for Training","text":"<p>A collection of 15+ progressive project ideas to master Flutter development using the Instagram Clone as a foundation.</p>"},{"location":"training/project-ideas/#project-categories","title":"Project Categories","text":""},{"location":"training/project-ideas/#beginner-projects-weeks-1-4","title":"Beginner Projects (Weeks 1-4)","text":"<p>Perfect for learning Flutter basics and core concepts.</p>"},{"location":"training/project-ideas/#intermediate-projects-weeks-5-8","title":"Intermediate Projects (Weeks 5-8)","text":"<p>Build on fundamentals with more complex features and integrations.</p>"},{"location":"training/project-ideas/#advanced-projects-weeks-9-12","title":"Advanced Projects (Weeks 9-12)","text":"<p>Production-ready applications with advanced features and optimizations.</p>"},{"location":"training/project-ideas/#beginner-projects","title":"Beginner Projects","text":""},{"location":"training/project-ideas/#1-personal-portfolio-app","title":"1. Personal Portfolio App","text":"<p>Duration: 3-5 days | Difficulty: \u2b50\u2b50\u2606\u2606\u2606</p> <p>Build a personal portfolio showcasing your skills and projects.</p> <p>Core Features: - About me section with photo and bio - Skills showcase with progress indicators - Project gallery with descriptions - Contact information and social links - Dark/light theme toggle</p> <p>Learning Goals: - Basic widget composition - Asset management (images, fonts) - Navigation between screens - Theme implementation - Responsive layouts</p> <p>Instagram Clone Concepts Used: - Profile screen layout - Image display and handling - Theme switching - Basic navigation structure</p>"},{"location":"training/project-ideas/#2-recipe-book-app","title":"2. Recipe Book App","text":"<p>Duration: 5-7 days | Difficulty: \u2b50\u2b50\u2606\u2606\u2606</p> <p>Create a digital recipe collection with search and favorites.</p> <p>Core Features: - Recipe list with images and ratings - Detailed recipe view with ingredients and steps - Search and filter functionality - Favorites system - Shopping list generator</p> <p>Learning Goals: - ListView and GridView - Search implementation - Local data storage - State management with Provider - Form handling</p> <p>Instagram Clone Concepts Used: - Feed-like recipe display - Search functionality - Like/favorite system - Image handling - Data persistence</p>"},{"location":"training/project-ideas/#3-weather-dashboard","title":"3. Weather Dashboard","text":"<p>Duration: 4-6 days | Difficulty: \u2b50\u2b50\u2606\u2606\u2606</p> <p>Build a beautiful weather app with forecasts and location services.</p> <p>Core Features: - Current weather display - 7-day forecast - Location-based weather - Weather alerts and notifications - Multiple city support</p> <p>Learning Goals: - API integration - Location services - Custom UI components - Data visualization - Background tasks</p> <p>Instagram Clone Concepts Used: - Real-time data updates - Location services - Custom UI components - Data fetching patterns</p>"},{"location":"training/project-ideas/#4-task-manager-app","title":"4. Task Manager App","text":"<p>Duration: 6-8 days | Difficulty: \u2b50\u2b50\u2b50\u2606\u2606</p> <p>Create a productivity app for managing tasks and projects.</p> <p>Core Features: - Task creation and editing - Categories and tags - Due dates and reminders - Progress tracking - Statistics and analytics</p> <p>Learning Goals: - CRUD operations - Local database (SQLite) - Notifications - Date/time handling - Data visualization</p> <p>Instagram Clone Concepts Used: - Data management patterns - User interaction flows - Notification system - Analytics implementation</p>"},{"location":"training/project-ideas/#intermediate-projects","title":"Intermediate Projects","text":""},{"location":"training/project-ideas/#5-social-fitness-tracker","title":"5. Social Fitness Tracker","text":"<p>Duration: 10-14 days | Difficulty: \u2b50\u2b50\u2b50\u2606\u2606</p> <p>Build a fitness app with social features and activity tracking.</p> <p>Core Features: - Workout logging and tracking - Social feed for sharing workouts - Friend system and challenges - Progress charts and statistics - Achievement system</p> <p>Learning Goals: - Complex state management - Social features implementation - Data visualization - Real-time updates - Gamification</p> <p>Instagram Clone Concepts Used: - Social feed structure - User following system - Real-time updates - Achievement/notification system - Profile and activity tracking</p>"},{"location":"training/project-ideas/#6-marketplace-app","title":"6. Marketplace App","text":"<p>Duration: 12-16 days | Difficulty: \u2b50\u2b50\u2b50\u2606\u2606</p> <p>Create a local marketplace for buying and selling items.</p> <p>Core Features: - Product listings with photos - User profiles and ratings - Chat system for negotiations - Search and filtering - Payment integration</p> <p>Learning Goals: - E-commerce patterns - Real-time messaging - Payment processing - Image upload and storage - User verification</p> <p>Instagram Clone Concepts Used: - Media upload system - User profiles and verification - Real-time messaging - Search and discovery - Content moderation</p>"},{"location":"training/project-ideas/#7-event-planning-app","title":"7. Event Planning App","text":"<p>Duration: 10-12 days | Difficulty: \u2b50\u2b50\u2b50\u2606\u2606</p> <p>Build an app for creating and managing events with social features.</p> <p>Core Features: - Event creation and management - RSVP system - Event feed and discovery - Photo sharing from events - Calendar integration</p> <p>Learning Goals: - Calendar integration - Event management - Social features - Photo sharing - Push notifications</p> <p>Instagram Clone Concepts Used: - Event feed (similar to post feed) - Photo sharing and galleries - User interaction (RSVP like likes) - Real-time updates - Social discovery</p>"},{"location":"training/project-ideas/#8-learning-management-system","title":"8. Learning Management System","text":"<p>Duration: 14-18 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606</p> <p>Create an educational platform with courses and progress tracking.</p> <p>Core Features: - Course catalog and enrollment - Video lessons and materials - Progress tracking and certificates - Discussion forums - Offline content download</p> <p>Learning Goals: - Video streaming - Offline capabilities - Progress tracking - Forum/discussion features - Certificate generation</p> <p>Instagram Clone Concepts Used: - Content feed (courses like posts) - Media handling (videos like images) - User progress (like activity tracking) - Discussion features (like comments) - Offline content management</p>"},{"location":"training/project-ideas/#advanced-projects","title":"Advanced Projects","text":""},{"location":"training/project-ideas/#9-multi-vendor-food-delivery","title":"9. Multi-Vendor Food Delivery","text":"<p>Duration: 18-25 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606</p> <p>Build a comprehensive food delivery platform with multiple user types.</p> <p>Core Features: - Restaurant discovery and menus - Real-time order tracking - Multiple payment methods - Delivery driver app integration - Restaurant management dashboard</p> <p>Learning Goals: - Multi-app architecture - Real-time tracking - Complex state management - Payment processing - Role-based access</p> <p>Instagram Clone Concepts Used: - Content discovery (restaurants like users) - Real-time updates (order tracking) - Media-rich content (food photos) - User profiles (restaurants, customers, drivers) - Review and rating system</p>"},{"location":"training/project-ideas/#10-telemedicine-platform","title":"10. Telemedicine Platform","text":"<p>Duration: 20-28 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2b50</p> <p>Create a healthcare app with video consultations and health tracking.</p> <p>Core Features: - Doctor discovery and booking - Video consultation integration - Health record management - Prescription management - Emergency features</p> <p>Learning Goals: - Video calling integration - Healthcare data handling - Security and privacy - Appointment scheduling - Emergency protocols</p> <p>Instagram Clone Concepts Used: - User profiles (doctors/patients) - Real-time communication - Media sharing (health records) - Appointment system - Secure messaging</p>"},{"location":"training/project-ideas/#11-real-estate-platform","title":"11. Real Estate Platform","text":"<p>Duration: 16-22 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606</p> <p>Build a property listing and management platform.</p> <p>Core Features: - Property listings with virtual tours - Advanced search and filters - Mortgage calculator - Agent profiles and ratings - Saved searches and alerts</p> <p>Learning Goals: - Map integration - Virtual tour implementation - Complex filtering - Financial calculations - Location-based services</p> <p>Instagram Clone Concepts Used: - Media-rich listings (like posts) - User profiles (agents like influencers) - Search and discovery - Saved content (like bookmarks) - Location-based features</p>"},{"location":"training/project-ideas/#12-cryptocurrency-portfolio-tracker","title":"12. Cryptocurrency Portfolio Tracker","text":"<p>Duration: 14-20 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2606</p> <p>Create a comprehensive crypto tracking and trading platform.</p> <p>Core Features: - Portfolio tracking and analytics - Real-time price updates - Trading integration - News and market analysis - Price alerts and notifications</p> <p>Learning Goals: - Real-time data streaming - Financial data visualization - Trading API integration - Complex calculations - Market data handling</p> <p>Instagram Clone Concepts Used: - Real-time feed updates (price feeds) - User portfolios (like profiles) - News feed integration - Alert system (like notifications) - Data visualization</p>"},{"location":"training/project-ideas/#13-smart-home-controller","title":"13. Smart Home Controller","text":"<p>Duration: 18-24 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2b50</p> <p>Build an IoT app for controlling smart home devices.</p> <p>Core Features: - Device discovery and pairing - Remote control interface - Automation and scheduling - Energy monitoring - Security features</p> <p>Learning Goals: - IoT integration - Bluetooth/WiFi communication - Device management - Automation logic - Security implementation</p> <p>Instagram Clone Concepts Used: - Device feeds (like user feeds) - Real-time status updates - Media sharing (device photos) - User preferences and settings - Activity monitoring</p>"},{"location":"training/project-ideas/#14-music-streaming-platform","title":"14. Music Streaming Platform","text":"<p>Duration: 20-26 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2b50</p> <p>Create a music streaming app with social features.</p> <p>Core Features: - Music library and streaming - Playlist creation and sharing - Social features and following - Offline downloads - Music discovery algorithms</p> <p>Learning Goals: - Audio streaming - Offline capabilities - Recommendation algorithms - Social music features - Audio processing</p> <p>Instagram Clone Concepts Used: - Content feeds (music like posts) - Social following system - Media sharing (playlists) - Discovery algorithms - User-generated content</p>"},{"location":"training/project-ideas/#15-augmented-reality-shopping","title":"15. Augmented Reality Shopping","text":"<p>Duration: 22-30 days | Difficulty: \u2b50\u2b50\u2b50\u2b50\u2b50</p> <p>Build an AR-powered shopping experience.</p> <p>Core Features: - AR product visualization - Virtual try-on features - Social sharing of AR experiences - Product recommendations - AR-based navigation</p> <p>Learning Goals: - AR integration - 3D model handling - Camera processing - Advanced UI/UX - Performance optimization</p> <p>Instagram Clone Concepts Used: - Camera integration (AR like camera) - Social sharing features - Media-rich content - User-generated content - Discovery and recommendations</p>"},{"location":"training/project-ideas/#project-selection-guide","title":"Project Selection Guide","text":""},{"location":"training/project-ideas/#choose-based-on-your-goals","title":"Choose Based on Your Goals:","text":"<p>Learning Flutter Basics \u2192 Projects 1-4 Building Portfolio \u2192 Projects 5-8 Mastering Advanced Concepts \u2192 Projects 9-15 Specific Industry Interest \u2192 Choose by domain (healthcare, fintech, etc.)</p>"},{"location":"training/project-ideas/#recommended-progression","title":"Recommended Progression:","text":"<ol> <li>Week 1-2: Personal Portfolio App</li> <li>Week 3-4: Recipe Book App</li> <li>Week 5-6: Social Fitness Tracker</li> <li>Week 7-8: Marketplace App</li> <li>Week 9-10: Learning Management System</li> <li>Week 11-12: Choose an advanced project based on interest</li> </ol>"},{"location":"training/project-ideas/#success-tips","title":"Success Tips:","text":"<ol> <li>Start Simple: Begin with basic features, then add complexity</li> <li>Use Instagram Clone as Reference: Apply similar patterns and solutions</li> <li>Focus on Quality: Better to build fewer features well than many poorly</li> <li>Document Your Journey: Keep notes on challenges and solutions</li> <li>Share Your Work: Get feedback from the Flutter community</li> <li>Iterate and Improve: Refactor and optimize as you learn</li> </ol> <p>Each project builds upon concepts from the Instagram Clone while introducing new challenges and learning opportunities. Use the Instagram Clone documentation as your reference guide for implementing similar features in these projects.</p> <p>Happy coding!</p>"},{"location":"training/self-paced-training-guide/","title":"Self-Paced Flutter Training Guide","text":"<p>A comprehensive training program for developers to master Flutter development using the Instagram Clone project as a foundation.</p>"},{"location":"training/self-paced-training-guide/#training-overview","title":"Training Overview","text":"<p>This self-paced training program is designed for both new and experienced developers who want to master Flutter development. Using our Instagram Clone project as a foundation, you'll learn production-grade Flutter development practices, clean architecture, and modern development workflows.</p>"},{"location":"training/self-paced-training-guide/#target-audience","title":"Target Audience","text":"<ul> <li>New Flutter Developers: Coming from other mobile frameworks or web development</li> <li>Experienced Mobile Developers: iOS/Android developers transitioning to Flutter</li> <li>Backend Developers: Looking to expand into mobile development</li> <li>Full-Stack Developers: Adding mobile skills to their toolkit</li> </ul>"},{"location":"training/self-paced-training-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic programming knowledge (any language)</li> <li>Understanding of object-oriented programming concepts</li> <li>Familiarity with Git and version control</li> <li>Basic understanding of mobile app concepts</li> </ul>"},{"location":"training/self-paced-training-guide/#training-structure","title":"Training Structure","text":""},{"location":"training/self-paced-training-guide/#phase-1-foundation-weeks-1-2","title":"Phase 1: Foundation (Weeks 1-2)","text":"<p>Goal: Understand Flutter basics and project structure</p>"},{"location":"training/self-paced-training-guide/#week-1-flutter-fundamentals","title":"Week 1: Flutter Fundamentals","text":"<ul> <li>[ ] Day 1-2: Flutter installation and setup</li> <li>Follow Flutter Installation Guide</li> <li>Set up development environment (VS Code/Android Studio)</li> <li> <p>Create your first \"Hello World\" app</p> </li> <li> <p>[ ] Day 3-4: Dart language basics</p> </li> <li>Variables, functions, and classes</li> <li>Null safety and type system</li> <li>Async/await and Futures</li> <li> <p>Collections and iterables</p> </li> <li> <p>[ ] Day 5-7: Core Flutter concepts</p> </li> <li>Widgets and widget tree</li> <li>Stateless vs Stateful widgets</li> <li>Basic layouts (Row, Column, Stack)</li> <li>Material Design components</li> </ul>"},{"location":"training/self-paced-training-guide/#week-2-project-structure-architecture","title":"Week 2: Project Structure &amp; Architecture","text":"<ul> <li>[ ] Day 1-3: Project organization</li> <li>Study Project Structure Guide</li> <li>Understand flat vs feature-based architecture</li> <li>Learn about dependency injection</li> <li> <p>Package management with pubspec.yaml</p> </li> <li> <p>[ ] Day 4-5: State management introduction</p> </li> <li>Provider pattern basics</li> <li>setState vs state management solutions</li> <li> <p>Introduction to Riverpod</p> </li> <li> <p>[ ] Day 6-7: Navigation and routing</p> </li> <li>Navigator 1.0 vs 2.0</li> <li>go_router implementation</li> <li>Deep linking concepts</li> </ul>"},{"location":"training/self-paced-training-guide/#phase-2-core-development-weeks-3-6","title":"Phase 2: Core Development (Weeks 3-6)","text":"<p>Goal: Build core Instagram Clone features</p>"},{"location":"training/self-paced-training-guide/#week-3-authentication-user-management","title":"Week 3: Authentication &amp; User Management","text":"<ul> <li>[ ] Study Materials:</li> <li>Authentication Guide</li> <li>Supabase Setup</li> <li> <p>Supabase Usage</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Implement user registration</li> <li>Add email/password login</li> <li>Create user profile management</li> <li>Add social authentication (Google/Apple)</li> </ul>"},{"location":"training/self-paced-training-guide/#week-4-uiux-development","title":"Week 4: UI/UX Development","text":"<ul> <li>[ ] Study Materials:</li> <li>Responsive Design</li> <li>Cross-Platform Design</li> <li> <p>Styling Systems</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Build responsive layouts</li> <li>Implement custom themes</li> <li>Create reusable UI components</li> <li>Add animations and transitions</li> </ul>"},{"location":"training/self-paced-training-guide/#week-5-data-management","title":"Week 5: Data Management","text":"<ul> <li>[ ] Study Materials:</li> <li>Supabase Integration</li> <li>State Synchronization</li> <li> <p>Offline Support</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Implement CRUD operations</li> <li>Add real-time data sync</li> <li>Create offline-first architecture</li> <li>Handle data caching</li> </ul>"},{"location":"training/self-paced-training-guide/#week-6-media-file-handling","title":"Week 6: Media &amp; File Handling","text":"<ul> <li>[ ] Study Materials:</li> <li>Platform Channels</li> <li> <p>Permissions</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Implement image picker</li> <li>Add camera functionality</li> <li>Create image upload/storage</li> <li>Handle file compression</li> </ul>"},{"location":"training/self-paced-training-guide/#phase-3-advanced-features-weeks-7-10","title":"Phase 3: Advanced Features (Weeks 7-10)","text":"<p>Goal: Implement advanced Instagram features</p>"},{"location":"training/self-paced-training-guide/#week-7-social-features","title":"Week 7: Social Features","text":"<ul> <li>[ ] Practical Tasks:</li> <li>User following/followers system</li> <li>Post likes and comments</li> <li>Activity feed/notifications</li> <li>User search and discovery</li> </ul>"},{"location":"training/self-paced-training-guide/#week-8-real-time-features","title":"Week 8: Real-time Features","text":"<ul> <li>[ ] Study Materials:</li> <li>Real-time Data</li> <li> <p>Performance Optimization</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Real-time chat/messaging</li> <li>Live notifications</li> <li>Real-time post updates</li> <li>Presence indicators</li> </ul>"},{"location":"training/self-paced-training-guide/#week-9-performance-optimization","title":"Week 9: Performance &amp; Optimization","text":"<ul> <li>[ ] Study Materials:</li> <li>Performance Monitoring</li> <li> <p>Code Quality</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Implement lazy loading</li> <li>Add image caching</li> <li>Optimize app performance</li> <li>Memory management</li> </ul>"},{"location":"training/self-paced-training-guide/#week-10-testing-quality-assurance","title":"Week 10: Testing &amp; Quality Assurance","text":"<ul> <li>[ ] Study Materials:</li> <li>Testing Guide</li> <li> <p>Debugging</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Write unit tests</li> <li>Create widget tests</li> <li>Implement integration tests</li> <li>Set up automated testing</li> </ul>"},{"location":"training/self-paced-training-guide/#phase-4-production-deployment-weeks-11-12","title":"Phase 4: Production &amp; Deployment (Weeks 11-12)","text":"<p>Goal: Deploy and maintain production apps</p>"},{"location":"training/self-paced-training-guide/#week-11-deployment-preparation","title":"Week 11: Deployment Preparation","text":"<ul> <li>[ ] Study Materials:</li> <li>Deployment Guide</li> <li>CI/CD</li> <li>App Store</li> <li> <p>Google Play</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Configure build variants</li> <li>Set up signing certificates</li> <li>Prepare app store assets</li> <li>Create release builds</li> </ul>"},{"location":"training/self-paced-training-guide/#week-12-monitoring-maintenance","title":"Week 12: Monitoring &amp; Maintenance","text":"<ul> <li>[ ] Study Materials:</li> <li>Crash Reporting</li> <li>A/B Testing</li> <li> <p>Version Management</p> </li> <li> <p>[ ] Practical Tasks:</p> </li> <li>Implement crash reporting</li> <li>Set up analytics</li> <li>Create update mechanisms</li> <li>Plan maintenance strategies</li> </ul>"},{"location":"training/self-paced-training-guide/#hands-on-projects","title":"Hands-On Projects","text":"<p>Complete these projects to reinforce your learning and build a portfolio:</p>"},{"location":"training/self-paced-training-guide/#project-1-personal-profile-app-week-2","title":"Project 1: Personal Profile App (Week 2)","text":"<p>Difficulty: Beginner Duration: 3-5 days</p> <p>Build a simple personal profile app with: - User profile display - Edit profile functionality - Settings screen - Basic navigation</p> <p>Learning Goals: - Widget composition - State management basics - Form handling - Navigation</p>"},{"location":"training/self-paced-training-guide/#project-2-photo-gallery-app-week-4","title":"Project 2: Photo Gallery App (Week 4)","text":"<p>Difficulty: Beginner-Intermediate Duration: 5-7 days</p> <p>Create a photo gallery app with: - Grid view of photos - Photo detail view - Search functionality - Favorites system</p> <p>Learning Goals: - ListView and GridView - Image handling - Search implementation - Local storage</p>"},{"location":"training/self-paced-training-guide/#project-3-chat-application-week-6","title":"Project 3: Chat Application (Week 6)","text":"<p>Difficulty: Intermediate Duration: 7-10 days</p> <p>Build a real-time chat app with: - User authentication - Real-time messaging - Group chats - Media sharing</p> <p>Learning Goals: - Real-time data - Complex state management - File uploads - Push notifications</p>"},{"location":"training/self-paced-training-guide/#project-4-e-commerce-app-week-8","title":"Project 4: E-commerce App (Week 8)","text":"<p>Difficulty: Intermediate-Advanced Duration: 10-14 days</p> <p>Create an e-commerce app with: - Product catalog - Shopping cart - Payment integration - Order tracking</p> <p>Learning Goals: - Complex navigation - Payment processing - State persistence - API integration</p>"},{"location":"training/self-paced-training-guide/#project-5-fitness-tracker-week-10","title":"Project 5: Fitness Tracker (Week 10)","text":"<p>Difficulty: Advanced Duration: 14-21 days</p> <p>Build a fitness tracking app with: - Activity tracking - Data visualization - Goal setting - Social features</p> <p>Learning Goals: - Sensor integration - Data visualization - Background processing - Health data handling</p>"},{"location":"training/self-paced-training-guide/#assessment-checkpoints","title":"Assessment Checkpoints","text":""},{"location":"training/self-paced-training-guide/#week-4-checkpoint-basic-competency","title":"Week 4 Checkpoint: Basic Competency","text":"<ul> <li>[ ] Can create responsive layouts</li> <li>[ ] Understands state management</li> <li>[ ] Can implement navigation</li> <li>[ ] Handles user input effectively</li> </ul>"},{"location":"training/self-paced-training-guide/#week-8-checkpoint-intermediate-skills","title":"Week 8 Checkpoint: Intermediate Skills","text":"<ul> <li>[ ] Implements complex features</li> <li>[ ] Uses advanced state management</li> <li>[ ] Handles real-time data</li> <li>[ ] Optimizes app performance</li> </ul>"},{"location":"training/self-paced-training-guide/#week-12-checkpoint-production-ready","title":"Week 12 Checkpoint: Production Ready","text":"<ul> <li>[ ] Deploys apps to stores</li> <li>[ ] Implements monitoring</li> <li>[ ] Handles edge cases</li> <li>[ ] Follows best practices</li> </ul>"},{"location":"training/self-paced-training-guide/#certification-path","title":"Certification Path","text":""},{"location":"training/self-paced-training-guide/#flutter-developer-certificate","title":"Flutter Developer Certificate","text":"<p>Complete all phases and projects to earn recognition:</p> <ol> <li>Foundation Certificate (Week 4)</li> <li>Complete Phase 1 and Projects 1-2</li> <li> <p>Pass basic competency assessment</p> </li> <li> <p>Intermediate Certificate (Week 8)</p> </li> <li>Complete Phase 2 and Projects 3-4</li> <li> <p>Demonstrate intermediate skills</p> </li> <li> <p>Advanced Certificate (Week 12)</p> </li> <li>Complete all phases and projects</li> <li>Deploy a production app</li> <li>Demonstrate best practices</li> </ol>"},{"location":"training/self-paced-training-guide/#additional-resources","title":"Additional Resources","text":""},{"location":"training/self-paced-training-guide/#recommended-reading","title":"Recommended Reading","text":"<ul> <li>Flutter Documentation</li> <li>Dart Language Tour</li> <li>Material Design Guidelines</li> <li>iOS Human Interface Guidelines</li> </ul>"},{"location":"training/self-paced-training-guide/#community-resources","title":"Community Resources","text":"<ul> <li>Flutter Community</li> <li>Flutter Discord</li> <li>r/FlutterDev</li> <li>Flutter YouTube Channel</li> </ul>"},{"location":"training/self-paced-training-guide/#practice-platforms","title":"Practice Platforms","text":"<ul> <li>DartPad - Online Dart/Flutter editor</li> <li>Flutter Codelabs</li> <li>Flutter Samples</li> </ul>"},{"location":"training/self-paced-training-guide/#getting-help","title":"Getting Help","text":""},{"location":"training/self-paced-training-guide/#when-youre-stuck","title":"When You're Stuck","text":"<ol> <li>Check Documentation: Always start with official docs</li> <li>Search Issues: Look for similar problems on GitHub</li> <li>Ask Community: Use Stack Overflow, Discord, or Reddit</li> <li>Debug Systematically: Use Flutter DevTools</li> <li>Take Breaks: Sometimes stepping away helps</li> </ol>"},{"location":"training/self-paced-training-guide/#mentorship-opportunities","title":"Mentorship Opportunities","text":"<ul> <li>Join Flutter study groups</li> <li>Participate in open source projects</li> <li>Attend Flutter meetups and conferences</li> <li>Find a mentor in the Flutter community</li> </ul>"},{"location":"training/self-paced-training-guide/#success-tips","title":"Success Tips","text":"<ol> <li>Practice Daily: Consistency is key to mastering Flutter</li> <li>Build Real Projects: Apply concepts to practical problems</li> <li>Read Code: Study well-written Flutter apps on GitHub</li> <li>Stay Updated: Follow Flutter releases and best practices</li> <li>Share Knowledge: Teach others to reinforce your learning</li> <li>Be Patient: Mobile development has a learning curve</li> <li>Focus on Quality: Write clean, maintainable code from the start</li> </ol> <p>Remember: This Instagram Clone project serves as your reference implementation. Use it to understand patterns, but challenge yourself to implement features independently first, then compare with the reference solution.</p> <p>Good luck on your Flutter journey!</p>"},{"location":"troubleshooting/android-troubleshooting/","title":"Android Troubleshooting Guide","text":"<p>Common Android development issues and solutions for Flutter projects.</p>"},{"location":"troubleshooting/android-troubleshooting/#build-issues","title":"Build Issues","text":""},{"location":"troubleshooting/android-troubleshooting/#1-gradle-build-failures","title":"1. Gradle Build Failures","text":"<p>Problem: <code>FAILURE: Build failed with an exception</code></p> <p>Solutions: <pre><code># Clean and rebuild\nflutter clean\ncd android\n./gradlew clean\ncd ..\nflutter build apk\n\n# Update Gradle wrapper\ncd android\n./gradlew wrapper --gradle-version=8.0\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#2-dependency-conflicts","title":"2. Dependency Conflicts","text":"<p>Problem: <code>Duplicate class</code> or <code>More than one file was found with OS independent path</code></p> <p>Solution: <pre><code>// android/app/build.gradle\nandroid {\n    packagingOptions {\n        pickFirst '**/libc++_shared.so'\n        pickFirst '**/libjsc.so'\n        exclude 'META-INF/DEPENDENCIES'\n        exclude 'META-INF/LICENSE'\n        exclude 'META-INF/LICENSE.txt'\n        exclude 'META-INF/NOTICE'\n        exclude 'META-INF/NOTICE.txt'\n    }\n}\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#3-minimum-sdk-version-issues","title":"3. Minimum SDK Version Issues","text":"<p>Problem: <code>uses-sdk:minSdkVersion 16 cannot be smaller than version 21</code></p> <p>Solution: <pre><code>// android/app/build.gradle\nandroid {\n    defaultConfig {\n        minSdkVersion 21\n        targetSdkVersion 34\n        compileSdkVersion 34\n    }\n}\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#runtime-issues","title":"Runtime Issues","text":""},{"location":"troubleshooting/android-troubleshooting/#1-app-crashes-on-launch","title":"1. App Crashes on Launch","text":"<p>Problem: App crashes immediately after launch</p> <p>Debugging: <pre><code># Check device logs\nflutter logs\n\n# Run with verbose logging\nflutter run --verbose\n\n# Check Android logcat\nadb logcat | grep flutter\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#2-permission-issues","title":"2. Permission Issues","text":"<p>Problem: Permissions not working on Android</p> <p>Solution: <pre><code>&lt;!-- android/app/src/main/AndroidManifest.xml --&gt;\n&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#3-network-security-issues","title":"3. Network Security Issues","text":"<p>Problem: Network requests fail on Android 9+</p> <p>Solution: <pre><code>&lt;!-- android/app/src/main/AndroidManifest.xml --&gt;\n&lt;application\n    android:usesCleartextTraffic=\"true\"\n    android:networkSecurityConfig=\"@xml/network_security_config\"&gt;\n\n&lt;!-- android/app/src/main/res/xml/network_security_config.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;network-security-config&gt;\n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;domain includeSubdomains=\"true\"&gt;your-api-domain.com&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/android-troubleshooting/#1-slow-build-times","title":"1. Slow Build Times","text":"<p>Solutions: <pre><code>// android/gradle.properties\norg.gradle.jvmargs=-Xmx4g -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\norg.gradle.parallel=true\norg.gradle.configureondemand=true\norg.gradle.daemon=true\nandroid.useAndroidX=true\nandroid.enableJetifier=true\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#2-large-apk-size","title":"2. Large APK Size","text":"<p>Solutions: <pre><code># Build with tree shaking\nflutter build apk --release --tree-shake-icons\n\n# Build app bundle\nflutter build appbundle --release\n\n# Analyze APK size\nflutter build apk --analyze-size\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#device-specific-issues","title":"Device-Specific Issues","text":""},{"location":"troubleshooting/android-troubleshooting/#1-emulator-issues","title":"1. Emulator Issues","text":"<p>Problem: Android emulator not starting or slow</p> <p>Solutions: <pre><code># List available emulators\nflutter emulators\n\n# Start specific emulator\nflutter emulators --launch Pixel_4_API_30\n\n# Create new emulator\navdmanager create avd -n test_emulator -k \"system-images;android-30;google_apis;x86_64\"\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#2-physical-device-issues","title":"2. Physical Device Issues","text":"<p>Problem: Device not detected</p> <p>Solutions: <pre><code># Check device connection\nadb devices\n\n# Enable USB debugging on device\n# Settings &gt; Developer options &gt; USB debugging\n\n# Install ADB drivers (Windows)\n# Download from Android SDK Manager\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"troubleshooting/android-troubleshooting/#1-could-not-resolve-all-artifacts","title":"1. \"Could not resolve all artifacts\"","text":"<p>Solution: <pre><code>// android/build.gradle\nallprojects {\n    repositories {\n        google()\n        mavenCentral()\n        maven { url 'https://jitpack.io' }\n    }\n}\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#2-execution-failed-for-task-appprocessdebugresources","title":"2. \"Execution failed for task ':app:processDebugResources'\"","text":"<p>Solution: <pre><code># Clean and rebuild\nflutter clean\ncd android\n./gradlew clean\ncd ..\nflutter pub get\nflutter build apk\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#3-android-license-status-unknown","title":"3. \"Android license status unknown\"","text":"<p>Solution: <pre><code># Accept Android licenses\nflutter doctor --android-licenses\n</code></pre></p>"},{"location":"troubleshooting/android-troubleshooting/#quick-fixes","title":"Quick Fixes","text":""},{"location":"troubleshooting/android-troubleshooting/#reset-everything","title":"Reset Everything","text":"<pre><code>flutter clean\ncd android\n./gradlew clean\ncd ..\nflutter pub get\nflutter run\n</code></pre>"},{"location":"troubleshooting/android-troubleshooting/#update-dependencies","title":"Update Dependencies","text":"<pre><code>flutter pub upgrade\ncd android\n./gradlew wrapper --gradle-version=latest\n</code></pre>"},{"location":"troubleshooting/android-troubleshooting/#check-configuration","title":"Check Configuration","text":"<pre><code>flutter doctor -v\nflutter config --android-sdk /path/to/android/sdk\n</code></pre>"},{"location":"troubleshooting/build-issues/","title":"Build Issues &amp; Solutions","text":"<p>Comprehensive guide to resolving Flutter build issues across different platforms and environments.</p>"},{"location":"troubleshooting/build-issues/#overview","title":"Overview","text":"<p>Build issues can occur at various stages of the Flutter development process. This guide provides systematic approaches to diagnose and resolve common build problems.</p>"},{"location":"troubleshooting/build-issues/#android-build-issues","title":"Android Build Issues","text":""},{"location":"troubleshooting/build-issues/#1-gradle-build-failures","title":"1. Gradle Build Failures","text":""},{"location":"troubleshooting/build-issues/#issue-gradle-sync-failed","title":"Issue: Gradle Sync Failed","text":"<pre><code># Error message\nFAILURE: Build failed with an exception.\n* What went wrong:\nCould not resolve all files for configuration ':app:debugCompileClasspath'.\n</code></pre> <p>Diagnosis Steps:</p> <pre><code># Check Gradle version compatibility\ncd android\n./gradlew --version\n\n# Check Flutter and Gradle compatibility\nflutter doctor -v\n\n# Clean and rebuild\n./gradlew clean\ncd ..\nflutter clean\nflutter pub get\n</code></pre> <p>Solution:</p> <pre><code>// android/gradle/wrapper/gradle-wrapper.properties\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-all.zip\n\n// android/build.gradle\nbuildscript {\n    ext.kotlin_version = '1.9.10'\n    dependencies {\n        classpath 'com.android.tools.build:gradle:8.1.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n\n// android/app/build.gradle\nandroid {\n    compileSdkVersion 34\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#issue-dependency-resolution-conflicts","title":"Issue: Dependency Resolution Conflicts","text":"<pre><code># Error message\nDuplicate class found in modules\n</code></pre> <p>Solution:</p> <pre><code>// android/app/build.gradle\nandroid {\n    configurations {\n        all {\n            exclude group: 'com.google.guava', module: 'listenablefuture'\n        }\n    }\n}\n\ndependencies {\n    implementation 'androidx.core:core-ktx:1.12.0'\n    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.7.0'\n\n    // Exclude conflicting dependencies\n    implementation('com.some.library:library:1.0.0') {\n        exclude group: 'conflicting.group', module: 'conflicting-module'\n    }\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#issue-multidex-build-errors","title":"Issue: Multidex Build Errors","text":"<pre><code># Error message\nCannot fit requested classes in a single dex file (# methods: 65536 &gt; 65536)\n</code></pre> <p>Solution:</p> <pre><code>// android/app/build.gradle\nandroid {\n    defaultConfig {\n        multiDexEnabled true\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n\ndependencies {\n    implementation 'androidx.multidex:multidex:2.0.1'\n}\n</code></pre> <pre><code>// android/app/src/main/kotlin/.../MainActivity.kt\nimport androidx.multidex.MultiDexApplication\n\nclass MainApplication : MultiDexApplication() {\n    override fun onCreate() {\n        super.onCreate()\n    }\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-proguardr8-issues","title":"2. ProGuard/R8 Issues","text":""},{"location":"troubleshooting/build-issues/#issue-code-obfuscation-breaks-app","title":"Issue: Code Obfuscation Breaks App","text":"<pre><code># Error message\nClassNotFoundException or MethodNotFoundException in release build\n</code></pre> <p>Solution:</p> <pre><code># android/app/proguard-rules.pro\n\n# Keep Flutter classes\n-keep class io.flutter.app.** { *; }\n-keep class io.flutter.plugin.**  { *; }\n-keep class io.flutter.util.**  { *; }\n-keep class io.flutter.view.**  { *; }\n-keep class io.flutter.**  { *; }\n-keep class io.flutter.plugins.**  { *; }\n\n# Keep your app's classes\n-keep class com.yourapp.** { *; }\n\n# Keep model classes (if using JSON serialization)\n-keep class * extends com.google.gson.TypeAdapter\n-keep class * implements com.google.gson.TypeAdapterFactory\n-keep class * implements com.google.gson.JsonSerializer\n-keep class * implements com.google.gson.JsonDeserializer\n\n# Keep Retrofit interfaces\n-keep,allowobfuscation,allowshrinking interface retrofit2.Call\n-keep,allowobfuscation,allowshrinking class retrofit2.Response\n-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation\n\n# Keep Firebase classes\n-keep class com.google.firebase.** { *; }\n-keep class com.google.android.gms.** { *; }\n\n# Keep native methods\n-keepclasseswithmembernames class * {\n    native &lt;methods&gt;;\n}\n\n# Remove debug logs\n-assumenosideeffects class android.util.Log {\n    public static *** d(...);\n    public static *** v(...);\n    public static *** i(...);\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#3-signing-issues","title":"3. Signing Issues","text":""},{"location":"troubleshooting/build-issues/#issue-keystore-not-found","title":"Issue: Keystore Not Found","text":"<pre><code># Error message\nKeystore file '/path/to/keystore.jks' not found for signing config 'release'.\n</code></pre> <p>Solution:</p> <pre><code># Generate new keystore\nkeytool -genkey -v -keystore ~/upload-keystore.jks \\\n  -keyalg RSA -keysize 2048 -validity 10000 -alias upload\n\n# Create key.properties file\necho \"storePassword=your_store_password\" &gt; android/key.properties\necho \"keyPassword=your_key_password\" &gt;&gt; android/key.properties\necho \"keyAlias=upload\" &gt;&gt; android/key.properties\necho \"storeFile=../upload-keystore.jks\" &gt;&gt; android/key.properties\n</code></pre> <pre><code>// android/app/build.gradle\ndef keystoreProperties = new Properties()\ndef keystorePropertiesFile = rootProject.file('key.properties')\nif (keystorePropertiesFile.exists()) {\n    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))\n}\n\nandroid {\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n        }\n    }\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#ios-build-issues","title":"iOS Build Issues","text":""},{"location":"troubleshooting/build-issues/#1-cocoapods-issues","title":"1. CocoaPods Issues","text":""},{"location":"troubleshooting/build-issues/#issue-pod-install-fails","title":"Issue: Pod Install Fails","text":"<pre><code># Error message\n[!] Unable to find a specification for `dependency_name`\n</code></pre> <p>Solution:</p> <pre><code># Clean CocoaPods cache\ncd ios\nrm -rf Pods\nrm Podfile.lock\npod cache clean --all\n\n# Update CocoaPods repository\npod repo update\n\n# Install with verbose output\npod install --verbose\n\n# For M1/M2 Macs\narch -x86_64 pod install\n\n# Alternative: Use Rosetta terminal\narch -x86_64 /bin/bash\npod install\n</code></pre>"},{"location":"troubleshooting/build-issues/#issue-minimum-deployment-target","title":"Issue: Minimum Deployment Target","text":"<pre><code># Error message\nThe iOS deployment target 'IPHONEOS_DEPLOYMENT_TARGET' is set to 8.0, but the range of supported deployment target versions is 11.0 to 17.0.99.\n</code></pre> <p>Solution:</p> <pre><code># ios/Podfile\nplatform :ios, '12.0'\n\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    flutter_additional_ios_build_settings(target)\n\n    target.build_configurations.each do |config|\n      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '12.0'\n    end\n  end\nend\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-xcode-build-issues","title":"2. Xcode Build Issues","text":""},{"location":"troubleshooting/build-issues/#issue-code-signing-errors","title":"Issue: Code Signing Errors","text":"<pre><code># Error message\nCode Sign error: No code signing identities found\n</code></pre> <p>Solution:</p> <pre><code># Open Xcode project\nopen ios/Runner.xcworkspace\n\n# In Xcode:\n# 1. Select Runner project\n# 2. Select Runner target\n# 3. Go to Signing &amp; Capabilities\n# 4. Enable \"Automatically manage signing\"\n# 5. Select your Apple Developer team\n\n# Or configure manually in project.pbxproj\n# Set DEVELOPMENT_TEAM = YOUR_TEAM_ID;\n</code></pre>"},{"location":"troubleshooting/build-issues/#issue-swift-version-conflicts","title":"Issue: Swift Version Conflicts","text":"<pre><code># Error message\nModule compiled with Swift 5.7 cannot be imported by the Swift 5.9 compiler\n</code></pre> <p>Solution:</p> <pre><code># ios/Podfile\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    flutter_additional_ios_build_settings(target)\n\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '5.9'\n    end\n  end\nend\n</code></pre>"},{"location":"troubleshooting/build-issues/#3-simulator-issues","title":"3. Simulator Issues","text":""},{"location":"troubleshooting/build-issues/#issue-simulator-not-found","title":"Issue: Simulator Not Found","text":"<pre><code># Error message\nNo iOS devices available\n</code></pre> <p>Solution:</p> <pre><code># List available simulators\nxcrun simctl list devices\n\n# Create new simulator if needed\nxcrun simctl create \"iPhone 15 Pro\" \"iPhone 15 Pro\" \"iOS 17.0\"\n\n# Boot simulator\nxcrun simctl boot \"iPhone 15 Pro\"\n\n# Open Simulator app\nopen -a Simulator\n\n# Reset simulator if corrupted\nxcrun simctl erase \"iPhone 15 Pro\"\n</code></pre>"},{"location":"troubleshooting/build-issues/#web-build-issues","title":"Web Build Issues","text":""},{"location":"troubleshooting/build-issues/#1-compilation-errors","title":"1. Compilation Errors","text":""},{"location":"troubleshooting/build-issues/#issue-web-compilation-fails","title":"Issue: Web Compilation Fails","text":"<pre><code># Error message\nFailed to compile application for the Web.\n</code></pre> <p>Solution:</p> <pre><code># Clean web build\nflutter clean\nflutter pub get\n\n# Build with verbose output\nflutter build web --verbose\n\n# Check for web-incompatible packages\nflutter pub deps | grep -E \"(dart:io|dart:isolate)\"\n\n# Use web-compatible alternatives\n# Replace dart:io with universal_io\n# Replace dart:isolate with web workers\n</code></pre>"},{"location":"troubleshooting/build-issues/#issue-cors-errors-in-development","title":"Issue: CORS Errors in Development","text":"<pre><code># Error message\nAccess to fetch at 'https://api.example.com' from origin 'http://localhost:port' has been blocked by CORS policy\n</code></pre> <p>Solution:</p> <pre><code># Run with CORS disabled (development only)\nflutter run -d chrome --web-browser-flag \"--disable-web-security\"\n\n# Or configure your API server to allow CORS\n# Add appropriate headers:\n# Access-Control-Allow-Origin: *\n# Access-Control-Allow-Methods: GET, POST, PUT, DELETE\n# Access-Control-Allow-Headers: Content-Type, Authorization\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-asset-loading-issues","title":"2. Asset Loading Issues","text":""},{"location":"troubleshooting/build-issues/#issue-assets-not-loading-in-web","title":"Issue: Assets Not Loading in Web","text":"<pre><code># pubspec.yaml\nflutter:\n  assets:\n    - assets/images/\n    - assets/fonts/\n</code></pre> <p>Solution:</p> <pre><code>// Use proper asset paths for web\nclass WebAssets {\n  static String getAssetPath(String assetPath) {\n    if (kIsWeb) {\n      return 'assets/$assetPath';\n    }\n    return assetPath;\n  }\n}\n\n// Usage\nImage.asset(WebAssets.getAssetPath('images/logo.png'))\n</code></pre>"},{"location":"troubleshooting/build-issues/#desktop-build-issues","title":"Desktop Build Issues","text":""},{"location":"troubleshooting/build-issues/#1-linux-build-issues","title":"1. Linux Build Issues","text":""},{"location":"troubleshooting/build-issues/#issue-missing-dependencies","title":"Issue: Missing Dependencies","text":"<pre><code># Error message\nCMake Error: Could not find a package configuration file provided by \"PkgConfig\"\n</code></pre> <p>Solution:</p> <pre><code># Install required dependencies\nsudo apt-get update\nsudo apt-get install -y curl git unzip xz-utils zip libglu1-mesa\nsudo apt-get install -y clang cmake ninja-build pkg-config libgtk-3-dev\n\n# Enable Linux desktop\nflutter config --enable-linux-desktop\n\n# Build for Linux\nflutter build linux\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-windows-build-issues","title":"2. Windows Build Issues","text":""},{"location":"troubleshooting/build-issues/#issue-visual-studio-build-tools-missing","title":"Issue: Visual Studio Build Tools Missing","text":"<pre><code># Error message\nVisual Studio build tools not found\n</code></pre> <p>Solution:</p> <pre><code># Install Visual Studio Build Tools\n# Download from: https://visualstudio.microsoft.com/downloads/\n\n# Or install Visual Studio Community with C++ workload\n\n# Enable Windows desktop\nflutter config --enable-windows-desktop\n\n# Build for Windows\nflutter build windows\n</code></pre>"},{"location":"troubleshooting/build-issues/#3-macos-build-issues","title":"3. macOS Build Issues","text":""},{"location":"troubleshooting/build-issues/#issue-macos-entitlements","title":"Issue: macOS Entitlements","text":"<pre><code># Error message\nApp Sandbox not enabled\n</code></pre> <p>Solution:</p> <pre><code>&lt;!-- macos/Runner/DebugProfile.entitlements --&gt;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre>"},{"location":"troubleshooting/build-issues/#build-optimization-issues","title":"Build Optimization Issues","text":""},{"location":"troubleshooting/build-issues/#1-large-app-size","title":"1. Large App Size","text":""},{"location":"troubleshooting/build-issues/#issue-apkipa-too-large","title":"Issue: APK/IPA Too Large","text":"<p>Analysis:</p> <pre><code># Analyze APK size\nflutter build apk --analyze-size\n\n# Analyze app bundle\nflutter build appbundle --analyze-size\n\n# Check asset sizes\nfind assets -type f -exec ls -lh {} \\; | sort -k5 -hr\n</code></pre> <p>Solution:</p> <pre><code># pubspec.yaml - Optimize assets\nflutter:\n  assets:\n    - assets/images/2.0x/  # Only include necessary resolutions\n    - assets/images/3.0x/\n\n  # Use vector graphics when possible\n  # Compress images before adding to assets\n</code></pre> <pre><code>// android/app/build.gradle - Enable R8 and resource shrinking\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    // Split APKs by ABI\n    splits {\n        abi {\n            enable true\n            reset()\n            include 'x86', 'x86_64', 'arm64-v8a', 'armeabi-v7a'\n            universalApk false\n        }\n    }\n}\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-slow-build-times","title":"2. Slow Build Times","text":""},{"location":"troubleshooting/build-issues/#issue-long-build-duration","title":"Issue: Long Build Duration","text":"<p>Solution:</p> <pre><code># Enable Gradle daemon\necho \"org.gradle.daemon=true\" &gt;&gt; ~/.gradle/gradle.properties\necho \"org.gradle.parallel=true\" &gt;&gt; ~/.gradle/gradle.properties\necho \"org.gradle.configureondemand=true\" &gt;&gt; ~/.gradle/gradle.properties\n\n# Increase Gradle memory\necho \"org.gradle.jvmargs=-Xmx4g -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\" &gt;&gt; ~/.gradle/gradle.properties\n\n# Use build cache\nflutter config --build-dir=build\n</code></pre>"},{"location":"troubleshooting/build-issues/#debugging-build-issues","title":"Debugging Build Issues","text":""},{"location":"troubleshooting/build-issues/#1-verbose-build-output","title":"1. Verbose Build Output","text":"<pre><code># Flutter verbose build\nflutter build apk --verbose\nflutter build ios --verbose\nflutter build web --verbose\n\n# Gradle verbose build\ncd android\n./gradlew assembleRelease --stacktrace --info\n\n# Xcode verbose build\nxcodebuild -workspace ios/Runner.xcworkspace -scheme Runner -configuration Release -destination generic/platform=iOS build -verbose\n</code></pre>"},{"location":"troubleshooting/build-issues/#2-build-analysis-tools","title":"2. Build Analysis Tools","text":"<pre><code># Flutter build analysis\nflutter analyze\nflutter test\nflutter doctor -v\n\n# Android build analysis\ncd android\n./gradlew build --scan\n\n# iOS build analysis\nxcodebuild -workspace ios/Runner.xcworkspace -scheme Runner analyze\n</code></pre>"},{"location":"troubleshooting/build-issues/#3-common-build-commands","title":"3. Common Build Commands","text":"<pre><code># Clean everything\nflutter clean\ncd android &amp;&amp; ./gradlew clean &amp;&amp; cd ..\ncd ios &amp;&amp; rm -rf Pods &amp;&amp; pod install &amp;&amp; cd ..\n\n# Reset Flutter\nflutter channel stable\nflutter upgrade\nflutter doctor\n\n# Reset development environment\nrm -rf ~/.gradle/caches\nrm -rf ~/.pub-cache\nflutter pub cache repair\n</code></pre> <p>Remember to always backup your project before making significant build configuration changes, and test builds on different devices and environments to ensure compatibility.</p>"},{"location":"troubleshooting/common-issues/","title":"Common Issues &amp; Solutions","text":"<p>Comprehensive troubleshooting guide for common Flutter development issues and their solutions.</p>"},{"location":"troubleshooting/common-issues/#overview","title":"Overview","text":"<p>This guide covers the most frequently encountered issues in Flutter development, from setup problems to runtime errors, with step-by-step solutions and prevention strategies.</p>"},{"location":"troubleshooting/common-issues/#development-environment-issues","title":"Development Environment Issues","text":""},{"location":"troubleshooting/common-issues/#1-flutter-doctor-issues","title":"1. Flutter Doctor Issues","text":""},{"location":"troubleshooting/common-issues/#issue-flutter-doctor-shows-warnings","title":"Issue: Flutter Doctor Shows Warnings","text":"<pre><code># Common flutter doctor output with issues\n[\u2717] Android toolchain - develop for Android devices\n    \u2717 Unable to locate Android SDK\n[\u2717] Xcode - develop for iOS and macOS\n    \u2717 Xcode installation is incomplete\n[!] Android Studio (not installed)\n</code></pre> <p>Solution:</p> <pre><code># Fix Android SDK issues\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n\n# Accept Android licenses\nflutter doctor --android-licenses\n\n# Install missing components\nsdkmanager \"platform-tools\" \"platforms;android-34\" \"build-tools;34.0.0\"\n\n# For macOS/iOS development\nsudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nsudo xcodebuild -runFirstLaunch\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-cocoapods-installation-problems","title":"Issue: CocoaPods Installation Problems","text":"<pre><code># Error message\nCocoaPods not installed or not in valid state.\n</code></pre> <p>Solution:</p> <pre><code># Install CocoaPods\nsudo gem install cocoapods\n\n# If using Homebrew Ruby (recommended)\nexport PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"\nexport GEM_HOME=\"$HOME/.gem/ruby/3.4.0\"\nexport GEM_PATH=\"$GEM_HOME\"\nexport PATH=\"$GEM_HOME/bin:$PATH\"\n\ngem install cocoapods\npod setup\n\n# For M1/M2 Macs\nsudo arch -x86_64 gem install ffi\narch -x86_64 pod install\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-dependency-issues","title":"2. Dependency Issues","text":""},{"location":"troubleshooting/common-issues/#issue-pub-get-fails","title":"Issue: Pub Get Fails","text":"<pre><code># Error in pubspec.yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  some_package: ^1.0.0  # Package not found or version conflict\n</code></pre> <p>Solution:</p> <pre><code># Clear pub cache\nflutter pub cache clean\n\n# Get dependencies with verbose output\nflutter pub get --verbose\n\n# Resolve version conflicts\nflutter pub deps\nflutter pub upgrade\n\n# Force refresh\nrm pubspec.lock\nflutter pub get\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-version-conflicts","title":"Issue: Version Conflicts","text":"<pre><code># Error message\nBecause myapp depends on package_a &gt;=1.0.0 and package_b &gt;=2.0.0 which depends on package_a &lt;1.0.0, version solving failed.\n</code></pre> <p>Solution:</p> <pre><code># pubspec.yaml - Use dependency overrides\ndependency_overrides:\n  package_a: ^1.0.0\n\n# Or specify exact versions\ndependencies:\n  package_a: 1.0.0\n  package_b: 2.0.0\n</code></pre>"},{"location":"troubleshooting/common-issues/#build-issues","title":"Build Issues","text":""},{"location":"troubleshooting/common-issues/#1-android-build-problems","title":"1. Android Build Problems","text":""},{"location":"troubleshooting/common-issues/#issue-gradle-build-fails","title":"Issue: Gradle Build Fails","text":"<pre><code># Common Gradle errors\nFAILURE: Build failed with an exception.\n* What went wrong:\nExecution failed for task ':app:processReleaseResources'.\n</code></pre> <p>Solution:</p> <pre><code># Clean and rebuild\ncd android\n./gradlew clean\ncd ..\nflutter clean\nflutter pub get\nflutter build apk\n\n# Fix common Gradle issues\ncd android\n./gradlew --stop\n./gradlew clean\n./gradlew build --stacktrace\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-multidex-issues","title":"Issue: Multidex Issues","text":"<pre><code># Error message\nCannot fit requested classes in a single dex file\n</code></pre> <p>Solution:</p> <pre><code>// android/app/build.gradle\nandroid {\n    defaultConfig {\n        multiDexEnabled true\n    }\n}\n\ndependencies {\n    implementation 'androidx.multidex:multidex:2.0.1'\n}\n</code></pre> <pre><code>// lib/main.dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-keystore-problems","title":"Issue: Keystore Problems","text":"<pre><code># Error message\nKeystore file not found or invalid\n</code></pre> <p>Solution:</p> <pre><code># Generate new keystore\nkeytool -genkey -v -keystore ~/upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias upload\n\n# Verify keystore\nkeytool -list -v -keystore ~/upload-keystore.jks -alias upload\n\n# Update key.properties\necho \"storePassword=your_password\" &gt; android/key.properties\necho \"keyPassword=your_password\" &gt;&gt; android/key.properties\necho \"keyAlias=upload\" &gt;&gt; android/key.properties\necho \"storeFile=../upload-keystore.jks\" &gt;&gt; android/key.properties\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-ios-build-problems","title":"2. iOS Build Problems","text":""},{"location":"troubleshooting/common-issues/#issue-cocoapods-integration","title":"Issue: CocoaPods Integration","text":"<pre><code># Error message\n[!] Unable to find a specification for dependency\n</code></pre> <p>Solution:</p> <pre><code># Clean CocoaPods cache\ncd ios\nrm -rf Pods\nrm Podfile.lock\npod cache clean --all\npod install\n\n# Update CocoaPods\npod repo update\npod install --repo-update\n\n# For M1/M2 Macs\narch -x86_64 pod install\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-xcode-signing-issues","title":"Issue: Xcode Signing Issues","text":"<pre><code># Error message\nCode signing error: No profiles for 'com.example.app' were found\n</code></pre> <p>Solution:</p> <pre><code># Open Xcode and configure signing\nopen ios/Runner.xcworkspace\n\n# Or use automatic signing in Xcode:\n# 1. Select Runner project\n# 2. Select Runner target\n# 3. Go to Signing &amp; Capabilities\n# 4. Enable \"Automatically manage signing\"\n# 5. Select your team\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-ios-simulator-not-found","title":"Issue: iOS Simulator Not Found","text":"<pre><code># Error message\nNo iOS devices available\n</code></pre> <p>Solution:</p> <pre><code># List available simulators\nxcrun simctl list devices\n\n# Create new simulator\nxcrun simctl create \"iPhone 15 Pro\" \"iPhone 15 Pro\" \"iOS 17.0\"\n\n# Boot simulator\nxcrun simctl boot \"iPhone 15 Pro\"\n\n# Open Simulator app\nopen -a Simulator\n</code></pre>"},{"location":"troubleshooting/common-issues/#runtime-issues","title":"Runtime Issues","text":""},{"location":"troubleshooting/common-issues/#1-state-management-problems","title":"1. State Management Problems","text":""},{"location":"troubleshooting/common-issues/#issue-setstate-called-after-dispose","title":"Issue: setState Called After Dispose","text":"<pre><code>// Error message\nsetState() called after dispose()\n</code></pre> <p>Solution:</p> <pre><code>class MyWidget extends StatefulWidget {\n  @override\n  _MyWidgetState createState() =&gt; _MyWidgetState();\n}\n\nclass _MyWidgetState extends State&lt;MyWidget&gt; {\n  bool _mounted = true;\n\n  @override\n  void dispose() {\n    _mounted = false;\n    super.dispose();\n  }\n\n  void updateState() {\n    if (_mounted) {\n      setState(() {\n        // Update state\n      });\n    }\n  }\n\n  // Alternative approach\n  void updateStateSafe() {\n    if (mounted) {\n      setState(() {\n        // Update state\n      });\n    }\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-memory-leaks","title":"Issue: Memory Leaks","text":"<pre><code>// Problem: Not disposing controllers\nclass BadWidget extends StatefulWidget {\n  @override\n  _BadWidgetState createState() =&gt; _BadWidgetState();\n}\n\nclass _BadWidgetState extends State&lt;BadWidget&gt; {\n  late AnimationController _controller;\n  late StreamSubscription _subscription;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this);\n    _subscription = someStream.listen((data) {\n      // Handle data\n    });\n  }\n\n  // Missing dispose method!\n}\n</code></pre> <p>Solution:</p> <pre><code>class GoodWidget extends StatefulWidget {\n  @override\n  _GoodWidgetState createState() =&gt; _GoodWidgetState();\n}\n\nclass _GoodWidgetState extends State&lt;GoodWidget&gt; with TickerProviderStateMixin {\n  late AnimationController _controller;\n  late StreamSubscription _subscription;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: Duration(seconds: 1),\n      vsync: this,\n    );\n    _subscription = someStream.listen((data) {\n      // Handle data\n    });\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    _subscription.cancel();\n    super.dispose();\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-performance-issues","title":"2. Performance Issues","text":""},{"location":"troubleshooting/common-issues/#issue-excessive-widget-rebuilds","title":"Issue: Excessive Widget Rebuilds","text":"<pre><code>// Problem: Rebuilding entire widget tree\nclass BadPerformanceWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        ExpensiveWidget(), // Rebuilds unnecessarily\n        AnotherExpensiveWidget(),\n      ],\n    );\n  }\n}\n</code></pre> <p>Solution:</p> <pre><code>// Solution: Use const constructors and extract widgets\nclass GoodPerformanceWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return const Column(\n      children: [\n        _ExpensiveWidget(), // const constructor\n        _AnotherExpensiveWidget(),\n      ],\n    );\n  }\n}\n\nclass _ExpensiveWidget extends StatelessWidget {\n  const _ExpensiveWidget();\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // Expensive widget content\n    );\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-large-lists-performance","title":"Issue: Large Lists Performance","text":"<pre><code>// Problem: Using Column for large lists\nWidget badList() {\n  return Column(\n    children: List.generate(1000, (index) =&gt; ListTile(\n      title: Text('Item $index'),\n    )),\n  );\n}\n</code></pre> <p>Solution:</p> <pre><code>// Solution: Use ListView.builder\nWidget goodList() {\n  return ListView.builder(\n    itemCount: 1000,\n    itemBuilder: (context, index) {\n      return ListTile(\n        title: Text('Item $index'),\n      );\n    },\n  );\n}\n\n// For complex lists, use ListView.separated\nWidget separatedList() {\n  return ListView.separated(\n    itemCount: 1000,\n    separatorBuilder: (context, index) =&gt; const Divider(),\n    itemBuilder: (context, index) {\n      return ListTile(\n        title: Text('Item $index'),\n      );\n    },\n  );\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#network-issues","title":"Network Issues","text":""},{"location":"troubleshooting/common-issues/#1-http-request-problems","title":"1. HTTP Request Problems","text":""},{"location":"troubleshooting/common-issues/#issue-certificate-verification-failed","title":"Issue: Certificate Verification Failed","text":"<pre><code>// Error message\nHandshakeException: Handshake error in client\n</code></pre> <p>Solution:</p> <pre><code>// For development only - NOT for production\nimport 'dart:io';\n\nclass DevHttpOverrides extends HttpOverrides {\n  @override\n  HttpClient createHttpClient(SecurityContext? context) {\n    return super.createHttpClient(context)\n      ..badCertificateCallback = (X509Certificate cert, String host, int port) =&gt; true;\n  }\n}\n\nvoid main() {\n  if (kDebugMode) {\n    HttpOverrides.global = DevHttpOverrides();\n  }\n  runApp(MyApp());\n}\n\n// Production solution: Use proper certificates\nimport 'package:dio/dio.dart';\nimport 'package:dio_certificate_pinning/dio_certificate_pinning.dart';\n\nfinal dio = Dio();\ndio.interceptors.add(\n  CertificatePinningInterceptor(\n    allowedSHAFingerprints: ['YOUR_CERTIFICATE_FINGERPRINT'],\n  ),\n);\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-timeout-errors","title":"Issue: Timeout Errors","text":"<pre><code>// Error message\nSocketException: OS Error: Connection timed out\n</code></pre> <p>Solution:</p> <pre><code>import 'package:dio/dio.dart';\n\nfinal dio = Dio(BaseOptions(\n  connectTimeout: Duration(seconds: 10),\n  receiveTimeout: Duration(seconds: 10),\n  sendTimeout: Duration(seconds: 10),\n));\n\n// Add retry interceptor\ndio.interceptors.add(\n  RetryInterceptor(\n    dio: dio,\n    logPrint: print,\n    retries: 3,\n    retryDelays: [\n      Duration(seconds: 1),\n      Duration(seconds: 2),\n      Duration(seconds: 3),\n    ],\n  ),\n);\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-api-integration-issues","title":"2. API Integration Issues","text":""},{"location":"troubleshooting/common-issues/#issue-json-parsing-errors","title":"Issue: JSON Parsing Errors","text":"<pre><code>// Error message\ntype 'Null' is not a subtype of type 'String'\n</code></pre> <p>Solution:</p> <pre><code>// Problem: Not handling null values\nclass BadUser {\n  final String name;\n  final String email;\n\n  BadUser.fromJson(Map&lt;String, dynamic&gt; json)\n    : name = json['name'],  // Can be null\n      email = json['email']; // Can be null\n}\n\n// Solution: Handle null values properly\nclass GoodUser {\n  final String name;\n  final String email;\n\n  GoodUser.fromJson(Map&lt;String, dynamic&gt; json)\n    : name = json['name'] ?? '',\n      email = json['email'] ?? '';\n\n  // Or use null-aware operators\n  factory GoodUser.fromJsonSafe(Map&lt;String, dynamic&gt; json) {\n    return GoodUser(\n      name: json['name']?.toString() ?? '',\n      email: json['email']?.toString() ?? '',\n    );\n  }\n}\n\n// Use json_annotation for better handling\nimport 'package:json_annotation/json_annotation.dart';\n\n@JsonSerializable()\nclass User {\n  @JsonKey(defaultValue: '')\n  final String name;\n\n  @JsonKey(defaultValue: '')\n  final String email;\n\n  User({required this.name, required this.email});\n\n  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);\n  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"troubleshooting/common-issues/#1-android-issues","title":"1. Android Issues","text":""},{"location":"troubleshooting/common-issues/#issue-permission-denied","title":"Issue: Permission Denied","text":"<pre><code># Error message\nPlatformException(PERMISSION_DENIED, Permission denied, null)\n</code></pre> <p>Solution:</p> <pre><code>import 'package:permission_handler/permission_handler.dart';\n\nFuture&lt;bool&gt; requestPermission() async {\n  final status = await Permission.camera.request();\n\n  if (status.isGranted) {\n    return true;\n  } else if (status.isPermanentlyDenied) {\n    // Show dialog to open app settings\n    await openAppSettings();\n  }\n\n  return false;\n}\n\n// Check permission before using\nFuture&lt;void&gt; useCamera() async {\n  if (await requestPermission()) {\n    // Use camera\n  } else {\n    // Show error message\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#issue-back-button-handling","title":"Issue: Back Button Handling","text":"<pre><code>// Problem: App exits unexpectedly\nclass BadBackButtonHandling extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(), // No back button handling\n    );\n  }\n}\n</code></pre> <p>Solution:</p> <pre><code>class GoodBackButtonHandling extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return WillPopScope(\n      onWillPop: () async {\n        // Handle back button press\n        final shouldPop = await showDialog&lt;bool&gt;(\n          context: context,\n          builder: (context) =&gt; AlertDialog(\n            title: Text('Exit App'),\n            content: Text('Do you want to exit the app?'),\n            actions: [\n              TextButton(\n                onPressed: () =&gt; Navigator.of(context).pop(false),\n                child: Text('No'),\n              ),\n              TextButton(\n                onPressed: () =&gt; Navigator.of(context).pop(true),\n                child: Text('Yes'),\n              ),\n            ],\n          ),\n        );\n\n        return shouldPop ?? false;\n      },\n      child: Scaffold(\n        body: Container(),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-ios-issues","title":"2. iOS Issues","text":""},{"location":"troubleshooting/common-issues/#issue-safe-area-problems","title":"Issue: Safe Area Problems","text":"<pre><code>// Problem: Content hidden behind notch/home indicator\nclass BadSafeArea extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: [\n          Text('This might be hidden'), // Behind notch\n        ],\n      ),\n    );\n  }\n}\n</code></pre> <p>Solution:</p> <pre><code>class GoodSafeArea extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: Column(\n          children: [\n            Text('This is visible'), // Properly positioned\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Or use MediaQuery for custom handling\nclass CustomSafeArea extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final padding = MediaQuery.of(context).padding;\n\n    return Scaffold(\n      body: Padding(\n        padding: EdgeInsets.only(\n          top: padding.top,\n          bottom: padding.bottom,\n        ),\n        child: Column(\n          children: [\n            Text('Custom safe area handling'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#debugging-strategies","title":"Debugging Strategies","text":""},{"location":"troubleshooting/common-issues/#1-debug-tools","title":"1. Debug Tools","text":"<pre><code>// Enable debug logging\nimport 'package:flutter/foundation.dart';\n\nvoid debugLog(String message) {\n  if (kDebugMode) {\n    print('DEBUG: $message');\n  }\n}\n\n// Use debugPrint for large outputs\nvoid debugLargeOutput(String message) {\n  debugPrint(message);\n}\n\n// Use Flutter Inspector\n// In VS Code: Ctrl+Shift+P -&gt; \"Flutter: Open Widget Inspector\"\n// In Android Studio: Flutter Inspector tab\n</code></pre>"},{"location":"troubleshooting/common-issues/#2-performance-debugging","title":"2. Performance Debugging","text":"<pre><code>// Profile widget rebuilds\nimport 'package:flutter/rendering.dart';\n\nvoid main() {\n  // Enable performance overlay\n  debugProfileBuildsEnabled = true;\n\n  runApp(MyApp());\n}\n\n// Use performance overlay\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      showPerformanceOverlay: kDebugMode,\n      home: MyHomePage(),\n    );\n  }\n}\n</code></pre>"},{"location":"troubleshooting/common-issues/#3-common-debug-commands","title":"3. Common Debug Commands","text":"<pre><code># Flutter debugging commands\nflutter logs                    # View device logs\nflutter analyze                # Static analysis\nflutter test                   # Run tests\nflutter doctor -v              # Detailed doctor output\nflutter clean                  # Clean build cache\nflutter pub deps               # Show dependency tree\nflutter pub outdated           # Check for updates\n\n# Device debugging\nadb logcat                     # Android logs\nxcrun simctl spawn booted log  # iOS simulator logs\n</code></pre> <p>Remember to always check the official Flutter documentation and GitHub issues for the latest solutions to common problems. Many issues have been encountered and solved by the community.</p>"},{"location":"troubleshooting/ios-troubleshooting/","title":"iOS Troubleshooting Guide","text":"<p>Comprehensive troubleshooting guide for common iOS development issues in Flutter projects.</p>"},{"location":"troubleshooting/ios-troubleshooting/#development-environment-issues","title":"Development Environment Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-xcode-command-line-tools","title":"1. Xcode Command Line Tools","text":"<p>Problem: <code>xcode-select: error: tool 'xcodebuild' requires Xcode</code></p> <p>Solution: <pre><code># Install Xcode Command Line Tools\nsudo xcode-select --install\n\n# Verify installation\nxcode-select -p\n\n# If needed, reset the path\nsudo xcode-select --reset\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#2-cocoapods-issues","title":"2. CocoaPods Issues","text":"<p>Problem: <code>CocoaPods not installed</code> or version conflicts</p> <p>Solution: <pre><code># Check Ruby version (should be 2.7+)\nruby --version\n\n# Install CocoaPods\nsudo gem install cocoapods\n\n# If using Homebrew Ruby\nexport PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"\nexport GEM_HOME=\"$HOME/.gem/ruby/3.4.0\"\nexport GEM_PATH=\"$GEM_HOME\"\nexport PATH=\"$GEM_HOME/bin:$PATH\"\ngem install cocoapods\n\n# Update CocoaPods repo\npod repo update\n\n# Clean and reinstall pods\ncd ios\nrm -rf Pods Podfile.lock\npod install --repo-update\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-ios-simulator-issues","title":"3. iOS Simulator Issues","text":"<p>Problem: Simulator not launching or app not installing</p> <p>Solution: <pre><code># Reset simulator\nxcrun simctl erase all\n\n# List available simulators\nxcrun simctl list devices\n\n# Boot specific simulator\nxcrun simctl boot \"iPhone 14 Pro\"\n\n# Install app manually\nxcrun simctl install booted path/to/app.app\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#build-issues","title":"Build Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-archive-build-failures","title":"1. Archive Build Failures","text":"<p>Problem: Build succeeds in debug but fails in release/archive</p> <p>Solution: <pre><code># Clean build folder\nflutter clean\ncd ios\nrm -rf build/\nxcodebuild clean -workspace Runner.xcworkspace -scheme Runner\n\n# Rebuild\nflutter build ios --release\n</code></pre></p> <p>Common Xcode Settings: - Set <code>ENABLE_BITCODE = NO</code> in Build Settings - Ensure <code>iOS Deployment Target</code> matches your minimum version - Check <code>Code Signing</code> settings</p>"},{"location":"troubleshooting/ios-troubleshooting/#2-dependency-conflicts","title":"2. Dependency Conflicts","text":"<p>Problem: <code>The iOS deployment target 'IPHONEOS_DEPLOYMENT_TARGET' is set to 8.0</code></p> <p>Solution: <pre><code># ios/Podfile\nplatform :ios, '11.0'\n\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    flutter_additional_ios_build_settings(target)\n    target.build_configurations.each do |config|\n      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '11.0'\n    end\n  end\nend\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-swift-version-issues","title":"3. Swift Version Issues","text":"<p>Problem: <code>Module compiled with Swift X.X cannot be imported by the Swift Y.Y compiler</code></p> <p>Solution: <pre><code># ios/Podfile\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['SWIFT_VERSION'] = '5.0'\n    end\n  end\nend\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#code-signing-issues","title":"Code Signing Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-provisioning-profile-problems","title":"1. Provisioning Profile Problems","text":"<p>Problem: <code>No provisioning profile found</code> or <code>Code signing error</code></p> <p>Solution: 1. Automatic Signing (Recommended for development):    - Open <code>ios/Runner.xcworkspace</code> in Xcode    - Select Runner target    - Enable \"Automatically manage signing\"    - Select your development team</p> <ol> <li>Manual Signing:</li> <li>Create App ID in Apple Developer Portal</li> <li>Create Development/Distribution certificates</li> <li>Create Provisioning Profiles</li> <li>Download and install profiles</li> </ol>"},{"location":"troubleshooting/ios-troubleshooting/#2-certificate-issues","title":"2. Certificate Issues","text":"<p>Problem: <code>Certificate has expired</code> or <code>No valid signing identity</code></p> <p>Solution: <pre><code># List certificates\nsecurity find-identity -v -p codesigning\n\n# Delete expired certificates from Keychain\n# Open Keychain Access &gt; Certificates &gt; Delete expired ones\n\n# Download new certificates from Apple Developer Portal\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-team-id-issues","title":"3. Team ID Issues","text":"<p>Problem: <code>No account for team</code> or <code>Team ID not found</code></p> <p>Solution: <pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;key&gt;CFBundleIdentifier&lt;/key&gt;\n&lt;string&gt;com.yourteam.yourapp&lt;/string&gt;\n\n&lt;!-- ios/Runner.xcodeproj/project.pbxproj --&gt;\nDEVELOPMENT_TEAM = YOUR_TEAM_ID;\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#runtime-issues","title":"Runtime Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-app-crashes-on-launch","title":"1. App Crashes on Launch","text":"<p>Problem: App crashes immediately after launch on device</p> <p>Debugging Steps: <pre><code># Check device logs\nflutter logs\n\n# Run with verbose logging\nflutter run --verbose\n\n# Check Xcode console for crash logs\n# Window &gt; Devices and Simulators &gt; Select device &gt; View Device Logs\n</code></pre></p> <p>Common Causes: - Missing Info.plist permissions - Incorrect bundle identifier - Missing required frameworks</p>"},{"location":"troubleshooting/ios-troubleshooting/#2-network-issues","title":"2. Network Issues","text":"<p>Problem: Network requests fail on iOS but work on Android</p> <p>Solution: <pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;\n&lt;dict&gt;\n    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;!-- Or for specific domains --&gt;\n    &lt;key&gt;NSExceptionDomains&lt;/key&gt;\n    &lt;dict&gt;\n        &lt;key&gt;your-api-domain.com&lt;/key&gt;\n        &lt;dict&gt;\n            &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt;\n            &lt;true/&gt;\n        &lt;/dict&gt;\n    &lt;/dict&gt;\n&lt;/dict&gt;\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-permission-issues","title":"3. Permission Issues","text":"<p>Problem: Camera, location, or other permissions not working</p> <p>Solution: <pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs camera access to take photos&lt;/string&gt;\n\n&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs location access to show nearby places&lt;/string&gt;\n\n&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs photo library access to select images&lt;/string&gt;\n\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs microphone access to record audio&lt;/string&gt;\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-slow-build-times","title":"1. Slow Build Times","text":"<p>Problem: iOS builds take too long</p> <p>Solutions: <pre><code># Enable parallel builds in Xcode\n# Build Settings &gt; Build Options &gt; Enable \"Parallelize Build\"\n\n# Use build cache\nflutter build ios --build-shared-framework\n\n# Clean derived data\nrm -rf ~/Library/Developer/Xcode/DerivedData\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#2-large-app-size","title":"2. Large App Size","text":"<p>Problem: iOS app size is too large</p> <p>Solutions: <pre><code># Build with tree shaking\nflutter build ios --release --tree-shake-icons\n\n# Analyze app size\nflutter build ios --analyze-size\n\n# Use app bundle\n# Enable in Xcode: Build Settings &gt; Enable App Slicing\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-memory-issues","title":"3. Memory Issues","text":"<p>Problem: App crashes due to memory pressure</p> <p>Debugging: <pre><code>// Monitor memory usage\nimport 'dart:developer' as developer;\n\nvoid checkMemoryUsage() {\n  developer.log('Memory usage: ${ProcessInfo.currentRss ~/ 1024 ~/ 1024} MB');\n}\n\n// Use memory profiler in Xcode\n// Product &gt; Profile &gt; Allocations\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#app-store-issues","title":"App Store Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-upload-failures","title":"1. Upload Failures","text":"<p>Problem: <code>Invalid binary</code> or upload errors</p> <p>Common Solutions: - Ensure all required icons are present - Check Info.plist for required keys - Verify bundle identifier matches App Store Connect - Use Application Loader or Xcode Organizer</p>"},{"location":"troubleshooting/ios-troubleshooting/#2-rejection-issues","title":"2. Rejection Issues","text":"<p>Problem: App rejected during review</p> <p>Common Reasons: - Missing privacy policy - Incomplete App Store information - UI/UX issues - Crash on reviewer's device</p> <p>Prevention: <pre><code>&lt;!-- ios/Runner/Info.plist --&gt;\n&lt;!-- Add all required usage descriptions --&gt;\n&lt;key&gt;NSUserTrackingUsageDescription&lt;/key&gt;\n&lt;string&gt;This app uses tracking to provide personalized ads&lt;/string&gt;\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-testflight-issues","title":"3. TestFlight Issues","text":"<p>Problem: TestFlight build not appearing</p> <p>Solutions: - Check build processing status in App Store Connect - Ensure compliance with export regulations - Verify all required metadata is complete</p>"},{"location":"troubleshooting/ios-troubleshooting/#device-specific-issues","title":"Device-Specific Issues","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-iphone-x-layout-issues","title":"1. iPhone X+ Layout Issues","text":"<p>Problem: UI not adapting to notch/safe areas</p> <p>Solution: <pre><code>// Use SafeArea widget\nSafeArea(\n  child: Scaffold(\n    body: YourContent(),\n  ),\n)\n\n// Or use MediaQuery for custom handling\nWidget build(BuildContext context) {\n  final padding = MediaQuery.of(context).padding;\n  return Container(\n    padding: EdgeInsets.only(\n      top: padding.top,\n      bottom: padding.bottom,\n    ),\n    child: YourContent(),\n  );\n}\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#2-ipad-layout-issues","title":"2. iPad Layout Issues","text":"<p>Problem: App doesn't look good on iPad</p> <p>Solution: <pre><code>// Responsive design\nWidget build(BuildContext context) {\n  final isTablet = MediaQuery.of(context).size.width &gt; 600;\n\n  return isTablet \n    ? TabletLayout()\n    : PhoneLayout();\n}\n\n// Support iPad multitasking\n// ios/Runner/Info.plist\n&lt;key&gt;UIRequiresFullScreen&lt;/key&gt;\n&lt;false/&gt;\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#3-ios-version-compatibility","title":"3. iOS Version Compatibility","text":"<p>Problem: App crashes on older iOS versions</p> <p>Solution: <pre><code>// Check iOS version at runtime\nimport 'dart:io';\n\nbool get isIOS13OrLater {\n  if (!Platform.isIOS) return false;\n  final version = Platform.operatingSystemVersion;\n  // Parse version string and compare\n  return true; // Implement version comparison\n}\n\n// Use conditional features\nif (isIOS13OrLater) {\n  // Use iOS 13+ features\n} else {\n  // Fallback for older versions\n}\n</code></pre></p>"},{"location":"troubleshooting/ios-troubleshooting/#debugging-tools","title":"Debugging Tools","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-xcode-debugger","title":"1. Xcode Debugger","text":"<pre><code># Run with Xcode debugger attached\nflutter run --debug\n\n# Set breakpoints in native code\n# Open ios/Runner.xcworkspace\n# Set breakpoints in AppDelegate.swift or other native files\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#2-instruments","title":"2. Instruments","text":"<pre><code># Profile with Instruments\nflutter build ios --profile\n# Open Xcode &gt; Product &gt; Profile\n# Choose appropriate instrument (Allocations, Time Profiler, etc.)\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#3-console-logs","title":"3. Console Logs","text":"<pre><code>// Add logging for iOS-specific issues\nimport 'dart:developer' as developer;\nimport 'dart:io';\n\nvoid logIOS(String message) {\n  if (Platform.isIOS) {\n    developer.log(message, name: 'iOS');\n  }\n}\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#prevention-strategies","title":"Prevention Strategies","text":""},{"location":"troubleshooting/ios-troubleshooting/#1-continuous-integration","title":"1. Continuous Integration","text":"<pre><code># .github/workflows/ios.yml\nname: iOS Build\non: [push, pull_request]\njobs:\n  build:\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: subosito/flutter-action@v2\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build ios --no-codesign\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#2-automated-testing","title":"2. Automated Testing","text":"<pre><code>// integration_test/ios_specific_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('iOS Specific Tests', () {\n    testWidgets('should handle iOS permissions', (tester) async {\n      // Test iOS-specific functionality\n    });\n  });\n}\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#3-regular-maintenance","title":"3. Regular Maintenance","text":"<pre><code># Weekly maintenance script\n#!/bin/bash\nflutter clean\nflutter pub get\ncd ios\npod repo update\npod install\ncd ..\nflutter doctor\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#quick-reference","title":"Quick Reference","text":""},{"location":"troubleshooting/ios-troubleshooting/#common-commands","title":"Common Commands","text":"<pre><code># Clean everything\nflutter clean &amp;&amp; cd ios &amp;&amp; rm -rf Pods Podfile.lock &amp;&amp; pod install\n\n# Reset simulator\nxcrun simctl erase all\n\n# View device logs\nflutter logs\n\n# Build for release\nflutter build ios --release\n\n# Archive in Xcode\n# Product &gt; Archive\n</code></pre>"},{"location":"troubleshooting/ios-troubleshooting/#useful-xcode-shortcuts","title":"Useful Xcode Shortcuts","text":"<ul> <li><code>\u2318 + Shift + K</code>: Clean Build Folder</li> <li><code>\u2318 + B</code>: Build</li> <li><code>\u2318 + R</code>: Run</li> <li><code>\u2318 + .</code>: Stop</li> <li><code>\u2318 + Shift + O</code>: Open Quickly</li> </ul>"},{"location":"troubleshooting/ios-troubleshooting/#key-files-to-check","title":"Key Files to Check","text":"<ul> <li><code>ios/Podfile</code>: CocoaPods configuration</li> <li><code>ios/Runner/Info.plist</code>: App configuration</li> <li><code>ios/Runner.xcodeproj/project.pbxproj</code>: Xcode project settings</li> <li><code>ios/Runner/AppDelegate.swift</code>: App lifecycle</li> </ul> <p>Remember to always test on real devices before releasing, as simulator behavior can differ from actual device behavior.</p>"},{"location":"ui/animations/","title":"Animations","text":"<p>Comprehensive guide to creating smooth, performant animations in Flutter applications.</p>"},{"location":"ui/animations/#overview","title":"Overview","text":"<p>Animations bring your Flutter app to life, providing visual feedback and enhancing user experience. This guide covers implicit animations, explicit animations, and advanced animation techniques.</p>"},{"location":"ui/animations/#animation-fundamentals","title":"Animation Fundamentals","text":""},{"location":"ui/animations/#1-animation-controller","title":"1. Animation Controller","text":"<pre><code>// lib/widgets/animated_widget_example.dart\nclass AnimatedWidgetExample extends StatefulWidget {\n  @override\n  _AnimatedWidgetExampleState createState() =&gt; _AnimatedWidgetExampleState();\n}\n\nclass _AnimatedWidgetExampleState extends State&lt;AnimatedWidgetExample&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation&lt;double&gt; _animation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    );\n\n    _animation = Tween&lt;double&gt;(\n      begin: 0.0,\n      end: 1.0,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: Curves.easeInOut,\n    ));\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _animation,\n      builder: (context, child) {\n        return Transform.scale(\n          scale: _animation.value,\n          child: Container(\n            width: 100,\n            height: 100,\n            color: Colors.blue,\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#implicit-animations","title":"Implicit Animations","text":""},{"location":"ui/animations/#1-animatedcontainer","title":"1. AnimatedContainer","text":"<pre><code>// lib/widgets/animated_container_example.dart\nclass AnimatedContainerExample extends StatefulWidget {\n  @override\n  _AnimatedContainerExampleState createState() =&gt; _AnimatedContainerExampleState();\n}\n\nclass _AnimatedContainerExampleState extends State&lt;AnimatedContainerExample&gt; {\n  bool _isExpanded = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () =&gt; setState(() =&gt; _isExpanded = !_isExpanded),\n      child: AnimatedContainer(\n        duration: const Duration(milliseconds: 300),\n        curve: Curves.easeInOut,\n        width: _isExpanded ? 200 : 100,\n        height: _isExpanded ? 200 : 100,\n        decoration: BoxDecoration(\n          color: _isExpanded ? Colors.red : Colors.blue,\n          borderRadius: BorderRadius.circular(_isExpanded ? 20 : 10),\n        ),\n        child: const Center(\n          child: Text('Tap me!', style: TextStyle(color: Colors.white)),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#2-animatedopacity","title":"2. AnimatedOpacity","text":"<pre><code>// lib/widgets/fade_transition_widget.dart\nclass FadeTransitionWidget extends StatefulWidget {\n  final Widget child;\n  final bool visible;\n\n  const FadeTransitionWidget({\n    Key? key,\n    required this.child,\n    required this.visible,\n  }) : super(key: key);\n\n  @override\n  _FadeTransitionWidgetState createState() =&gt; _FadeTransitionWidgetState();\n}\n\nclass _FadeTransitionWidgetState extends State&lt;FadeTransitionWidget&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedOpacity(\n      opacity: widget.visible ? 1.0 : 0.0,\n      duration: const Duration(milliseconds: 300),\n      child: widget.child,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#3-animatedpositioned","title":"3. AnimatedPositioned","text":"<pre><code>// lib/widgets/sliding_panel.dart\nclass SlidingPanel extends StatefulWidget {\n  final Widget child;\n  final bool isOpen;\n\n  const SlidingPanel({\n    Key? key,\n    required this.child,\n    required this.isOpen,\n  }) : super(key: key);\n\n  @override\n  _SlidingPanelState createState() =&gt; _SlidingPanelState();\n}\n\nclass _SlidingPanelState extends State&lt;SlidingPanel&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        AnimatedPositioned(\n          duration: const Duration(milliseconds: 300),\n          curve: Curves.easeInOut,\n          bottom: widget.isOpen ? 0 : -300,\n          left: 0,\n          right: 0,\n          height: 300,\n          child: Container(\n            decoration: const BoxDecoration(\n              color: Colors.white,\n              borderRadius: BorderRadius.vertical(top: Radius.circular(20)),\n              boxShadow: [\n                BoxShadow(\n                  color: Colors.black26,\n                  blurRadius: 10,\n                  offset: Offset(0, -2),\n                ),\n              ],\n            ),\n            child: widget.child,\n          ),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#explicit-animations","title":"Explicit Animations","text":""},{"location":"ui/animations/#1-custom-tween-animations","title":"1. Custom Tween Animations","text":"<pre><code>// lib/animations/custom_tween_animation.dart\nclass BouncingBall extends StatefulWidget {\n  @override\n  _BouncingBallState createState() =&gt; _BouncingBallState();\n}\n\nclass _BouncingBallState extends State&lt;BouncingBall&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation&lt;double&gt; _bounceAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 1),\n      vsync: this,\n    );\n\n    _bounceAnimation = Tween&lt;double&gt;(\n      begin: 0.0,\n      end: 200.0,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: Curves.bounceOut,\n    ));\n\n    _controller.repeat(reverse: true);\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _bounceAnimation,\n      builder: (context, child) {\n        return Transform.translate(\n          offset: Offset(0, _bounceAnimation.value),\n          child: Container(\n            width: 50,\n            height: 50,\n            decoration: const BoxDecoration(\n              color: Colors.red,\n              shape: BoxShape.circle,\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#2-staggered-animations","title":"2. Staggered Animations","text":"<pre><code>// lib/animations/staggered_animation.dart\nclass StaggeredAnimation extends StatefulWidget {\n  @override\n  _StaggeredAnimationState createState() =&gt; _StaggeredAnimationState();\n}\n\nclass _StaggeredAnimationState extends State&lt;StaggeredAnimation&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation&lt;double&gt; _scaleAnimation;\n  late Animation&lt;double&gt; _fadeAnimation;\n  late Animation&lt;Offset&gt; _slideAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    );\n\n    _scaleAnimation = Tween&lt;double&gt;(\n      begin: 0.0,\n      end: 1.0,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: const Interval(0.0, 0.5, curve: Curves.easeOut),\n    ));\n\n    _fadeAnimation = Tween&lt;double&gt;(\n      begin: 0.0,\n      end: 1.0,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: const Interval(0.3, 0.8, curve: Curves.easeIn),\n    ));\n\n    _slideAnimation = Tween&lt;Offset&gt;(\n      begin: const Offset(0, 1),\n      end: Offset.zero,\n    ).animate(CurvedAnimation(\n      parent: _controller,\n      curve: const Interval(0.5, 1.0, curve: Curves.elasticOut),\n    ));\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  void _startAnimation() {\n    _controller.forward();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        AnimatedBuilder(\n          animation: _controller,\n          builder: (context, child) {\n            return Transform.scale(\n              scale: _scaleAnimation.value,\n              child: FadeTransition(\n                opacity: _fadeAnimation,\n                child: SlideTransition(\n                  position: _slideAnimation,\n                  child: Container(\n                    width: 100,\n                    height: 100,\n                    decoration: BoxDecoration(\n                      color: Colors.blue,\n                      borderRadius: BorderRadius.circular(10),\n                    ),\n                    child: const Center(\n                      child: Text(\n                        'Animated!',\n                        style: TextStyle(color: Colors.white),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            );\n          },\n        ),\n        const SizedBox(height: 20),\n        ElevatedButton(\n          onPressed: _startAnimation,\n          child: const Text('Start Animation'),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#page-transitions","title":"Page Transitions","text":""},{"location":"ui/animations/#1-custom-page-route","title":"1. Custom Page Route","text":"<pre><code>// lib/animations/custom_page_route.dart\nclass SlidePageRoute&lt;T&gt; extends PageRouteBuilder&lt;T&gt; {\n  final Widget child;\n  final Offset beginOffset;\n  final Offset endOffset;\n\n  SlidePageRoute({\n    required this.child,\n    this.beginOffset = const Offset(1.0, 0.0),\n    this.endOffset = Offset.zero,\n    RouteSettings? settings,\n  }) : super(\n    settings: settings,\n    pageBuilder: (context, animation, secondaryAnimation) =&gt; child,\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return SlideTransition(\n        position: Tween&lt;Offset&gt;(\n          begin: beginOffset,\n          end: endOffset,\n        ).animate(CurvedAnimation(\n          parent: animation,\n          curve: Curves.easeInOut,\n        )),\n        child: child,\n      );\n    },\n    transitionDuration: const Duration(milliseconds: 300),\n  );\n}\n\nclass FadePageRoute&lt;T&gt; extends PageRouteBuilder&lt;T&gt; {\n  final Widget child;\n\n  FadePageRoute({\n    required this.child,\n    RouteSettings? settings,\n  }) : super(\n    settings: settings,\n    pageBuilder: (context, animation, secondaryAnimation) =&gt; child,\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      return FadeTransition(\n        opacity: animation,\n        child: child,\n      );\n    },\n    transitionDuration: const Duration(milliseconds: 300),\n  );\n}\n</code></pre>"},{"location":"ui/animations/#2-hero-animations","title":"2. Hero Animations","text":"<pre><code>// lib/widgets/hero_animation_example.dart\nclass HeroAnimationExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Hero Animation')),\n      body: Center(\n        child: GestureDetector(\n          onTap: () {\n            Navigator.of(context).push(\n              MaterialPageRoute(\n                builder: (context) =&gt; const DetailScreen(),\n              ),\n            );\n          },\n          child: Hero(\n            tag: 'hero-image',\n            child: Container(\n              width: 100,\n              height: 100,\n              decoration: BoxDecoration(\n                color: Colors.blue,\n                borderRadius: BorderRadius.circular(10),\n              ),\n              child: const Center(\n                child: Text(\n                  'Tap me!',\n                  style: TextStyle(color: Colors.white),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  const DetailScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detail')),\n      body: Center(\n        child: Hero(\n          tag: 'hero-image',\n          child: Container(\n            width: 300,\n            height: 300,\n            decoration: BoxDecoration(\n              color: Colors.blue,\n              borderRadius: BorderRadius.circular(20),\n            ),\n            child: const Center(\n              child: Text(\n                'Expanded!',\n                style: TextStyle(\n                  color: Colors.white,\n                  fontSize: 24,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#list-animations","title":"List Animations","text":""},{"location":"ui/animations/#1-animatedlist","title":"1. AnimatedList","text":"<pre><code>// lib/widgets/animated_list_example.dart\nclass AnimatedListExample extends StatefulWidget {\n  @override\n  _AnimatedListExampleState createState() =&gt; _AnimatedListExampleState();\n}\n\nclass _AnimatedListExampleState extends State&lt;AnimatedListExample&gt; {\n  final GlobalKey&lt;AnimatedListState&gt; _listKey = GlobalKey&lt;AnimatedListState&gt;();\n  final List&lt;String&gt; _items = ['Item 1', 'Item 2', 'Item 3'];\n\n  void _addItem() {\n    final index = _items.length;\n    _items.insert(index, 'Item ${index + 1}');\n    _listKey.currentState?.insertItem(index);\n  }\n\n  void _removeItem(int index) {\n    final removedItem = _items.removeAt(index);\n    _listKey.currentState?.removeItem(\n      index,\n      (context, animation) =&gt; _buildItem(removedItem, animation),\n    );\n  }\n\n  Widget _buildItem(String item, Animation&lt;double&gt; animation) {\n    return SlideTransition(\n      position: animation.drive(\n        Tween&lt;Offset&gt;(\n          begin: const Offset(1, 0),\n          end: Offset.zero,\n        ),\n      ),\n      child: Card(\n        child: ListTile(\n          title: Text(item),\n          trailing: IconButton(\n            icon: const Icon(Icons.delete),\n            onPressed: () =&gt; _removeItem(_items.indexOf(item)),\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Animated List')),\n      body: AnimatedList(\n        key: _listKey,\n        initialItemCount: _items.length,\n        itemBuilder: (context, index, animation) {\n          return _buildItem(_items[index], animation);\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addItem,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#performance-optimization","title":"Performance Optimization","text":""},{"location":"ui/animations/#1-animation-performance-tips","title":"1. Animation Performance Tips","text":"<pre><code>// lib/widgets/optimized_animation.dart\nclass OptimizedAnimation extends StatefulWidget {\n  @override\n  _OptimizedAnimationState createState() =&gt; _OptimizedAnimationState();\n}\n\nclass _OptimizedAnimationState extends State&lt;OptimizedAnimation&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation&lt;double&gt; _animation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(milliseconds: 300),\n      vsync: this,\n    );\n\n    // Use RepaintBoundary to isolate repaints\n    _animation = _controller.drive(Tween&lt;double&gt;(begin: 0.0, end: 1.0));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return RepaintBoundary(\n      child: AnimatedBuilder(\n        animation: _animation,\n        builder: (context, child) {\n          return Transform.scale(\n            scale: _animation.value,\n            child: child,\n          );\n        },\n        // Use child parameter to avoid rebuilding static content\n        child: const ExpensiveWidget(),\n      ),\n    );\n  }\n}\n\nclass ExpensiveWidget extends StatelessWidget {\n  const ExpensiveWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // Expensive widget that doesn't need to rebuild\n    return Container(\n      width: 100,\n      height: 100,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: [Colors.blue, Colors.purple],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/animations/#2-animation-utilities","title":"2. Animation Utilities","text":"<pre><code>// lib/utils/animation_utils.dart\nclass AnimationUtils {\n  static Animation&lt;T&gt; createDelayedAnimation&lt;T&gt;({\n    required AnimationController controller,\n    required Tween&lt;T&gt; tween,\n    double delay = 0.0,\n    Curve curve = Curves.easeInOut,\n  }) {\n    final start = delay;\n    final end = 1.0;\n\n    return tween.animate(\n      CurvedAnimation(\n        parent: controller,\n        curve: Interval(start, end, curve: curve),\n      ),\n    );\n  }\n\n  static void staggeredAnimation({\n    required List&lt;AnimationController&gt; controllers,\n    required Duration staggerDelay,\n    bool reverse = false,\n  }) {\n    for (int i = 0; i &lt; controllers.length; i++) {\n      final delay = reverse \n        ? staggerDelay * (controllers.length - 1 - i)\n        : staggerDelay * i;\n\n      Timer(delay, () {\n        controllers[i].forward();\n      });\n    }\n  }\n}\n</code></pre>"},{"location":"ui/animations/#testing-animations","title":"Testing Animations","text":""},{"location":"ui/animations/#1-animation-testing","title":"1. Animation Testing","text":"<pre><code>// test/animation_test.dart\nvoid main() {\n  group('Animation Tests', () {\n    testWidgets('should animate scale from 0 to 1', (tester) async {\n      await tester.pumpWidget(MaterialApp(\n        home: AnimatedWidgetExample(),\n      ));\n\n      // Find the animated widget\n      final animatedWidget = find.byType(AnimatedWidgetExample);\n      expect(animatedWidget, findsOneWidget);\n\n      // Trigger animation\n      await tester.tap(find.byType(GestureDetector));\n      await tester.pump();\n\n      // Test animation at different points\n      await tester.pump(const Duration(milliseconds: 500));\n      // Add assertions for intermediate state\n\n      await tester.pump(const Duration(milliseconds: 1000));\n      // Add assertions for final state\n    });\n  });\n}\n</code></pre>"},{"location":"ui/animations/#best-practices","title":"Best Practices","text":""},{"location":"ui/animations/#1-animation-guidelines","title":"1. Animation Guidelines","text":"<pre><code>// Follow Material Design motion principles\nclass MaterialMotion {\n  static const Duration shortDuration = Duration(milliseconds: 150);\n  static const Duration mediumDuration = Duration(milliseconds: 300);\n  static const Duration longDuration = Duration(milliseconds: 500);\n\n  static const Curve standardCurve = Curves.easeInOut;\n  static const Curve accelerateCurve = Curves.easeIn;\n  static const Curve decelerateCurve = Curves.easeOut;\n}\n</code></pre>"},{"location":"ui/animations/#2-memory-management","title":"2. Memory Management","text":"<pre><code>// Always dispose animation controllers\n@override\nvoid dispose() {\n  _controller.dispose();\n  super.dispose();\n}\n\n// Use SingleTickerProviderStateMixin for single animations\n// Use TickerProviderStateMixin for multiple animations\n</code></pre> <p>Animations should enhance user experience without overwhelming it. Use them purposefully to guide attention and provide feedback.</p>"},{"location":"ui/cross-platform-design/","title":"Cross-Platform Design","text":"<p>Guide to creating consistent user experiences across iOS, Android, and Web platforms while respecting platform conventions.</p>"},{"location":"ui/cross-platform-design/#overview","title":"Overview","text":"<p>Cross-platform design in Flutter involves balancing consistency with platform-specific conventions. This guide covers adaptive design patterns, platform-specific widgets, and design system implementation.</p>"},{"location":"ui/cross-platform-design/#platform-detection","title":"Platform Detection","text":""},{"location":"ui/cross-platform-design/#1-platform-utilities","title":"1. Platform Utilities","text":"<pre><code>// lib/utils/platform_utils.dart\nimport 'dart:io';\nimport 'package:flutter/foundation.dart';\n\nclass PlatformUtils {\n  static bool get isIOS =&gt; !kIsWeb &amp;&amp; Platform.isIOS;\n  static bool get isAndroid =&gt; !kIsWeb &amp;&amp; Platform.isAndroid;\n  static bool get isWeb =&gt; kIsWeb;\n  static bool get isMobile =&gt; isIOS || isAndroid;\n  static bool get isDesktop =&gt; !kIsWeb &amp;&amp; (Platform.isWindows || Platform.isMacOS || Platform.isLinux);\n\n  static TargetPlatform get currentPlatform {\n    if (kIsWeb) return TargetPlatform.android; // Default for web\n    return defaultTargetPlatform;\n  }\n\n  static bool get supportsHapticFeedback =&gt; isIOS || isAndroid;\n  static bool get supportsBiometrics =&gt; isIOS || isAndroid;\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-platform-aware-widgets","title":"2. Platform-Aware Widgets","text":"<pre><code>// lib/widgets/platform_widget.dart\nabstract class PlatformWidget&lt;I extends Widget, A extends Widget&gt; extends StatelessWidget {\n  const PlatformWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return buildIOS(context);\n    }\n    return buildAndroid(context);\n  }\n\n  I buildIOS(BuildContext context);\n  A buildAndroid(BuildContext context);\n}\n\n// Usage example\nclass PlatformButton extends PlatformWidget&lt;CupertinoButton, ElevatedButton&gt; {\n  final String text;\n  final VoidCallback onPressed;\n\n  const PlatformButton({\n    Key? key,\n    required this.text,\n    required this.onPressed,\n  }) : super(key: key);\n\n  @override\n  CupertinoButton buildIOS(BuildContext context) {\n    return CupertinoButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n\n  @override\n  ElevatedButton buildAndroid(BuildContext context) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#navigation-patterns","title":"Navigation Patterns","text":""},{"location":"ui/cross-platform-design/#1-adaptive-navigation","title":"1. Adaptive Navigation","text":"<pre><code>// lib/widgets/adaptive_navigation.dart\nclass AdaptiveScaffold extends StatelessWidget {\n  final Widget body;\n  final String title;\n  final List&lt;Widget&gt;? actions;\n  final Widget? floatingActionButton;\n\n  const AdaptiveScaffold({\n    Key? key,\n    required this.body,\n    required this.title,\n    this.actions,\n    this.floatingActionButton,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return CupertinoPageScaffold(\n        navigationBar: CupertinoNavigationBar(\n          middle: Text(title),\n          trailing: actions != null ? Row(\n            mainAxisSize: MainAxisSize.min,\n            children: actions!,\n          ) : null,\n        ),\n        child: SafeArea(child: body),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n        actions: actions,\n      ),\n      body: body,\n      floatingActionButton: floatingActionButton,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-platform-specific-routing","title":"2. Platform-Specific Routing","text":"<pre><code>// lib/navigation/platform_route.dart\nclass PlatformRoute&lt;T&gt; extends PageRouteBuilder&lt;T&gt; {\n  final Widget child;\n  final String? title;\n\n  PlatformRoute({\n    required this.child,\n    this.title,\n    RouteSettings? settings,\n  }) : super(\n    settings: settings,\n    pageBuilder: (context, animation, secondaryAnimation) =&gt; child,\n    transitionsBuilder: (context, animation, secondaryAnimation, child) {\n      if (PlatformUtils.isIOS) {\n        return CupertinoPageTransition(\n          primaryRouteAnimation: animation,\n          secondaryRouteAnimation: secondaryAnimation,\n          child: child,\n          linearTransition: false,\n        );\n      }\n\n      return SlideTransition(\n        position: animation.drive(\n          Tween(begin: const Offset(1.0, 0.0), end: Offset.zero)\n            .chain(CurveTween(curve: Curves.ease)),\n        ),\n        child: child,\n      );\n    },\n  );\n}\n\n// Navigation helper\nclass PlatformNavigator {\n  static Future&lt;T?&gt; push&lt;T&gt;(BuildContext context, Widget page, {String? title}) {\n    return Navigator.of(context).push&lt;T&gt;(\n      PlatformRoute&lt;T&gt;(child: page, title: title),\n    );\n  }\n\n  static void pop&lt;T&gt;(BuildContext context, [T? result]) {\n    Navigator.of(context).pop(result);\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#ui-components","title":"UI Components","text":""},{"location":"ui/cross-platform-design/#1-platform-adaptive-dialogs","title":"1. Platform-Adaptive Dialogs","text":"<pre><code>// lib/widgets/platform_dialog.dart\nclass PlatformDialog {\n  static Future&lt;bool?&gt; showConfirmDialog(\n    BuildContext context, {\n    required String title,\n    required String content,\n    String confirmText = 'OK',\n    String cancelText = 'Cancel',\n  }) {\n    if (PlatformUtils.isIOS) {\n      return showCupertinoDialog&lt;bool&gt;(\n        context: context,\n        builder: (context) =&gt; CupertinoAlertDialog(\n          title: Text(title),\n          content: Text(content),\n          actions: [\n            CupertinoDialogAction(\n              onPressed: () =&gt; Navigator.of(context).pop(false),\n              child: Text(cancelText),\n            ),\n            CupertinoDialogAction(\n              onPressed: () =&gt; Navigator.of(context).pop(true),\n              isDefaultAction: true,\n              child: Text(confirmText),\n            ),\n          ],\n        ),\n      );\n    }\n\n    return showDialog&lt;bool&gt;(\n      context: context,\n      builder: (context) =&gt; AlertDialog(\n        title: Text(title),\n        content: Text(content),\n        actions: [\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(false),\n            child: Text(cancelText),\n          ),\n          TextButton(\n            onPressed: () =&gt; Navigator.of(context).pop(true),\n            child: Text(confirmText),\n          ),\n        ],\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-platform-adaptive-loading","title":"2. Platform-Adaptive Loading","text":"<pre><code>// lib/widgets/platform_loading.dart\nclass PlatformLoading extends StatelessWidget {\n  final double? size;\n  final Color? color;\n\n  const PlatformLoading({\n    Key? key,\n    this.size,\n    this.color,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return CupertinoActivityIndicator(\n        radius: size != null ? size! / 2 : 10.0,\n        color: color,\n      );\n    }\n\n    return SizedBox(\n      width: size ?? 20.0,\n      height: size ?? 20.0,\n      child: CircularProgressIndicator(\n        strokeWidth: 2.0,\n        valueColor: color != null ? AlwaysStoppedAnimation(color) : null,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#3-platform-adaptive-switch","title":"3. Platform-Adaptive Switch","text":"<pre><code>// lib/widgets/platform_switch.dart\nclass PlatformSwitch extends StatelessWidget {\n  final bool value;\n  final ValueChanged&lt;bool&gt; onChanged;\n  final Color? activeColor;\n\n  const PlatformSwitch({\n    Key? key,\n    required this.value,\n    required this.onChanged,\n    this.activeColor,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return CupertinoSwitch(\n        value: value,\n        onChanged: onChanged,\n        activeColor: activeColor,\n      );\n    }\n\n    return Switch(\n      value: value,\n      onChanged: onChanged,\n      activeColor: activeColor,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#design-system-integration","title":"Design System Integration","text":""},{"location":"ui/cross-platform-design/#1-platform-aware-theme","title":"1. Platform-Aware Theme","text":"<pre><code>// lib/theme/platform_theme.dart\nclass PlatformTheme {\n  static ThemeData getTheme(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return ThemeData(\n        cupertinoOverrideTheme: const CupertinoThemeData(\n          primaryColor: CupertinoColors.systemBlue,\n        ),\n        colorScheme: ColorScheme.fromSeed(\n          seedColor: CupertinoColors.systemBlue,\n        ),\n      );\n    }\n\n    return ThemeData(\n      useMaterial3: true,\n      colorScheme: ColorScheme.fromSeed(\n        seedColor: Colors.blue,\n      ),\n    );\n  }\n\n  static CupertinoThemeData getCupertinoTheme() {\n    return const CupertinoThemeData(\n      primaryColor: CupertinoColors.systemBlue,\n      brightness: Brightness.light,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-typography-adaptation","title":"2. Typography Adaptation","text":"<pre><code>// lib/theme/platform_typography.dart\nclass PlatformTypography {\n  static TextTheme getTextTheme(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return const TextTheme(\n        headlineLarge: TextStyle(\n          fontSize: 34,\n          fontWeight: FontWeight.bold,\n          fontFamily: '.SF UI Display',\n        ),\n        headlineMedium: TextStyle(\n          fontSize: 28,\n          fontWeight: FontWeight.bold,\n          fontFamily: '.SF UI Display',\n        ),\n        bodyLarge: TextStyle(\n          fontSize: 17,\n          fontFamily: '.SF UI Text',\n        ),\n        bodyMedium: TextStyle(\n          fontSize: 15,\n          fontFamily: '.SF UI Text',\n        ),\n      );\n    }\n\n    return const TextTheme(\n      headlineLarge: TextStyle(\n        fontSize: 32,\n        fontWeight: FontWeight.bold,\n        fontFamily: 'Roboto',\n      ),\n      headlineMedium: TextStyle(\n        fontSize: 24,\n        fontWeight: FontWeight.bold,\n        fontFamily: 'Roboto',\n      ),\n      bodyLarge: TextStyle(\n        fontSize: 16,\n        fontFamily: 'Roboto',\n      ),\n      bodyMedium: TextStyle(\n        fontSize: 14,\n        fontFamily: 'Roboto',\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#platform-specific-features","title":"Platform-Specific Features","text":""},{"location":"ui/cross-platform-design/#1-haptic-feedback","title":"1. Haptic Feedback","text":"<pre><code>// lib/services/haptic_service.dart\nimport 'package:flutter/services.dart';\n\nclass HapticService {\n  static Future&lt;void&gt; lightImpact() async {\n    if (PlatformUtils.supportsHapticFeedback) {\n      await HapticFeedback.lightImpact();\n    }\n  }\n\n  static Future&lt;void&gt; mediumImpact() async {\n    if (PlatformUtils.supportsHapticFeedback) {\n      await HapticFeedback.mediumImpact();\n    }\n  }\n\n  static Future&lt;void&gt; heavyImpact() async {\n    if (PlatformUtils.supportsHapticFeedback) {\n      await HapticFeedback.heavyImpact();\n    }\n  }\n\n  static Future&lt;void&gt; selectionClick() async {\n    if (PlatformUtils.supportsHapticFeedback) {\n      await HapticFeedback.selectionClick();\n    }\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-platform-specific-icons","title":"2. Platform-Specific Icons","text":"<pre><code>// lib/widgets/platform_icon.dart\nclass PlatformIcon extends StatelessWidget {\n  final PlatformIconData iconData;\n  final double? size;\n  final Color? color;\n\n  const PlatformIcon(\n    this.iconData, {\n    Key? key,\n    this.size,\n    this.color,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isIOS) {\n      return Icon(\n        iconData.ios,\n        size: size,\n        color: color,\n      );\n    }\n\n    return Icon(\n      iconData.android,\n      size: size,\n      color: color,\n    );\n  }\n}\n\nclass PlatformIconData {\n  final IconData ios;\n  final IconData android;\n\n  const PlatformIconData({\n    required this.ios,\n    required this.android,\n  });\n\n  // Common icons\n  static const PlatformIconData home = PlatformIconData(\n    ios: CupertinoIcons.home,\n    android: Icons.home,\n  );\n\n  static const PlatformIconData settings = PlatformIconData(\n    ios: CupertinoIcons.settings,\n    android: Icons.settings,\n  );\n\n  static const PlatformIconData search = PlatformIconData(\n    ios: CupertinoIcons.search,\n    android: Icons.search,\n  );\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#web-adaptations","title":"Web Adaptations","text":""},{"location":"ui/cross-platform-design/#1-web-specific-layouts","title":"1. Web-Specific Layouts","text":"<pre><code>// lib/widgets/web_adaptive_layout.dart\nclass WebAdaptiveLayout extends StatelessWidget {\n  final Widget child;\n  final double maxWidth;\n\n  const WebAdaptiveLayout({\n    Key? key,\n    required this.child,\n    this.maxWidth = 1200,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (PlatformUtils.isWeb) {\n      return Center(\n        child: ConstrainedBox(\n          constraints: BoxConstraints(maxWidth: maxWidth),\n          child: child,\n        ),\n      );\n    }\n\n    return child;\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-mouse-and-keyboard-support","title":"2. Mouse and Keyboard Support","text":"<pre><code>// lib/widgets/web_enhanced_widget.dart\nclass WebEnhancedWidget extends StatefulWidget {\n  final Widget child;\n  final VoidCallback? onTap;\n\n  const WebEnhancedWidget({\n    Key? key,\n    required this.child,\n    this.onTap,\n  }) : super(key: key);\n\n  @override\n  _WebEnhancedWidgetState createState() =&gt; _WebEnhancedWidgetState();\n}\n\nclass _WebEnhancedWidgetState extends State&lt;WebEnhancedWidget&gt; {\n  bool _isHovered = false;\n\n  @override\n  Widget build(BuildContext context) {\n    if (!PlatformUtils.isWeb) {\n      return GestureDetector(\n        onTap: widget.onTap,\n        child: widget.child,\n      );\n    }\n\n    return MouseRegion(\n      onEnter: (_) =&gt; setState(() =&gt; _isHovered = true),\n      onExit: (_) =&gt; setState(() =&gt; _isHovered = false),\n      cursor: widget.onTap != null ? SystemMouseCursors.click : SystemMouseCursors.basic,\n      child: GestureDetector(\n        onTap: widget.onTap,\n        child: AnimatedContainer(\n          duration: const Duration(milliseconds: 200),\n          transform: _isHovered ? (Matrix4.identity()..scale(1.05)) : Matrix4.identity(),\n          child: widget.child,\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#testing-cross-platform-design","title":"Testing Cross-Platform Design","text":""},{"location":"ui/cross-platform-design/#1-platform-testing","title":"1. Platform Testing","text":"<pre><code>// test/platform_widget_test.dart\nvoid main() {\n  group('Platform Widget Tests', () {\n    testWidgets('should show iOS widget on iOS platform', (tester) async {\n      debugDefaultTargetPlatformOverride = TargetPlatform.iOS;\n\n      await tester.pumpWidget(MaterialApp(\n        home: PlatformButton(\n          text: 'Test',\n          onPressed: () {},\n        ),\n      ));\n\n      expect(find.byType(CupertinoButton), findsOneWidget);\n      expect(find.byType(ElevatedButton), findsNothing);\n\n      debugDefaultTargetPlatformOverride = null;\n    });\n\n    testWidgets('should show Android widget on Android platform', (tester) async {\n      debugDefaultTargetPlatformOverride = TargetPlatform.android;\n\n      await tester.pumpWidget(MaterialApp(\n        home: PlatformButton(\n          text: 'Test',\n          onPressed: () {},\n        ),\n      ));\n\n      expect(find.byType(ElevatedButton), findsOneWidget);\n      expect(find.byType(CupertinoButton), findsNothing);\n\n      debugDefaultTargetPlatformOverride = null;\n    });\n  });\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#best-practices","title":"Best Practices","text":""},{"location":"ui/cross-platform-design/#1-consistent-behavior","title":"1. Consistent Behavior","text":"<pre><code>// Ensure consistent behavior across platforms\nclass PlatformConsistentWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return PlatformWidget(\n      ios: CupertinoButton(\n        onPressed: _handlePress,\n        child: Text('Button'),\n      ),\n      android: ElevatedButton(\n        onPressed: _handlePress,\n        child: Text('Button'),\n      ),\n    );\n  }\n\n  void _handlePress() {\n    // Same behavior on both platforms\n    HapticService.lightImpact();\n    // Handle button press\n  }\n}\n</code></pre>"},{"location":"ui/cross-platform-design/#2-performance-considerations","title":"2. Performance Considerations","text":"<pre><code>// Use platform detection sparingly\nclass OptimizedPlatformWidget extends StatelessWidget {\n  static final bool _isIOS = PlatformUtils.isIOS;\n\n  @override\n  Widget build(BuildContext context) {\n    // Cache platform detection result\n    if (_isIOS) {\n      return _buildIOSWidget();\n    }\n    return _buildAndroidWidget();\n  }\n}\n</code></pre> <p>Cross-platform design requires balancing consistency with platform conventions. Focus on creating familiar experiences while maintaining your app's unique identity.</p>"},{"location":"ui/design-systems/","title":"Flutter UI/UX Design Systems","text":"<p>Comprehensive guide to implementing consistent, accessible, and beautiful user interfaces in Flutter applications.</p>"},{"location":"ui/design-systems/#design-system-overview","title":"Design System Overview","text":"<p>A design system provides a unified visual language and component library for consistent user experiences across platforms.</p>"},{"location":"ui/design-systems/#core-principles","title":"Core Principles","text":"<ol> <li>Consistency: Uniform visual elements and interactions</li> <li>Accessibility: Inclusive design for all users</li> <li>Scalability: Components that work across different screen sizes</li> <li>Performance: Optimized for smooth animations and interactions</li> </ol>"},{"location":"ui/design-systems/#material-design-3","title":"Material Design 3","text":"<p>Flutter's default design system based on Google's Material Design 3.</p>"},{"location":"ui/design-systems/#theme-configuration","title":"Theme Configuration","text":"<pre><code>// lib/core/theme/app_theme.dart\nimport 'package:flutter/material.dart';\n\nclass AppTheme {\n  static ThemeData lightTheme = ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: const Color(0xFF1976D2),\n      brightness: Brightness.light,\n    ),\n    appBarTheme: const AppBarTheme(\n      centerTitle: true,\n      elevation: 0,\n      scrolledUnderElevation: 1,\n    ),\n    cardTheme: CardTheme(\n      elevation: 2,\n      shape: RoundedRectangleBorder(\n        borderRadius: BorderRadius.circular(12),\n      ),\n    ),\n    elevatedButtonTheme: ElevatedButtonThemeData(\n      style: ElevatedButton.styleFrom(\n        shape: RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(8),\n        ),\n        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),\n      ),\n    ),\n    inputDecorationTheme: InputDecorationTheme(\n      border: OutlineInputBorder(\n        borderRadius: BorderRadius.circular(8),\n      ),\n      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),\n    ),\n  );\n\n  static ThemeData darkTheme = ThemeData(\n    useMaterial3: true,\n    colorScheme: ColorScheme.fromSeed(\n      seedColor: const Color(0xFF1976D2),\n      brightness: Brightness.dark,\n    ),\n    appBarTheme: const AppBarTheme(\n      centerTitle: true,\n      elevation: 0,\n      scrolledUnderElevation: 1,\n    ),\n  );\n}\n</code></pre>"},{"location":"ui/design-systems/#color-system","title":"Color System","text":"<pre><code>// lib/core/theme/app_colors.dart\nimport 'package:flutter/material.dart';\n\nclass AppColors {\n  // Primary Colors\n  static const Color primary = Color(0xFF1976D2);\n  static const Color primaryVariant = Color(0xFF1565C0);\n  static const Color secondary = Color(0xFFE91E63);\n\n  // Neutral Colors\n  static const Color background = Color(0xFFFAFAFA);\n  static const Color surface = Color(0xFFFFFFFF);\n  static const Color error = Color(0xFFD32F2F);\n\n  // Text Colors\n  static const Color textPrimary = Color(0xFF212121);\n  static const Color textSecondary = Color(0xFF757575);\n  static const Color textHint = Color(0xFFBDBDBD);\n\n  // Instagram-specific Colors\n  static const Color instagramBlue = Color(0xFF3897F0);\n  static const Color instagramPink = Color(0xFFE4405F);\n  static const Color instagramOrange = Color(0xFFF56040);\n  static const Color instagramYellow = Color(0xFFFCAF45);\n\n  // Gradient\n  static const LinearGradient instagramGradient = LinearGradient(\n    colors: [instagramPink, instagramOrange, instagramYellow],\n    begin: Alignment.topLeft,\n    end: Alignment.bottomRight,\n  );\n}\n</code></pre>"},{"location":"ui/design-systems/#typography","title":"Typography","text":"<pre><code>// lib/core/theme/app_typography.dart\nimport 'package:flutter/material.dart';\n\nclass AppTypography {\n  static const TextTheme textTheme = TextTheme(\n    displayLarge: TextStyle(\n      fontSize: 32,\n      fontWeight: FontWeight.bold,\n      letterSpacing: -0.5,\n    ),\n    displayMedium: TextStyle(\n      fontSize: 28,\n      fontWeight: FontWeight.bold,\n      letterSpacing: -0.25,\n    ),\n    headlineLarge: TextStyle(\n      fontSize: 24,\n      fontWeight: FontWeight.w600,\n      letterSpacing: 0,\n    ),\n    headlineMedium: TextStyle(\n      fontSize: 20,\n      fontWeight: FontWeight.w600,\n      letterSpacing: 0.15,\n    ),\n    titleLarge: TextStyle(\n      fontSize: 18,\n      fontWeight: FontWeight.w500,\n      letterSpacing: 0.15,\n    ),\n    titleMedium: TextStyle(\n      fontSize: 16,\n      fontWeight: FontWeight.w500,\n      letterSpacing: 0.1,\n    ),\n    bodyLarge: TextStyle(\n      fontSize: 16,\n      fontWeight: FontWeight.normal,\n      letterSpacing: 0.5,\n    ),\n    bodyMedium: TextStyle(\n      fontSize: 14,\n      fontWeight: FontWeight.normal,\n      letterSpacing: 0.25,\n    ),\n    labelLarge: TextStyle(\n      fontSize: 14,\n      fontWeight: FontWeight.w500,\n      letterSpacing: 0.1,\n    ),\n  );\n}\n</code></pre>"},{"location":"ui/design-systems/#component-library","title":"Component Library","text":""},{"location":"ui/design-systems/#custom-buttons","title":"Custom Buttons","text":"<pre><code>// lib/shared/widgets/buttons/app_button.dart\nimport 'package:flutter/material.dart';\n\nenum AppButtonType { primary, secondary, outline, text }\n\nclass AppButton extends StatelessWidget {\n  final String text;\n  final VoidCallback? onPressed;\n  final AppButtonType type;\n  final bool isLoading;\n  final IconData? icon;\n  final double? width;\n\n  const AppButton({\n    super.key,\n    required this.text,\n    this.onPressed,\n    this.type = AppButtonType.primary,\n    this.isLoading = false,\n    this.icon,\n    this.width,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    Widget button;\n\n    switch (type) {\n      case AppButtonType.primary:\n        button = ElevatedButton(\n          onPressed: isLoading ? null : onPressed,\n          child: _buildContent(),\n        );\n        break;\n      case AppButtonType.secondary:\n        button = FilledButton.tonal(\n          onPressed: isLoading ? null : onPressed,\n          child: _buildContent(),\n        );\n        break;\n      case AppButtonType.outline:\n        button = OutlinedButton(\n          onPressed: isLoading ? null : onPressed,\n          child: _buildContent(),\n        );\n        break;\n      case AppButtonType.text:\n        button = TextButton(\n          onPressed: isLoading ? null : onPressed,\n          child: _buildContent(),\n        );\n        break;\n    }\n\n    return SizedBox(\n      width: width,\n      child: button,\n    );\n  }\n\n  Widget _buildContent() {\n    if (isLoading) {\n      return const SizedBox(\n        height: 20,\n        width: 20,\n        child: CircularProgressIndicator(strokeWidth: 2),\n      );\n    }\n\n    if (icon != null) {\n      return Row(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Icon(icon, size: 18),\n          const SizedBox(width: 8),\n          Text(text),\n        ],\n      );\n    }\n\n    return Text(text);\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#input-fields","title":"Input Fields","text":"<pre><code>// lib/shared/widgets/inputs/app_text_field.dart\nimport 'package:flutter/material.dart';\n\nclass AppTextField extends StatefulWidget {\n  final String? label;\n  final String? hint;\n  final String? errorText;\n  final bool obscureText;\n  final TextInputType keyboardType;\n  final TextEditingController? controller;\n  final ValueChanged&lt;String&gt;? onChanged;\n  final VoidCallback? onTap;\n  final bool readOnly;\n  final Widget? prefixIcon;\n  final Widget? suffixIcon;\n  final int? maxLines;\n  final int? maxLength;\n\n  const AppTextField({\n    super.key,\n    this.label,\n    this.hint,\n    this.errorText,\n    this.obscureText = false,\n    this.keyboardType = TextInputType.text,\n    this.controller,\n    this.onChanged,\n    this.onTap,\n    this.readOnly = false,\n    this.prefixIcon,\n    this.suffixIcon,\n    this.maxLines = 1,\n    this.maxLength,\n  });\n\n  @override\n  State&lt;AppTextField&gt; createState() =&gt; _AppTextFieldState();\n}\n\nclass _AppTextFieldState extends State&lt;AppTextField&gt; {\n  late bool _obscureText;\n\n  @override\n  void initState() {\n    super.initState();\n    _obscureText = widget.obscureText;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        if (widget.label != null) ...[\n          Text(\n            widget.label!,\n            style: Theme.of(context).textTheme.labelLarge,\n          ),\n          const SizedBox(height: 8),\n        ],\n        TextField(\n          controller: widget.controller,\n          obscureText: _obscureText,\n          keyboardType: widget.keyboardType,\n          onChanged: widget.onChanged,\n          onTap: widget.onTap,\n          readOnly: widget.readOnly,\n          maxLines: widget.maxLines,\n          maxLength: widget.maxLength,\n          decoration: InputDecoration(\n            hintText: widget.hint,\n            errorText: widget.errorText,\n            prefixIcon: widget.prefixIcon,\n            suffixIcon: widget.obscureText\n                ? IconButton(\n                    icon: Icon(_obscureText ? Icons.visibility : Icons.visibility_off),\n                    onPressed: () =&gt; setState(() =&gt; _obscureText = !_obscureText),\n                  )\n                : widget.suffixIcon,\n          ),\n        ),\n      ],\n    );\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#responsive-design","title":"Responsive Design","text":""},{"location":"ui/design-systems/#breakpoints","title":"Breakpoints","text":"<pre><code>// lib/core/utils/responsive.dart\nimport 'package:flutter/material.dart';\n\nclass Responsive {\n  static const double mobileBreakpoint = 600;\n  static const double tabletBreakpoint = 1024;\n  static const double desktopBreakpoint = 1440;\n\n  static bool isMobile(BuildContext context) =&gt;\n      MediaQuery.of(context).size.width &lt; mobileBreakpoint;\n\n  static bool isTablet(BuildContext context) =&gt;\n      MediaQuery.of(context).size.width &gt;= mobileBreakpoint &amp;&amp;\n      MediaQuery.of(context).size.width &lt; tabletBreakpoint;\n\n  static bool isDesktop(BuildContext context) =&gt;\n      MediaQuery.of(context).size.width &gt;= tabletBreakpoint;\n\n  static T responsive&lt;T&gt;(\n    BuildContext context, {\n    required T mobile,\n    T? tablet,\n    T? desktop,\n  }) {\n    if (isDesktop(context) &amp;&amp; desktop != null) return desktop;\n    if (isTablet(context) &amp;&amp; tablet != null) return tablet;\n    return mobile;\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#responsive-layout","title":"Responsive Layout","text":"<pre><code>// lib/shared/widgets/layout/responsive_layout.dart\nimport 'package:flutter/material.dart';\n\nclass ResponsiveLayout extends StatelessWidget {\n  final Widget mobile;\n  final Widget? tablet;\n  final Widget? desktop;\n\n  const ResponsiveLayout({\n    super.key,\n    required this.mobile,\n    this.tablet,\n    this.desktop,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        if (constraints.maxWidth &gt;= 1024) {\n          return desktop ?? tablet ?? mobile;\n        } else if (constraints.maxWidth &gt;= 600) {\n          return tablet ?? mobile;\n        } else {\n          return mobile;\n        }\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#animations","title":"Animations","text":""},{"location":"ui/design-systems/#custom-animations","title":"Custom Animations","text":"<pre><code>// lib/shared/widgets/animations/fade_in_animation.dart\nimport 'package:flutter/material.dart';\n\nclass FadeInAnimation extends StatefulWidget {\n  final Widget child;\n  final Duration duration;\n  final Duration delay;\n\n  const FadeInAnimation({\n    super.key,\n    required this.child,\n    this.duration = const Duration(milliseconds: 500),\n    this.delay = Duration.zero,\n  });\n\n  @override\n  State&lt;FadeInAnimation&gt; createState() =&gt; _FadeInAnimationState();\n}\n\nclass _FadeInAnimationState extends State&lt;FadeInAnimation&gt;\n    with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation&lt;double&gt; _animation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(duration: widget.duration, vsync: this);\n    _animation = Tween&lt;double&gt;(begin: 0.0, end: 1.0).animate(\n      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),\n    );\n\n    Future.delayed(widget.delay, () {\n      if (mounted) _controller.forward();\n    });\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: _animation,\n      child: widget.child,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#accessibility","title":"Accessibility","text":""},{"location":"ui/design-systems/#semantic-widgets","title":"Semantic Widgets","text":"<pre><code>// lib/shared/widgets/accessibility/semantic_button.dart\nimport 'package:flutter/material.dart';\n\nclass SemanticButton extends StatelessWidget {\n  final String label;\n  final String? hint;\n  final VoidCallback? onPressed;\n  final Widget child;\n\n  const SemanticButton({\n    super.key,\n    required this.label,\n    this.hint,\n    this.onPressed,\n    required this.child,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Semantics(\n      label: label,\n      hint: hint,\n      button: true,\n      enabled: onPressed != null,\n      child: GestureDetector(\n        onTap: onPressed,\n        child: child,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#platform-specific-design","title":"Platform-Specific Design","text":""},{"location":"ui/design-systems/#adaptive-widgets","title":"Adaptive Widgets","text":"<pre><code>// lib/shared/widgets/adaptive/adaptive_scaffold.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter/cupertino.dart';\nimport 'dart:io';\n\nclass AdaptiveScaffold extends StatelessWidget {\n  final Widget body;\n  final String? title;\n  final List&lt;Widget&gt;? actions;\n\n  const AdaptiveScaffold({\n    super.key,\n    required this.body,\n    this.title,\n    this.actions,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    if (Platform.isIOS) {\n      return CupertinoPageScaffold(\n        navigationBar: title != null\n            ? CupertinoNavigationBar(\n                middle: Text(title!),\n                trailing: actions != null\n                    ? Row(\n                        mainAxisSize: MainAxisSize.min,\n                        children: actions!,\n                      )\n                    : null,\n              )\n            : null,\n        child: body,\n      );\n    }\n\n    return Scaffold(\n      appBar: title != null\n          ? AppBar(\n              title: Text(title!),\n              actions: actions,\n            )\n          : null,\n      body: body,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/design-systems/#best-practices","title":"Best Practices","text":""},{"location":"ui/design-systems/#1-consistent-spacing","title":"1. Consistent Spacing","text":"<pre><code>class AppSpacing {\n  static const double xs = 4.0;\n  static const double sm = 8.0;\n  static const double md = 16.0;\n  static const double lg = 24.0;\n  static const double xl = 32.0;\n  static const double xxl = 48.0;\n}\n</code></pre>"},{"location":"ui/design-systems/#2-design-tokens","title":"2. Design Tokens","text":"<pre><code>class AppTokens {\n  // Border Radius\n  static const double radiusXs = 4.0;\n  static const double radiusSm = 8.0;\n  static const double radiusMd = 12.0;\n  static const double radiusLg = 16.0;\n\n  // Elevation\n  static const double elevationLow = 2.0;\n  static const double elevationMedium = 4.0;\n  static const double elevationHigh = 8.0;\n\n  // Animation Duration\n  static const Duration durationFast = Duration(milliseconds: 150);\n  static const Duration durationNormal = Duration(milliseconds: 300);\n  static const Duration durationSlow = Duration(milliseconds: 500);\n}\n</code></pre>"},{"location":"ui/design-systems/#3-theme-extensions","title":"3. Theme Extensions","text":"<pre><code>extension ThemeExtension on BuildContext {\n  ColorScheme get colorScheme =&gt; Theme.of(this).colorScheme;\n  TextTheme get textTheme =&gt; Theme.of(this).textTheme;\n\n  bool get isDarkMode =&gt; Theme.of(this).brightness == Brightness.dark;\n}\n</code></pre>"},{"location":"ui/design-systems/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Implement your design system components</li> <li>\u2705 Set up responsive breakpoints for your app</li> <li>\u2705 Add accessibility features to all interactive elements</li> <li>\u2705 Test your UI across different screen sizes and platforms</li> <li>\u2705 Proceed to Testing Documentation</li> </ol> <p>Your Flutter UI/UX design system is now ready for consistent, beautiful user interfaces!</p>"},{"location":"ui/responsive-design/","title":"Responsive Design","text":"<p>Comprehensive guide to creating responsive Flutter applications that work seamlessly across different screen sizes and orientations.</p>"},{"location":"ui/responsive-design/#overview","title":"Overview","text":"<p>Responsive design ensures your Flutter app provides an optimal user experience across phones, tablets, desktops, and web browsers. This guide covers adaptive layouts, breakpoints, and responsive patterns.</p>"},{"location":"ui/responsive-design/#screen-size-categories","title":"Screen Size Categories","text":""},{"location":"ui/responsive-design/#device-breakpoints","title":"Device Breakpoints","text":"<pre><code>// lib/utils/screen_utils.dart\nclass ScreenUtils {\n  static const double mobileBreakpoint = 600;\n  static const double tabletBreakpoint = 1024;\n  static const double desktopBreakpoint = 1440;\n\n  static bool isMobile(BuildContext context) {\n    return MediaQuery.of(context).size.width &lt; mobileBreakpoint;\n  }\n\n  static bool isTablet(BuildContext context) {\n    final width = MediaQuery.of(context).size.width;\n    return width &gt;= mobileBreakpoint &amp;&amp; width &lt; tabletBreakpoint;\n  }\n\n  static bool isDesktop(BuildContext context) {\n    return MediaQuery.of(context).size.width &gt;= tabletBreakpoint;\n  }\n\n  static ScreenType getScreenType(BuildContext context) {\n    final width = MediaQuery.of(context).size.width;\n    if (width &lt; mobileBreakpoint) return ScreenType.mobile;\n    if (width &lt; tabletBreakpoint) return ScreenType.tablet;\n    return ScreenType.desktop;\n  }\n}\n\nenum ScreenType { mobile, tablet, desktop }\n</code></pre>"},{"location":"ui/responsive-design/#responsive-widgets","title":"Responsive Widgets","text":""},{"location":"ui/responsive-design/#1-responsive-builder","title":"1. Responsive Builder","text":"<pre><code>// lib/widgets/responsive_builder.dart\nclass ResponsiveBuilder extends StatelessWidget {\n  final Widget mobile;\n  final Widget? tablet;\n  final Widget? desktop;\n\n  const ResponsiveBuilder({\n    Key? key,\n    required this.mobile,\n    this.tablet,\n    this.desktop,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        if (constraints.maxWidth &gt;= ScreenUtils.tabletBreakpoint) {\n          return desktop ?? tablet ?? mobile;\n        } else if (constraints.maxWidth &gt;= ScreenUtils.mobileBreakpoint) {\n          return tablet ?? mobile;\n        } else {\n          return mobile;\n        }\n      },\n    );\n  }\n}\n\n// Usage\nResponsiveBuilder(\n  mobile: MobileLayout(),\n  tablet: TabletLayout(),\n  desktop: DesktopLayout(),\n)\n</code></pre>"},{"location":"ui/responsive-design/#2-responsive-grid","title":"2. Responsive Grid","text":"<pre><code>// lib/widgets/responsive_grid.dart\nclass ResponsiveGrid extends StatelessWidget {\n  final List&lt;Widget&gt; children;\n  final double spacing;\n  final double runSpacing;\n\n  const ResponsiveGrid({\n    Key? key,\n    required this.children,\n    this.spacing = 8.0,\n    this.runSpacing = 8.0,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        final crossAxisCount = _getCrossAxisCount(constraints.maxWidth);\n\n        return GridView.builder(\n          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n            crossAxisCount: crossAxisCount,\n            crossAxisSpacing: spacing,\n            mainAxisSpacing: runSpacing,\n            childAspectRatio: 1.0,\n          ),\n          itemCount: children.length,\n          itemBuilder: (context, index) =&gt; children[index],\n        );\n      },\n    );\n  }\n\n  int _getCrossAxisCount(double width) {\n    if (width &gt; 1200) return 4;\n    if (width &gt; 800) return 3;\n    if (width &gt; 600) return 2;\n    return 1;\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#3-adaptive-container","title":"3. Adaptive Container","text":"<pre><code>// lib/widgets/adaptive_container.dart\nclass AdaptiveContainer extends StatelessWidget {\n  final Widget child;\n  final EdgeInsets? mobilePadding;\n  final EdgeInsets? tabletPadding;\n  final EdgeInsets? desktopPadding;\n\n  const AdaptiveContainer({\n    Key? key,\n    required this.child,\n    this.mobilePadding,\n    this.tabletPadding,\n    this.desktopPadding,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    EdgeInsets padding;\n\n    if (ScreenUtils.isDesktop(context)) {\n      padding = desktopPadding ?? const EdgeInsets.all(24.0);\n    } else if (ScreenUtils.isTablet(context)) {\n      padding = tabletPadding ?? const EdgeInsets.all(16.0);\n    } else {\n      padding = mobilePadding ?? const EdgeInsets.all(12.0);\n    }\n\n    return Container(\n      padding: padding,\n      child: child,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#layout-patterns","title":"Layout Patterns","text":""},{"location":"ui/responsive-design/#1-adaptive-navigation","title":"1. Adaptive Navigation","text":"<pre><code>// lib/widgets/adaptive_navigation.dart\nclass AdaptiveNavigation extends StatelessWidget {\n  final List&lt;NavigationItem&gt; items;\n  final int selectedIndex;\n  final ValueChanged&lt;int&gt; onItemSelected;\n\n  const AdaptiveNavigation({\n    Key? key,\n    required this.items,\n    required this.selectedIndex,\n    required this.onItemSelected,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (ScreenUtils.isDesktop(context)) {\n      return NavigationRail(\n        selectedIndex: selectedIndex,\n        onDestinationSelected: onItemSelected,\n        destinations: items.map((item) =&gt; NavigationRailDestination(\n          icon: Icon(item.icon),\n          label: Text(item.label),\n        )).toList(),\n      );\n    } else {\n      return BottomNavigationBar(\n        currentIndex: selectedIndex,\n        onTap: onItemSelected,\n        items: items.map((item) =&gt; BottomNavigationBarItem(\n          icon: Icon(item.icon),\n          label: item.label,\n        )).toList(),\n      );\n    }\n  }\n}\n\nclass NavigationItem {\n  final IconData icon;\n  final String label;\n\n  NavigationItem({required this.icon, required this.label});\n}\n</code></pre>"},{"location":"ui/responsive-design/#2-responsive-app-bar","title":"2. Responsive App Bar","text":"<pre><code>// lib/widgets/responsive_app_bar.dart\nclass ResponsiveAppBar extends StatelessWidget implements PreferredSizeWidget {\n  final String title;\n  final List&lt;Widget&gt;? actions;\n\n  const ResponsiveAppBar({\n    Key? key,\n    required this.title,\n    this.actions,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    if (ScreenUtils.isMobile(context)) {\n      return AppBar(\n        title: Text(title),\n        actions: actions,\n      );\n    } else {\n      return AppBar(\n        title: Text(title),\n        centerTitle: false,\n        actions: [\n          ...?actions,\n          if (ScreenUtils.isDesktop(context))\n            IconButton(\n              icon: const Icon(Icons.account_circle),\n              onPressed: () {},\n            ),\n        ],\n      );\n    }\n  }\n\n  @override\n  Size get preferredSize =&gt; const Size.fromHeight(kToolbarHeight);\n}\n</code></pre>"},{"location":"ui/responsive-design/#orientation-handling","title":"Orientation Handling","text":""},{"location":"ui/responsive-design/#1-orientation-builder","title":"1. Orientation Builder","text":"<pre><code>// lib/widgets/orientation_builder.dart\nclass OrientationAwareWidget extends StatelessWidget {\n  final Widget portrait;\n  final Widget? landscape;\n\n  const OrientationAwareWidget({\n    Key? key,\n    required this.portrait,\n    this.landscape,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return OrientationBuilder(\n      builder: (context, orientation) {\n        if (orientation == Orientation.landscape) {\n          return landscape ?? portrait;\n        }\n        return portrait;\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#2-adaptive-listgrid","title":"2. Adaptive List/Grid","text":"<pre><code>// lib/widgets/adaptive_list_grid.dart\nclass AdaptiveListGrid extends StatelessWidget {\n  final List&lt;Widget&gt; children;\n  final ScrollController? controller;\n\n  const AdaptiveListGrid({\n    Key? key,\n    required this.children,\n    this.controller,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return OrientationBuilder(\n      builder: (context, orientation) {\n        if (orientation == Orientation.landscape &amp;&amp; ScreenUtils.isTablet(context)) {\n          return GridView.count(\n            controller: controller,\n            crossAxisCount: 2,\n            children: children,\n          );\n        }\n        return ListView(\n          controller: controller,\n          children: children,\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#typography-scaling","title":"Typography Scaling","text":""},{"location":"ui/responsive-design/#1-responsive-text","title":"1. Responsive Text","text":"<pre><code>// lib/widgets/responsive_text.dart\nclass ResponsiveText extends StatelessWidget {\n  final String text;\n  final TextStyle? style;\n  final double? mobileSize;\n  final double? tabletSize;\n  final double? desktopSize;\n\n  const ResponsiveText(\n    this.text, {\n    Key? key,\n    this.style,\n    this.mobileSize,\n    this.tabletSize,\n    this.desktopSize,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    double fontSize;\n\n    if (ScreenUtils.isDesktop(context)) {\n      fontSize = desktopSize ?? 18.0;\n    } else if (ScreenUtils.isTablet(context)) {\n      fontSize = tabletSize ?? 16.0;\n    } else {\n      fontSize = mobileSize ?? 14.0;\n    }\n\n    return Text(\n      text,\n      style: (style ?? const TextStyle()).copyWith(fontSize: fontSize),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#2-adaptive-theme","title":"2. Adaptive Theme","text":"<pre><code>// lib/theme/adaptive_theme.dart\nclass AdaptiveTheme {\n  static ThemeData getTheme(BuildContext context) {\n    final textScaleFactor = ScreenUtils.isDesktop(context) ? 1.1 : 1.0;\n\n    return ThemeData(\n      textTheme: Theme.of(context).textTheme.apply(\n        fontSizeFactor: textScaleFactor,\n      ),\n      appBarTheme: AppBarTheme(\n        toolbarHeight: ScreenUtils.isMobile(context) ? 56.0 : 64.0,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#image-handling","title":"Image Handling","text":""},{"location":"ui/responsive-design/#1-responsive-images","title":"1. Responsive Images","text":"<pre><code>// lib/widgets/responsive_image.dart\nclass ResponsiveImage extends StatelessWidget {\n  final String imagePath;\n  final BoxFit? fit;\n\n  const ResponsiveImage({\n    Key? key,\n    required this.imagePath,\n    this.fit,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        String imageSuffix = '';\n\n        if (constraints.maxWidth &gt; 800) {\n          imageSuffix = '@3x';\n        } else if (constraints.maxWidth &gt; 400) {\n          imageSuffix = '@2x';\n        }\n\n        return Image.asset(\n          '${imagePath}$imageSuffix.png',\n          fit: fit ?? BoxFit.cover,\n          errorBuilder: (context, error, stackTrace) {\n            return Image.asset(imagePath, fit: fit ?? BoxFit.cover);\n          },\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#testing-responsive-design","title":"Testing Responsive Design","text":""},{"location":"ui/responsive-design/#1-device-preview","title":"1. Device Preview","text":"<pre><code>// lib/main.dart\nimport 'package:device_preview/device_preview.dart';\n\nvoid main() {\n  runApp(\n    DevicePreview(\n      enabled: !kReleaseMode,\n      builder: (context) =&gt; MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      useInheritedMediaQuery: true,\n      locale: DevicePreview.locale(context),\n      builder: DevicePreview.appBuilder,\n      home: HomeScreen(),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#2-responsive-testing","title":"2. Responsive Testing","text":"<pre><code>// test/responsive_test.dart\nvoid main() {\n  group('Responsive Widget Tests', () {\n    testWidgets('should show mobile layout on small screen', (tester) async {\n      await tester.binding.setSurfaceSize(const Size(400, 800));\n\n      await tester.pumpWidget(MaterialApp(\n        home: ResponsiveBuilder(\n          mobile: Text('Mobile'),\n          tablet: Text('Tablet'),\n          desktop: Text('Desktop'),\n        ),\n      ));\n\n      expect(find.text('Mobile'), findsOneWidget);\n      expect(find.text('Tablet'), findsNothing);\n      expect(find.text('Desktop'), findsNothing);\n    });\n\n    testWidgets('should show tablet layout on medium screen', (tester) async {\n      await tester.binding.setSurfaceSize(const Size(800, 600));\n\n      await tester.pumpWidget(MaterialApp(\n        home: ResponsiveBuilder(\n          mobile: Text('Mobile'),\n          tablet: Text('Tablet'),\n          desktop: Text('Desktop'),\n        ),\n      ));\n\n      expect(find.text('Tablet'), findsOneWidget);\n    });\n  });\n}\n</code></pre>"},{"location":"ui/responsive-design/#best-practices","title":"Best Practices","text":""},{"location":"ui/responsive-design/#1-performance-considerations","title":"1. Performance Considerations","text":"<pre><code>// Use const constructors where possible\nconst ResponsiveBuilder(\n  mobile: const MobileWidget(),\n  tablet: const TabletWidget(),\n);\n\n// Avoid rebuilding expensive widgets\nclass ExpensiveWidget extends StatelessWidget {\n  const ExpensiveWidget({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const SizedBox(); // Expensive widget content\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#2-accessibility","title":"2. Accessibility","text":"<pre><code>// Ensure touch targets are appropriately sized\nclass AccessibleButton extends StatelessWidget {\n  final VoidCallback onPressed;\n  final Widget child;\n\n  const AccessibleButton({\n    Key? key,\n    required this.onPressed,\n    required this.child,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final minSize = ScreenUtils.isMobile(context) ? 48.0 : 44.0;\n\n    return SizedBox(\n      width: minSize,\n      height: minSize,\n      child: ElevatedButton(\n        onPressed: onPressed,\n        child: child,\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"ui/responsive-design/#3-consistent-spacing","title":"3. Consistent Spacing","text":"<pre><code>// lib/theme/spacing.dart\nclass Spacing {\n  static double xs(BuildContext context) =&gt; ScreenUtils.isMobile(context) ? 4.0 : 6.0;\n  static double sm(BuildContext context) =&gt; ScreenUtils.isMobile(context) ? 8.0 : 12.0;\n  static double md(BuildContext context) =&gt; ScreenUtils.isMobile(context) ? 16.0 : 20.0;\n  static double lg(BuildContext context) =&gt; ScreenUtils.isMobile(context) ? 24.0 : 32.0;\n  static double xl(BuildContext context) =&gt; ScreenUtils.isMobile(context) ? 32.0 : 48.0;\n}\n</code></pre> <p>Responsive design is crucial for creating Flutter apps that work well across all devices. Start with mobile-first design and progressively enhance for larger screens.</p>"},{"location":"ui/styling-systems/","title":"Styling Systems","text":"<p>Comprehensive guide to creating consistent, maintainable styling systems in Flutter applications.</p>"},{"location":"ui/styling-systems/#overview","title":"Overview","text":"<p>A well-designed styling system ensures consistency across your Flutter app while making it easy to maintain and update visual elements. This guide covers theme management, design tokens, and component styling.</p>"},{"location":"ui/styling-systems/#theme-architecture","title":"Theme Architecture","text":""},{"location":"ui/styling-systems/#1-base-theme-structure","title":"1. Base Theme Structure","text":"<pre><code>// lib/theme/app_theme.dart\nclass AppTheme {\n  static ThemeData lightTheme = ThemeData(\n    useMaterial3: true,\n    colorScheme: _lightColorScheme,\n    textTheme: _textTheme,\n    appBarTheme: _appBarTheme,\n    elevatedButtonTheme: _elevatedButtonTheme,\n    inputDecorationTheme: _inputDecorationTheme,\n    cardTheme: _cardTheme,\n  );\n\n  static ThemeData darkTheme = ThemeData(\n    useMaterial3: true,\n    colorScheme: _darkColorScheme,\n    textTheme: _textTheme,\n    appBarTheme: _appBarThemeDark,\n    elevatedButtonTheme: _elevatedButtonTheme,\n    inputDecorationTheme: _inputDecorationThemeDark,\n    cardTheme: _cardThemeDark,\n  );\n}\n</code></pre>"},{"location":"ui/styling-systems/#2-color-system","title":"2. Color System","text":"<pre><code>// lib/theme/app_colors.dart\nclass AppColors {\n  // Primary colors\n  static const Color primary = Color(0xFF1976D2);\n  static const Color primaryVariant = Color(0xFF1565C0);\n  static const Color onPrimary = Color(0xFFFFFFFF);\n\n  // Secondary colors\n  static const Color secondary = Color(0xFF03DAC6);\n  static const Color secondaryVariant = Color(0xFF018786);\n  static const Color onSecondary = Color(0xFF000000);\n\n  // Surface colors\n  static const Color surface = Color(0xFFFFFFFF);\n  static const Color onSurface = Color(0xFF000000);\n  static const Color surfaceVariant = Color(0xFFF5F5F5);\n\n  // Error colors\n  static const Color error = Color(0xFFB00020);\n  static const Color onError = Color(0xFFFFFFFF);\n\n  // Neutral colors\n  static const Color neutral50 = Color(0xFFFAFAFA);\n  static const Color neutral100 = Color(0xFFF5F5F5);\n  static const Color neutral200 = Color(0xFFEEEEEE);\n  static const Color neutral300 = Color(0xFFE0E0E0);\n  static const Color neutral400 = Color(0xFFBDBDBD);\n  static const Color neutral500 = Color(0xFF9E9E9E);\n  static const Color neutral600 = Color(0xFF757575);\n  static const Color neutral700 = Color(0xFF616161);\n  static const Color neutral800 = Color(0xFF424242);\n  static const Color neutral900 = Color(0xFF212121);\n\n  // Semantic colors\n  static const Color success = Color(0xFF4CAF50);\n  static const Color warning = Color(0xFFFF9800);\n  static const Color info = Color(0xFF2196F3);\n}\n\n// Color schemes\nconst ColorScheme _lightColorScheme = ColorScheme(\n  brightness: Brightness.light,\n  primary: AppColors.primary,\n  onPrimary: AppColors.onPrimary,\n  secondary: AppColors.secondary,\n  onSecondary: AppColors.onSecondary,\n  error: AppColors.error,\n  onError: AppColors.onError,\n  surface: AppColors.surface,\n  onSurface: AppColors.onSurface,\n);\n\nconst ColorScheme _darkColorScheme = ColorScheme(\n  brightness: Brightness.dark,\n  primary: AppColors.primary,\n  onPrimary: AppColors.onPrimary,\n  secondary: AppColors.secondary,\n  onSecondary: AppColors.onSecondary,\n  error: AppColors.error,\n  onError: AppColors.onError,\n  surface: Color(0xFF121212),\n  onSurface: Color(0xFFFFFFFF),\n);\n</code></pre>"},{"location":"ui/styling-systems/#3-typography-system","title":"3. Typography System","text":"<pre><code>// lib/theme/app_typography.dart\nclass AppTypography {\n  static const String fontFamily = 'Inter';\n\n  // Font weights\n  static const FontWeight light = FontWeight.w300;\n  static const FontWeight regular = FontWeight.w400;\n  static const FontWeight medium = FontWeight.w500;\n  static const FontWeight semiBold = FontWeight.w600;\n  static const FontWeight bold = FontWeight.w700;\n\n  // Text styles\n  static const TextStyle h1 = TextStyle(\n    fontSize: 32,\n    fontWeight: bold,\n    height: 1.25,\n    letterSpacing: -0.5,\n  );\n\n  static const TextStyle h2 = TextStyle(\n    fontSize: 28,\n    fontWeight: bold,\n    height: 1.29,\n    letterSpacing: -0.5,\n  );\n\n  static const TextStyle h3 = TextStyle(\n    fontSize: 24,\n    fontWeight: semiBold,\n    height: 1.33,\n    letterSpacing: -0.5,\n  );\n\n  static const TextStyle h4 = TextStyle(\n    fontSize: 20,\n    fontWeight: semiBold,\n    height: 1.4,\n    letterSpacing: -0.25,\n  );\n\n  static const TextStyle h5 = TextStyle(\n    fontSize: 18,\n    fontWeight: medium,\n    height: 1.44,\n    letterSpacing: -0.25,\n  );\n\n  static const TextStyle h6 = TextStyle(\n    fontSize: 16,\n    fontWeight: medium,\n    height: 1.5,\n    letterSpacing: -0.25,\n  );\n\n  static const TextStyle bodyLarge = TextStyle(\n    fontSize: 16,\n    fontWeight: regular,\n    height: 1.5,\n    letterSpacing: 0,\n  );\n\n  static const TextStyle bodyMedium = TextStyle(\n    fontSize: 14,\n    fontWeight: regular,\n    height: 1.43,\n    letterSpacing: 0,\n  );\n\n  static const TextStyle bodySmall = TextStyle(\n    fontSize: 12,\n    fontWeight: regular,\n    height: 1.33,\n    letterSpacing: 0.25,\n  );\n\n  static const TextStyle caption = TextStyle(\n    fontSize: 12,\n    fontWeight: regular,\n    height: 1.33,\n    letterSpacing: 0.4,\n  );\n\n  static const TextStyle overline = TextStyle(\n    fontSize: 10,\n    fontWeight: medium,\n    height: 1.6,\n    letterSpacing: 1.5,\n  );\n}\n\n// Text theme\nconst TextTheme _textTheme = TextTheme(\n  displayLarge: AppTypography.h1,\n  displayMedium: AppTypography.h2,\n  displaySmall: AppTypography.h3,\n  headlineLarge: AppTypography.h4,\n  headlineMedium: AppTypography.h5,\n  headlineSmall: AppTypography.h6,\n  bodyLarge: AppTypography.bodyLarge,\n  bodyMedium: AppTypography.bodyMedium,\n  bodySmall: AppTypography.bodySmall,\n  labelLarge: AppTypography.caption,\n  labelMedium: AppTypography.overline,\n);\n</code></pre>"},{"location":"ui/styling-systems/#4-spacing-system","title":"4. Spacing System","text":"<pre><code>// lib/theme/app_spacing.dart\nclass AppSpacing {\n  static const double xs = 4.0;\n  static const double sm = 8.0;\n  static const double md = 16.0;\n  static const double lg = 24.0;\n  static const double xl = 32.0;\n  static const double xxl = 48.0;\n  static const double xxxl = 64.0;\n\n  // Semantic spacing\n  static const double elementSpacing = sm;\n  static const double sectionSpacing = lg;\n  static const double pageSpacing = xl;\n\n  // Edge insets\n  static const EdgeInsets paddingXS = EdgeInsets.all(xs);\n  static const EdgeInsets paddingSM = EdgeInsets.all(sm);\n  static const EdgeInsets paddingMD = EdgeInsets.all(md);\n  static const EdgeInsets paddingLG = EdgeInsets.all(lg);\n  static const EdgeInsets paddingXL = EdgeInsets.all(xl);\n\n  // Horizontal padding\n  static const EdgeInsets horizontalXS = EdgeInsets.symmetric(horizontal: xs);\n  static const EdgeInsets horizontalSM = EdgeInsets.symmetric(horizontal: sm);\n  static const EdgeInsets horizontalMD = EdgeInsets.symmetric(horizontal: md);\n  static const EdgeInsets horizontalLG = EdgeInsets.symmetric(horizontal: lg);\n  static const EdgeInsets horizontalXL = EdgeInsets.symmetric(horizontal: xl);\n\n  // Vertical padding\n  static const EdgeInsets verticalXS = EdgeInsets.symmetric(vertical: xs);\n  static const EdgeInsets verticalSM = EdgeInsets.symmetric(vertical: sm);\n  static const EdgeInsets verticalMD = EdgeInsets.symmetric(vertical: md);\n  static const EdgeInsets verticalLG = EdgeInsets.symmetric(vertical: lg);\n  static const EdgeInsets verticalXL = EdgeInsets.symmetric(vertical: xl);\n}\n</code></pre>"},{"location":"ui/styling-systems/#5-border-radius-system","title":"5. Border Radius System","text":"<pre><code>// lib/theme/app_radius.dart\nclass AppRadius {\n  static const double xs = 4.0;\n  static const double sm = 8.0;\n  static const double md = 12.0;\n  static const double lg = 16.0;\n  static const double xl = 24.0;\n  static const double xxl = 32.0;\n\n  // Border radius\n  static const BorderRadius radiusXS = BorderRadius.all(Radius.circular(xs));\n  static const BorderRadius radiusSM = BorderRadius.all(Radius.circular(sm));\n  static const BorderRadius radiusMD = BorderRadius.all(Radius.circular(md));\n  static const BorderRadius radiusLG = BorderRadius.all(Radius.circular(lg));\n  static const BorderRadius radiusXL = BorderRadius.all(Radius.circular(xl));\n  static const BorderRadius radiusXXL = BorderRadius.all(Radius.circular(xxl));\n\n  // Circular radius\n  static const BorderRadius circular = BorderRadius.all(Radius.circular(999));\n}\n</code></pre>"},{"location":"ui/styling-systems/#component-themes","title":"Component Themes","text":""},{"location":"ui/styling-systems/#1-button-themes","title":"1. Button Themes","text":"<pre><code>// lib/theme/component_themes/button_theme.dart\nclass AppButtonTheme {\n  static ElevatedButtonThemeData elevatedButtonTheme = ElevatedButtonThemeData(\n    style: ElevatedButton.styleFrom(\n      foregroundColor: AppColors.onPrimary,\n      backgroundColor: AppColors.primary,\n      elevation: 2,\n      shadowColor: AppColors.primary.withOpacity(0.3),\n      shape: RoundedRectangleBorder(\n        borderRadius: AppRadius.radiusMD,\n      ),\n      padding: const EdgeInsets.symmetric(\n        horizontal: AppSpacing.lg,\n        vertical: AppSpacing.md,\n      ),\n      textStyle: AppTypography.bodyMedium.copyWith(\n        fontWeight: AppTypography.semiBold,\n      ),\n    ),\n  );\n\n  static OutlinedButtonThemeData outlinedButtonTheme = OutlinedButtonThemeData(\n    style: OutlinedButton.styleFrom(\n      foregroundColor: AppColors.primary,\n      side: const BorderSide(color: AppColors.primary, width: 1.5),\n      shape: RoundedRectangleBorder(\n        borderRadius: AppRadius.radiusMD,\n      ),\n      padding: const EdgeInsets.symmetric(\n        horizontal: AppSpacing.lg,\n        vertical: AppSpacing.md,\n      ),\n      textStyle: AppTypography.bodyMedium.copyWith(\n        fontWeight: AppTypography.semiBold,\n      ),\n    ),\n  );\n\n  static TextButtonThemeData textButtonTheme = TextButtonThemeData(\n    style: TextButton.styleFrom(\n      foregroundColor: AppColors.primary,\n      padding: const EdgeInsets.symmetric(\n        horizontal: AppSpacing.md,\n        vertical: AppSpacing.sm,\n      ),\n      textStyle: AppTypography.bodyMedium.copyWith(\n        fontWeight: AppTypography.semiBold,\n      ),\n    ),\n  );\n}\n</code></pre>"},{"location":"ui/styling-systems/#2-input-themes","title":"2. Input Themes","text":"<pre><code>// lib/theme/component_themes/input_theme.dart\nclass AppInputTheme {\n  static InputDecorationTheme inputDecorationTheme = InputDecorationTheme(\n    filled: true,\n    fillColor: AppColors.neutral50,\n    border: OutlineInputBorder(\n      borderRadius: AppRadius.radiusMD,\n      borderSide: const BorderSide(color: AppColors.neutral300),\n    ),\n    enabledBorder: OutlineInputBorder(\n      borderRadius: AppRadius.radiusMD,\n      borderSide: const BorderSide(color: AppColors.neutral300),\n    ),\n    focusedBorder: OutlineInputBorder(\n      borderRadius: AppRadius.radiusMD,\n      borderSide: const BorderSide(color: AppColors.primary, width: 2),\n    ),\n    errorBorder: OutlineInputBorder(\n      borderRadius: AppRadius.radiusMD,\n      borderSide: const BorderSide(color: AppColors.error),\n    ),\n    contentPadding: AppSpacing.paddingMD,\n    labelStyle: AppTypography.bodyMedium.copyWith(\n      color: AppColors.neutral600,\n    ),\n    hintStyle: AppTypography.bodyMedium.copyWith(\n      color: AppColors.neutral500,\n    ),\n  );\n}\n</code></pre>"},{"location":"ui/styling-systems/#3-card-themes","title":"3. Card Themes","text":"<pre><code>// lib/theme/component_themes/card_theme.dart\nclass AppCardTheme {\n  static CardTheme cardTheme = CardTheme(\n    elevation: 2,\n    shadowColor: AppColors.neutral900.withOpacity(0.1),\n    shape: RoundedRectangleBorder(\n      borderRadius: AppRadius.radiusLG,\n    ),\n    margin: AppSpacing.paddingMD,\n  );\n}\n</code></pre>"},{"location":"ui/styling-systems/#custom-styled-components","title":"Custom Styled Components","text":""},{"location":"ui/styling-systems/#1-styled-container","title":"1. Styled Container","text":"<pre><code>// lib/widgets/styled_container.dart\nclass StyledContainer extends StatelessWidget {\n  final Widget child;\n  final EdgeInsets? padding;\n  final EdgeInsets? margin;\n  final Color? backgroundColor;\n  final BorderRadius? borderRadius;\n  final List&lt;BoxShadow&gt;? boxShadow;\n  final Border? border;\n\n  const StyledContainer({\n    Key? key,\n    required this.child,\n    this.padding,\n    this.margin,\n    this.backgroundColor,\n    this.borderRadius,\n    this.boxShadow,\n    this.border,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: padding ?? AppSpacing.paddingMD,\n      margin: margin,\n      decoration: BoxDecoration(\n        color: backgroundColor ?? Theme.of(context).colorScheme.surface,\n        borderRadius: borderRadius ?? AppRadius.radiusMD,\n        boxShadow: boxShadow,\n        border: border,\n      ),\n      child: child,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/styling-systems/#2-styled-text","title":"2. Styled Text","text":"<pre><code>// lib/widgets/styled_text.dart\nclass StyledText extends StatelessWidget {\n  final String text;\n  final TextStyle? style;\n  final Color? color;\n  final FontWeight? fontWeight;\n  final double? fontSize;\n  final TextAlign? textAlign;\n  final int? maxLines;\n  final TextOverflow? overflow;\n\n  const StyledText(\n    this.text, {\n    Key? key,\n    this.style,\n    this.color,\n    this.fontWeight,\n    this.fontSize,\n    this.textAlign,\n    this.maxLines,\n    this.overflow,\n  }) : super(key: key);\n\n  // Named constructors for common text styles\n  const StyledText.h1(\n    this.text, {\n    Key? key,\n    this.color,\n    this.textAlign,\n    this.maxLines,\n    this.overflow,\n  }) : style = AppTypography.h1,\n       fontWeight = null,\n       fontSize = null,\n       super(key: key);\n\n  const StyledText.h2(\n    this.text, {\n    Key? key,\n    this.color,\n    this.textAlign,\n    this.maxLines,\n    this.overflow,\n  }) : style = AppTypography.h2,\n       fontWeight = null,\n       fontSize = null,\n       super(key: key);\n\n  const StyledText.body(\n    this.text, {\n    Key? key,\n    this.color,\n    this.fontWeight,\n    this.textAlign,\n    this.maxLines,\n    this.overflow,\n  }) : style = AppTypography.bodyMedium,\n       fontSize = null,\n       super(key: key);\n\n  const StyledText.caption(\n    this.text, {\n    Key? key,\n    this.color,\n    this.textAlign,\n    this.maxLines,\n    this.overflow,\n  }) : style = AppTypography.caption,\n       fontWeight = null,\n       fontSize = null,\n       super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final effectiveStyle = (style ?? AppTypography.bodyMedium).copyWith(\n      color: color,\n      fontWeight: fontWeight,\n      fontSize: fontSize,\n    );\n\n    return Text(\n      text,\n      style: effectiveStyle,\n      textAlign: textAlign,\n      maxLines: maxLines,\n      overflow: overflow,\n    );\n  }\n}\n</code></pre>"},{"location":"ui/styling-systems/#theme-extensions","title":"Theme Extensions","text":""},{"location":"ui/styling-systems/#1-custom-theme-extension","title":"1. Custom Theme Extension","text":"<pre><code>// lib/theme/custom_theme_extension.dart\n@immutable\nclass CustomThemeExtension extends ThemeExtension&lt;CustomThemeExtension&gt; {\n  final Color? brandColor;\n  final Color? successColor;\n  final Color? warningColor;\n  final Color? infoColor;\n  final double? customSpacing;\n\n  const CustomThemeExtension({\n    this.brandColor,\n    this.successColor,\n    this.warningColor,\n    this.infoColor,\n    this.customSpacing,\n  });\n\n  @override\n  CustomThemeExtension copyWith({\n    Color? brandColor,\n    Color? successColor,\n    Color? warningColor,\n    Color? infoColor,\n    double? customSpacing,\n  }) {\n    return CustomThemeExtension(\n      brandColor: brandColor ?? this.brandColor,\n      successColor: successColor ?? this.successColor,\n      warningColor: warningColor ?? this.warningColor,\n      infoColor: infoColor ?? this.infoColor,\n      customSpacing: customSpacing ?? this.customSpacing,\n    );\n  }\n\n  @override\n  CustomThemeExtension lerp(ThemeExtension&lt;CustomThemeExtension&gt;? other, double t) {\n    if (other is! CustomThemeExtension) {\n      return this;\n    }\n\n    return CustomThemeExtension(\n      brandColor: Color.lerp(brandColor, other.brandColor, t),\n      successColor: Color.lerp(successColor, other.successColor, t),\n      warningColor: Color.lerp(warningColor, other.warningColor, t),\n      infoColor: Color.lerp(infoColor, other.infoColor, t),\n      customSpacing: lerpDouble(customSpacing, other.customSpacing, t),\n    );\n  }\n\n  static const light = CustomThemeExtension(\n    brandColor: AppColors.primary,\n    successColor: AppColors.success,\n    warningColor: AppColors.warning,\n    infoColor: AppColors.info,\n    customSpacing: 20.0,\n  );\n\n  static const dark = CustomThemeExtension(\n    brandColor: AppColors.primary,\n    successColor: AppColors.success,\n    warningColor: AppColors.warning,\n    infoColor: AppColors.info,\n    customSpacing: 20.0,\n  );\n}\n\n// Usage\nextension CustomThemeExtensionGetter on ThemeData {\n  CustomThemeExtension get customTheme =&gt;\n      extension&lt;CustomThemeExtension&gt;() ?? CustomThemeExtension.light;\n}\n</code></pre>"},{"location":"ui/styling-systems/#responsive-styling","title":"Responsive Styling","text":""},{"location":"ui/styling-systems/#1-responsive-values","title":"1. Responsive Values","text":"<pre><code>// lib/theme/responsive_values.dart\nclass ResponsiveValues {\n  static double getSpacing(BuildContext context, {\n    double mobile = AppSpacing.md,\n    double tablet = AppSpacing.lg,\n    double desktop = AppSpacing.xl,\n  }) {\n    final screenWidth = MediaQuery.of(context).size.width;\n    if (screenWidth &gt; 1024) return desktop;\n    if (screenWidth &gt; 600) return tablet;\n    return mobile;\n  }\n\n  static double getFontSize(BuildContext context, {\n    double mobile = 14,\n    double tablet = 16,\n    double desktop = 18,\n  }) {\n    final screenWidth = MediaQuery.of(context).size.width;\n    if (screenWidth &gt; 1024) return desktop;\n    if (screenWidth &gt; 600) return tablet;\n    return mobile;\n  }\n}\n</code></pre>"},{"location":"ui/styling-systems/#theme-management","title":"Theme Management","text":""},{"location":"ui/styling-systems/#1-theme-provider","title":"1. Theme Provider","text":"<pre><code>// lib/providers/theme_provider.dart\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  ThemeMode get themeMode =&gt; _themeMode;\n\n  void setThemeMode(ThemeMode themeMode) {\n    _themeMode = themeMode;\n    notifyListeners();\n    _saveThemeMode(themeMode);\n  }\n\n  void toggleTheme() {\n    if (_themeMode == ThemeMode.light) {\n      setThemeMode(ThemeMode.dark);\n    } else {\n      setThemeMode(ThemeMode.light);\n    }\n  }\n\n  Future&lt;void&gt; _saveThemeMode(ThemeMode themeMode) async {\n    final prefs = await SharedPreferences.getInstance();\n    await prefs.setString('theme_mode', themeMode.toString());\n  }\n\n  Future&lt;void&gt; loadThemeMode() async {\n    final prefs = await SharedPreferences.getInstance();\n    final themeModeString = prefs.getString('theme_mode');\n    if (themeModeString != null) {\n      _themeMode = ThemeMode.values.firstWhere(\n        (mode) =&gt; mode.toString() == themeModeString,\n        orElse: () =&gt; ThemeMode.system,\n      );\n      notifyListeners();\n    }\n  }\n}\n</code></pre> <p>A well-structured styling system is the foundation of a maintainable Flutter app. Invest time in setting up consistent design tokens and component themes early in your project.</p>"}]}